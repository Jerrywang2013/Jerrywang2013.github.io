<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>QT | Jerry Blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="QGlobal​		QGlobal.h中定义了一些全局的类型定义、宏、函数 类型： 123qint8 | qint16 |qint32 |qint64   quint8 | quint16 |quint32 |quint64qlonglong | qulonglong  qrealuchar | uint | ulong | ushort  这里uint是unsigned int  函数： 1qA">
<meta property="og:type" content="article">
<meta property="og:title" content="QT">
<meta property="og:url" content="https://jerrywang2013.github.io/2024/05/18/QT/index.html">
<meta property="og:site_name" content="Jerry Blogs">
<meta property="og:description" content="QGlobal​		QGlobal.h中定义了一些全局的类型定义、宏、函数 类型： 123qint8 | qint16 |qint32 |qint64   quint8 | quint16 |quint32 |quint64qlonglong | qulonglong  qrealuchar | uint | ulong | ushort  这里uint是unsigned int  函数： 1qA">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://jerrywang2013.github.io/2024/05/18/QT/image-20240518091304577.png">
<meta property="article:published_time" content="2024-05-18T00:56:13.000Z">
<meta property="article:modified_time" content="2024-06-03T23:31:43.548Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="c++ lua php js python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jerrywang2013.github.io/2024/05/18/QT/image-20240518091304577.png">
  
    <link rel="alternate" href="/atom.xml" title="Jerry Blogs" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Jerry Blogs</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://jerrywang2013.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-QT" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/05/18/QT/" class="article-date">
  <time class="dt-published" datetime="2024-05-18T00:56:13.000Z" itemprop="datePublished">2024-05-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      QT
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="QGlobal"><a href="#QGlobal" class="headerlink" title="QGlobal"></a>QGlobal</h1><p>​		QGlobal.h中定义了一些全局的类型定义、宏、函数</p>
<p>类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">qint8 | qint16 |qint32 |qint64   quint8 | quint16 |quint32 |quint64</span><br><span class="line">qlonglong | qulonglong  qreal</span><br><span class="line">uchar | uint | ulong | ushort  这里uint是unsigned int</span><br></pre></td></tr></table></figure>

<p>函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qAbs | qBound | qMax | qMin | qRound | qRound64 | qOverload | qVersion | q_check_ptr</span><br></pre></td></tr></table></figure>

<p>宏</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">QT_DEPRECATED_WARNINGS | QT_VERSION | QT_VERSION_CHECK | QT_VERSION_STR</span><br><span class="line">Q_ASSERT | Q_ASSERT_X</span><br><span class="line">Q_BYTE_ORDER | Q_BIG_ENDIAN | Q_LITTLE_ENDIAN</span><br><span class="line">Q_DECL_EXPORT | Q_DECL_IMPORT</span><br><span class="line">foreach(var, container)</span><br><span class="line">qDebug | qInfo | qWarning | qCritical | qFatal</span><br><span class="line">qMove</span><br><span class="line">qPrintable: 将QString转为const char*，等价于str.toLocal8Bit().constData()</span><br><span class="line">qUtf8Printable: 转为utf8编码格式的const char *</span><br><span class="line">qUtf16Printable：QString转为const ushort*，等价于str.utf16()</span><br></pre></td></tr></table></figure>



<h1 id="QString"><a href="#QString" class="headerlink" title="QString"></a>QString</h1><p>QT字符串类，包括字符操作、编码转换、字符串和数值转换（包括进制）</p>
<ul>
<li><p>static函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">QString::asprintf(const char *format);</span><br><span class="line">vasprintf(const char *format, va_list ap);</span><br><span class="line">fromLatin1</span><br><span class="line">fromLocal8Bit</span><br><span class="line">fromStdString</span><br><span class="line">fromUcs4</span><br><span class="line">fromUtf8</span><br><span class="line">fromUtf16</span><br><span class="line">fromWCharArray</span><br><span class="line">number() ==&gt; 数值型转为字符串</span><br></pre></td></tr></table></figure>


</li>
<li><p>字符串&lt;&#x3D;&gt;数值转换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">数值=&gt;字符串</span><br><span class="line">QString QString::number(long n, int base = 10)</span><br><span class="line">QString&amp; setnum()</span><br><span class="line">arg()</span><br><span class="line"></span><br><span class="line">字符串=&gt;数值</span><br><span class="line">toInt | toLong | toLongLong |toFloat</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">int intValue = 42;</span><br><span class="line">double doubleValue = 3.14159;</span><br><span class="line">QString intString = QString::number(intValue); // &quot;42&quot;</span><br><span class="line">QString doubleString = QString::number(doubleValue, &#x27;f&#x27;, 2); </span><br><span class="line"></span><br><span class="line">int intValue = 42;</span><br><span class="line">double doubleValue = 3.14159;</span><br><span class="line">QString formattedString = QString(&quot;Integer: %1, Double: %2&quot;).arg(intValue).arg(doubleValue, 0, &#x27;f&#x27;, 2);</span><br><span class="line"></span><br><span class="line">int intValue = intString.toInt(&amp;ok);</span><br><span class="line">float floatValue = floatString.toFloat(&amp;ok);</span><br><span class="line">double doubleValue = doubleString.toDouble(&amp;ok);</span><br></pre></td></tr></table></figure>


</li>
<li><p>编码转换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// QString 转utf8、Latin1、local 8bit</span><br><span class="line">QString()::toUtf8() | toLatin1() | toLocal8Bit()</span><br><span class="line">// 从XX转为QString</span><br><span class="line">QString::fromUtf8() | fromLatin1() | from Local8Bit</span><br></pre></td></tr></table></figure>

<p>也可以借助QTextCodec类完成复杂的编码转换，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QTextCodec&gt; </span><br><span class="line">QString str = &quot;你好，世界&quot;; </span><br><span class="line">// 将 QString 转换为 GBK 编码的 </span><br><span class="line">QByteArray QTextCodec *codec = QTextCodec::codecForName(&quot;GBK&quot;); </span><br><span class="line">QByteArray gbkBytes = codec-&gt;fromUnicode(str); </span><br><span class="line">// 从 GBK 编码的 QByteArray 转换为 QString </span><br><span class="line">QString decodedStr = codec-&gt;toUnicode(gbkBytes);</span><br></pre></td></tr></table></figure>

<p>QT6里头有QStringConverter用于编码转换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QStringConverter&gt; </span><br><span class="line">QString str = &quot;Hello, 世界&quot;; </span><br><span class="line">// 将 QString 转换为 UTF-8 编码的 </span><br><span class="line">QByteArray auto utf8Bytes = QStringConverter::encode(QStringConverter::Utf8, str); </span><br><span class="line">// 从 UTF-8 编码的 QByteArray 转换为 QString </span><br><span class="line">auto decodedStr = QStringConverter::decode(QStringConverter::Utf8, utf8Bytes);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="日期时间类"><a href="#日期时间类" class="headerlink" title="日期时间类"></a>日期时间类</h1><p>QTime</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 构造QTime类</span><br><span class="line">currentTime()</span><br><span class="line">fromString(const QString &amp;string, const QString &amp;format)</span><br><span class="line">// 时间格式化，例如 HH-mm-ss</span><br><span class="line">toString(format)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 获取小时、分钟、秒、毫秒</span><br><span class="line">hour() | minute() | second() | msec()</span><br><span class="line">// 时间比较</span><br><span class="line">operator&lt; | &lt;= | == | &gt; | &gt;=</span><br><span class="line"></span><br><span class="line">// 用于计时类</span><br><span class="line">QTime t;</span><br><span class="line">t.start();</span><br><span class="line">do_some_task();</span><br><span class="line">qDebug(&quot;time elapsed:%d ms&quot;, t.elapsed());</span><br></pre></td></tr></table></figure>

<p>QDate</p>
<p>QDateTime</p>
<h1 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h1><h2 id="Q：如何理解qt中的signal和slot"><a href="#Q：如何理解qt中的signal和slot" class="headerlink" title="Q：如何理解qt中的signal和slot"></a>Q：<strong>如何理解qt中的signal和slot</strong></h2><p>A：简单点说，signal类似事件或者消息，slot类似事件或者消息handler；常见的需求是动作发生后对应的事件（或者消息）被触发进而触发对应的handler处理，这样的话，只需要捕获动作对应的事件和消息即可。slot这里可以自定义，也有一部分预先定义好的，比如window有一个关闭的slot，那么我们可以将一个按钮的点击信号关联到窗口的关闭handler，实现点击按钮就关闭窗口的效果。</p>
<p>​		用slot这个概念很形象，功能handler就像一个插槽一样，这里的siganal和slot就像将电线接到插槽上形成通路一样，signal发出就会触发handler执行。</p>
<p>signale和slot的连接通过 <code>**QObject::connect**</code>实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FooObjectA *fooA = new FooObjectA();</span><br><span class="line">FooObjectB *fooB = new FooObjectB();</span><br><span class="line"></span><br><span class="line">QObject::connect(fooA, SIGNAL(bared()), fooB, SLOT (baz()));</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li><p>信号由对象发出，表示某个事件发生，例如按钮点击会发出一个clicked()信号。信号不需要再类外定义，它们由qt的元系统（MOS）自动生成。</p>
</li>
<li><p>槽是一个函数，可以连接到信号，信号发生时，连接到该信号的槽函数被调用。槽可以是任意成员函数、全局函数或者lambda表达式。槽需要在类外定义，和普通成员函数一样。</p>
</li>
<li><p>signal可以连接signal，从这个角度看，signal可以充当信号中转。</p>
<p>例如： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class MyWidget : public QWidget</span><br><span class="line"> &#123;</span><br><span class="line">     Q_OBJECT</span><br><span class="line"> public:</span><br><span class="line">     MyWidget();</span><br><span class="line"> signals:</span><br><span class="line">     void buttonClicked();</span><br><span class="line"> private:</span><br><span class="line">     QPushButton *myButton;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> MyWidget::MyWidget()</span><br><span class="line"> &#123;</span><br><span class="line">     myButton = new QPushButton(this);</span><br><span class="line">     connect(myButton, SIGNAL(clicked()),</span><br><span class="line">             this, SIGNAL(buttonClicked()));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



</li>
<li><p>connect有多个重载版本，使用SIGNAL宏的好处是可以指定带参数的型号，并且不需要指定类名</p>
<p>如果不用SIGNAL需要将重载成员函数进行明确的类型转换指定确定的重载版本，</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span> : <span class="keyword">public</span> QObject &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">valueChanged</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">valueChanged</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">QObject::<span class="built_in">connect</span>(obj, <span class="built_in">static_cast</span>&lt;<span class="built_in">void</span> (MyObject::*)(<span class="type">int</span>)&gt;(&amp;MyObject::valueChanged), [](<span class="type">int</span> value) &#123;</span><br><span class="line">    <span class="comment">// 处理 int 类型的 valueChanged 信号</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">QObject::<span class="built_in">connect</span>(obj, <span class="built_in">static_cast</span>&lt;<span class="built_in">void</span> (MyObject::*)(<span class="type">double</span>)&gt;(&amp;MyObject::valueChanged), [](<span class="type">double</span> value) &#123;</span><br><span class="line">    <span class="comment">// 处理 double 类型的 valueChanged 信号</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Q：Qt-Designer对mainwindow重置布局就会导致程序崩溃"><a href="#Q：Qt-Designer对mainwindow重置布局就会导致程序崩溃" class="headerlink" title="Q：Qt Designer对mainwindow重置布局就会导致程序崩溃"></a><strong>Q：Qt Designer对mainwindow重置布局就会导致程序崩溃</strong></h2><p><strong>A：</strong>暂时不知！</p>
<h2 id="Q-Qt-designer中如何用自定义类替换默认的widget类"><a href="#Q-Qt-designer中如何用自定义类替换默认的widget类" class="headerlink" title="Q: Qt designer中如何用自定义类替换默认的widget类"></a>Q: Qt designer中如何用自定义类替换默认的widget类</h2><p>A：比如说Designer中有一个PushButton，我们写了一个自定义的CustomPushButton类，派生自PushButton，有自定义的slot例如myButtonSlot，我们想在Designer中创建连接，选择PushButton然后能选择myButtonSlot。经过测试发现，可以通过在Designer中选择模板PushButton按钮，右键菜单选择“提升”，在弹出的提升对话框中编辑“提升类名称”为CustomPushButton，点击“添加”，添加完毕之后再点击“提升”就可以将此空间提升为CustomPushButton类型。</p>
<p>​		提升之后，我们查看对应的ui文件可以发现，有一段<customwidgets>有新增一个CustomPushButton类型，同时我们发现我们刚才提升的按钮，其class属性由原来的PushButton更新为CustomPushButton了。</customwidgets></p>
<p>​		到此，类是提升了，但是我们在编辑连接的时候，选择了已经提升的按钮，仍然无法看到CustomPushButton类中定义的slot。好像designer并不会扫描我们的CustomPUshButton.h文件获取其中定义的slots，要要designer能知道我们类中定义的slots，需要在目标按钮控件上点击右键，点击菜单项“改变信号和槽”，然后手动添加我们CustomPushButton中自定义的槽，这样就可以在designer中可以选择目标按钮的自定义槽。</p>
<h2 id="Q：界面ui文件如何生成相应的代码"><a href="#Q：界面ui文件如何生成相应的代码" class="headerlink" title="Q：界面ui文件如何生成相应的代码"></a>Q：界面ui文件如何生成相应的代码</h2><p><strong>A：</strong>默认情况下，通过designer创建一个界面(例如mainwindow.ui)文件，会同步自动创建对应的界面类mainwindow.h和mainwindow.cpp文件，并且在编译之后在编译目录生成ui_mainwindow.h文件，此文件是解析界面mainwindow.ui文件(xml)，生成对应窗口的创建代码。</p>
<p>​		对应的mainwindow.h定义的是类MainWindow，生成的ui_mainwindow.h对应的是界面类UI::MainWindow(等价于编译生成文件中的Ui_MainWindow类)，然后MainWindow类中成员ui指针类型是UI::MainWindow*，MainWindow构造函数会new UI::MainWindow对象赋值给ui，然后调用UI::MainWindow::setupUi来初始化界面元素。</p>
<h2 id="Q：为何有些ui文件编译时不会生成对应的ui-xxx-h文件？"><a href="#Q：为何有些ui文件编译时不会生成对应的ui-xxx-h文件？" class="headerlink" title="Q：为何有些ui文件编译时不会生成对应的ui_xxx.h文件？"></a><strong>Q：为何有些ui文件编译时不会生成对应的ui_xxx.h文件？</strong></h2><p><strong>A：</strong>项目编译的时候，会用预处理工具uic对ui文件进行处理，生成对应的头文件，并非所有的ui文件在编译的时候都会生成对应的头文件，因为uic只会对工程pro文件中的FORMS参数中的ui进行预编译生成对应的头文件。用qt creator创建ui文件一般会自动添加到项目中，会自动修改pro文件，将ui追加到FORMS变量中。</p>
<h2 id="Q：mainwindow-cpp为何可以直接-include-“ui-mainwindow-h”？他们并不在同一个目录"><a href="#Q：mainwindow-cpp为何可以直接-include-“ui-mainwindow-h”？他们并不在同一个目录" class="headerlink" title="Q：mainwindow.cpp为何可以直接#include “ui_mainwindow.h”？他们并不在同一个目录"></a><strong>Q：mainwindow.cpp为何可以直接#include “ui_mainwindow.h”？他们并不在同一个目录</strong></h2><p><strong>A：</strong>ui文件不一定非要放在项目目录下，比如放在&#x2F;ui&#x2F;mainwindow.ui，只需要修改pro文件FORMS中ui文件的路径即可，例如FORMS +&#x3D; ui&#x2F;mainwindow.ui。ui编译后生成的ui_mainwindow.h文件在build目录下，mainwindow.cpp是直接include ui_mainwindow.h，哪里头文件搜索路径在哪里设置的？pro文件并没有看到include文件搜索路径。</p>
<p>​		pro文件确实没有，这个是qt默认的生成规则，qmake在处理pro文件的时候会生成makefile文件，我们可以打开makefile.debug文件看一下，里头INCPATH并没有包括了build目录。这是因为生成的ui_mainwindow.h文件和makefile文件是同一个目录，所以对ui_mainwindow.h文件的引用并不需要在incpath中添加路径。但是mainwindow.cpp文件在项目目录而不是build目录，和ui_mainwindow.h文件不在同一个目录之所以能直接#include “ui_maindown.h”，是因为makefile文件中mainwindow.cpp目标依赖是..\..\mainwindow.cpp。</p>
<h2 id="Q：除了用uic编译ui文件生成-h文件，还有没有其他办法使用ui文件？"><a href="#Q：除了用uic编译ui文件生成-h文件，还有没有其他办法使用ui文件？" class="headerlink" title="Q：除了用uic编译ui文件生成.h文件，还有没有其他办法使用ui文件？"></a><strong>Q：除了用uic编译ui文件生成.h文件，还有没有其他办法使用ui文件？</strong></h2><p><strong>A：</strong>还可以用QUiLoader，需要使用QtUiTools库（修改pro文件的QT +&#x3D; widgets uitools）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 这里calculatorform.ui是在资源文件下的forms过滤器下</span><br><span class="line">QFile file(&quot;:/forms/calculatorform.ui&quot;);</span><br><span class="line">file.open(QFile::ReadOnly);</span><br><span class="line">QWidget *formWidget = loader.load(&amp;file, this);</span><br><span class="line">file.close();</span><br></pre></td></tr></table></figure>



<h2 id="Q-QObject-findChild"><a href="#Q-QObject-findChild" class="headerlink" title="Q:  QObject::findChild"></a><strong>Q:  QObject::findChild</strong></h2><p><strong>A:</strong> 可用于Widget查找子窗体。todo…</p>
<h2 id="Q-QObject-staticMetaObject"><a href="#Q-QObject-staticMetaObject" class="headerlink" title="Q: QObject::staticMetaObject"></a><strong>Q: QObject::staticMetaObject</strong></h2><p><strong>A:</strong><code>staticMetaObject</code> 是 Qt 中 QObject 类的静态成员，它返回与特定对象类型相关联的元对象。元对象（Meta Object）是 QObject 的一个重要概念，它包含了有关对象类型的元信息，比如对象的类名、父类、属性、信号和槽等信息。</p>
<p>对于任何继承自 QObject 的类，都可以使用 <code>staticMetaObject</code> 来获取与其相关联的元对象。这个元对象是在编译时生成的，包含了所有静态信息，因此可以在运行时快速地访问对象的元信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QObject&gt;</span><br><span class="line"></span><br><span class="line">// 定义一个继承自 QObject 的类</span><br><span class="line">class MyClass : public QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    // 其他类定义</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 在需要获取元对象的地方，使用 staticMetaObject</span><br><span class="line">const QMetaObject *metaObject = MyClass::staticMetaObject;</span><br></pre></td></tr></table></figure>

<p>​		上面的代码定义了一个继承自 QObject 的类 MyClass，并在需要的地方使用了 <code>staticMetaObject</code> 获取了 MyClass 类的元对象。一旦获取了元对象，就可以通过元对象访问对象的各种属性、信号和槽等元信息。</p>
<ul>
<li><p><strong>访问属性信息</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 获取属性个数</span><br><span class="line">int propertyCount = metaObject-&gt;propertyCount();</span><br><span class="line"></span><br><span class="line">// 遍历所有属性</span><br><span class="line">for (int i = 0; i &lt; propertyCount; ++i) &#123;</span><br><span class="line">    QMetaProperty property = metaObject-&gt;property(i);</span><br><span class="line">    qDebug() &lt;&lt; &quot;Property Name: &quot; &lt;&lt; property.name();</span><br><span class="line">    qDebug() &lt;&lt; &quot;Property Type: &quot; &lt;&lt; property.typeName();</span><br><span class="line">    qDebug() &lt;&lt; &quot;Is Readable: &quot; &lt;&lt; property.isReadable();</span><br><span class="line">    qDebug() &lt;&lt; &quot;Is Writable: &quot; &lt;&lt; property.isWritable();</span><br><span class="line">    // 其他属性信息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>访问信号信息</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 获取信号个数</span><br><span class="line">int signalCount = metaObject-&gt;methodCount();</span><br><span class="line">for (int i = metaObject-&gt;methodOffset(); i &lt; signalCount; ++i) &#123;</span><br><span class="line">    QMetaMethod method = metaObject-&gt;method(i);</span><br><span class="line">    if (method.methodType() == QMetaMethod::Signal) &#123;</span><br><span class="line">        qDebug() &lt;&lt; &quot;Signal Name: &quot; &lt;&lt; method.name();</span><br><span class="line">        qDebug() &lt;&lt; &quot;Parameter Types: &quot; &lt;&lt; method.parameterTypes();</span><br><span class="line">        // 其他信号信息</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>访问slot信息</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 获取槽个数</span><br><span class="line">int slotCount = metaObject-&gt;methodCount();</span><br><span class="line">for (int i = metaObject-&gt;methodOffset(); i &lt; slotCount; ++i) &#123;</span><br><span class="line">    QMetaMethod method = metaObject-&gt;method(i);</span><br><span class="line">    if (method.methodType() == QMetaMethod::Slot) &#123;</span><br><span class="line">        qDebug() &lt;&lt; &quot;Slot Name: &quot; &lt;&lt; method.name();</span><br><span class="line">        qDebug() &lt;&lt; &quot;Parameter Types: &quot; &lt;&lt; method.parameterTypes();</span><br><span class="line">        // 其他槽信息</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>调用槽函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个对象</span><br><span class="line">QObject *obj = new QObject();</span><br><span class="line"></span><br><span class="line">// 获取槽函数的索引</span><br><span class="line">int slotIndex = metaObject-&gt;indexOfSlot(&quot;slotFunctionName()&quot;);</span><br><span class="line"></span><br><span class="line">// 调用槽函数</span><br><span class="line">if (slotIndex != -1) &#123;</span><br><span class="line">    QMetaMethod slotMethod = metaObject-&gt;method(slotIndex);</span><br><span class="line">    slotMethod.invoke(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Q：解析moc-classname-cpp文件"><a href="#Q：解析moc-classname-cpp文件" class="headerlink" title="Q：解析moc_classname.cpp文件"></a><strong>Q：解析moc_classname.cpp文件</strong></h2><p><strong>A：</strong>对象声明文件中如果有Q_OBJECT宏，则会生成moc_classname.cpp文件。</p>
<p><code>qt_meta_stringdata_TextFinder</code>：signal和slot声明的函数原型涉及到的返回值、函数名、参数类型、参数名等等的字符串表。本质是一个字符串表，里头把所有用到的字符串去重后统一存在一个字符数组中，然后建立一个索引表（索引数组，可以用于遍历字符串表），每个索引项记录了字符串的起始指针和长度</p>
<p><code>qt_meta_data_TextFinder</code>: uint数组，内部结构其实是QMetaObjectPrivate，在QMetaObjectPrivate后面跟着是method(signal&#x2F;slot)的原型定义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct QMetaObjectPrivate</span><br><span class="line">&#123;</span><br><span class="line">  // revision 7 is Qt 5.0 everything lower is not supported</span><br><span class="line">  // revision 8 is Qt 5.12: It adds the enum name to QMetaEnum</span><br><span class="line">  enum &#123; OutputRevision = 8 &#125;; // Used by moc, qmetaobjectbuilder and qdbus</span><br><span class="line">  int revision;</span><br><span class="line">  int className;</span><br><span class="line">  int classInfoCount, classInfoData;</span><br><span class="line">  int methodCount, methodData;</span><br><span class="line">  int propertyCount, propertyData;</span><br><span class="line">  int enumeratorCount, enumeratorData;</span><br><span class="line">  int constructorCount, constructorData;</span><br><span class="line">  int flags;</span><br><span class="line">  int signalCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例（相关的注释在代码中）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// 字符串表总体结构，其中data是字符串表的索引信息，stringdata0是压缩在一起的所有字符串的字节数组。</span><br><span class="line">// 字符串表 = 字符串索引表 + 所有字符串连接起来的大字节数组</span><br><span class="line">struct qt_meta_stringdata_TextFinder_t &#123;</span><br><span class="line">    QByteArrayData data[16];</span><br><span class="line">    char stringdata0[160];</span><br><span class="line">&#125;;</span><br><span class="line">// 计算字字符串表中的每个字符串的索引信息，每个字符串在字符串表中的索引信息</span><br><span class="line">// 注意：字符串的索引信息包括字符串长度size和字符串偏移offset。其中offset并非在字符串表中的偏移，而是相对于当前字符串索引项指针的偏移</span><br><span class="line">// 例如：假设ptr是执行字符串表的索引表的第n个字符串指针，是QByteArrayData*ptr，那么对应的字符串的地址是(char *)ptr+offset</span><br><span class="line">// 可以参考下面QArrayData::data()代码实现来理解</span><br><span class="line">#define QT_MOC_LITERAL(idx, ofs, len) \</span><br><span class="line">    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \</span><br><span class="line">    qptrdiff(offsetof(qt_meta_stringdata_TextFinder_t, stringdata0) + ofs \</span><br><span class="line">        - idx * sizeof(QByteArrayData)) \</span><br><span class="line">    )</span><br><span class="line">    // 构造字符串表：字符串索引表 + 大的字符串字节数组</span><br><span class="line">static const qt_meta_stringdata_TextFinder_t qt_meta_stringdata_TextFinder = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">QT_MOC_LITERAL(0, 0, 10), // &quot;TextFinder&quot;</span><br><span class="line">QT_MOC_LITERAL(1, 11, 14), // &quot;custom_clicked&quot;</span><br><span class="line">QT_MOC_LITERAL(2, 26, 0), // &quot;&quot;</span><br><span class="line">QT_MOC_LITERAL(3, 27, 7), // &quot;checked&quot;</span><br><span class="line">QT_MOC_LITERAL(4, 35, 15), // &quot;custom_clicked2&quot;</span><br><span class="line">QT_MOC_LITERAL(5, 51, 1), // &quot;a&quot;</span><br><span class="line">QT_MOC_LITERAL(6, 53, 11), // &quot;const char*&quot;</span><br><span class="line">QT_MOC_LITERAL(7, 65, 1), // &quot;s&quot;</span><br><span class="line">QT_MOC_LITERAL(8, 67, 15), // &quot;custom_clicked3&quot;</span><br><span class="line">QT_MOC_LITERAL(9, 83, 1), // &quot;c&quot;</span><br><span class="line">QT_MOC_LITERAL(10, 85, 5), // &quot;char*&quot;</span><br><span class="line">QT_MOC_LITERAL(11, 91, 1), // &quot;b&quot;</span><br><span class="line">QT_MOC_LITERAL(12, 93, 15), // &quot;custom_clicked4&quot;</span><br><span class="line">QT_MOC_LITERAL(13, 109, 6), // &quot;int8_t&quot;</span><br><span class="line">QT_MOC_LITERAL(14, 116, 20), // &quot;on_btnSearch_clicked&quot;</span><br><span class="line">QT_MOC_LITERAL(15, 137, 22) // &quot;on_btnSearch_pressdown&quot;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    //</span><br><span class="line">    &quot;TextFinder\0custom_clicked\0\0checked\0&quot;</span><br><span class="line">    &quot;custom_clicked2\0a\0const char*\0s\0&quot;</span><br><span class="line">    &quot;custom_clicked3\0c\0char*\0b\0custom_clicked4\0&quot;</span><br><span class="line">    &quot;int8_t\0on_btnSearch_clicked\0&quot;</span><br><span class="line">    &quot;on_btnSearch_pressdown&quot;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">#undef QT_MOC_LITERAL</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct Q_CORE_EXPORT QArrayData</span><br><span class="line">&#123;</span><br><span class="line">  QtPrivate::RefCount ref;</span><br><span class="line">  int size;</span><br><span class="line">  uint alloc : 31;</span><br><span class="line">  uint capacityReserved : 1;</span><br><span class="line">  qptrdiff offset; // in bytes from beginning of header</span><br><span class="line">  // QArrayData::data()就是上述获取其指向的数据的内容，可以看到offset是相对于自己(QArrayData *this)而言的</span><br><span class="line">  void *data()</span><br><span class="line">  &#123;</span><br><span class="line">​    Q_ASSERT(size == 0</span><br><span class="line">​        || offset &lt; 0 || size_t(offset) &gt;= sizeof(QArrayData));</span><br><span class="line">​    return reinterpret_cast&lt;char *&gt;(this) + offset;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><code>staticMetaObject</code>: QObject对象的静态metaobject</p>
<p>另外还有为用户定义的信号（signal函数）生成实现代码。注意，用户定义的信号只需要在头文件的类中给出函数申明即可，不需要定义。</p>
<p><strong>Q：QT布局</strong></p>
<p><strong>A：</strong>QT UI系统通过Layout&#x2F;sizePolicy&#x2F;StretchFactor来控制布局和控件的大小。</p>
<ul>
<li>布局控制<strong>子元素</strong>的排列，比如如果widget是QHBoxLayout布局，那么其所有子元素会水平布局</li>
<li>sizePolicy控制<strong>控件自己</strong>尺寸的行为，有下列选项<ul>
<li><strong>Fixed</strong>：控件将保持其固定大小，并不会改变。</li>
<li><strong>Minimum</strong>：控件将尽可能小，以适应其内容，但不会超过其最小尺寸。</li>
<li><strong>Maximum</strong>：控件将尽可能大，以填充可用空间，但不会超过其最大尺寸。</li>
<li><strong>Preferred</strong>：控件希望具有适当的大小，以显示其内容，但它可能会根据可用空间进行扩展或收缩。</li>
<li><strong>Expanding</strong>：控件希望尽可能大，以填充可用空间。如果可用空间增加，它将尝试扩展以填充更多空间。</li>
<li><strong>MinimumExpanding</strong>：控件希望尽可能大，以填充可用空间，并且具有最小尺寸。</li>
<li><strong>Ignored</strong>：布局管理器会忽略控件的大小，控件可以是任何大小。</li>
</ul>
</li>
<li>StretchFactor</li>
</ul>
<p><strong>备注：</strong>在水平布局中，假设里头有2个子控件，默认设置sizePolicy水平方向均为prefered或者extended，父窗口调整大小，两个子控件会自动调整宽度以完全适应父窗口宽度。如果想在中间假如间隔，可以假如一个horzSpacer弹簧。如果想控制其中一个子控件宽度不变，修改该子控件sizePolicy水平为fixed还不行，还需要修改minimumsize.x为你相设置的宽度（不要尝试修改geometry的宽度，在布局下面，控件的geometry无法修改）</p>
<h2 id="Q：qrc文件"><a href="#Q：qrc文件" class="headerlink" title="Q：qrc文件"></a><strong>Q：qrc文件</strong></h2><p><strong>A：</strong>通过makefile可以看到编译时会用rcc.exe来编译qrc文件，生成对应的cpp文件。然后在程序入口地方可以用Q_INIT_RESOURCE(XXX);来初始化资源，内部调用qRegisterResourceData函数来注册资源数据。</p>
<h2 id="Q：-在线安装频繁提示网络错误，用代理和不用代理一样"><a href="#Q：-在线安装频繁提示网络错误，用代理和不用代理一样" class="headerlink" title="Q： 在线安装频繁提示网络错误，用代理和不用代理一样"></a><strong>Q： 在线安装频繁提示网络错误，用代理和不用代理一样</strong></h2><p><strong>A：</strong>尝试使用离线安装包（qt-creator-opensource-windows-x86_64-13.0.1.exe），里头可选择安装项目。</p>
<h2 id="Q：QtCreator编译后如何部署"><a href="#Q：QtCreator编译后如何部署" class="headerlink" title="Q：QtCreator编译后如何部署"></a><strong>Q：QtCreator编译后如何部署</strong></h2><p>A：编译后会生成可执行环境，进入到生成目录直接运行exe文件无法启动，提示依赖库不存在，不过可以在Creator中调试（会自动设置好依赖库路径）。发布的时候需要部署，qt自带了部署工具windeployqt.exe，具体的在开发包5.12.12\msvc2017_64\bin\（x64）或者5.12.12\msvc2017\bin\（x86）下面，此命令只需要一个exe文件名即可。例如：你可以将生成的output.exe文件拷贝到你要部署的目录，然后在部署目录下执行windeployqt.exe output.exe即可。</p>
<p>​		当然，我们也可以借助QtCreator工具来部署，在Kit中点击Run，打开运行配置，最上面就是部署配置，可以创建部署步骤(Customer Process Step)，例如我们先拷贝输出文件到部署目录然后部署，下面是示例&gt;2：</p>
<p><img src="/2024/05/18/QT/image-20240518091304577.png" alt="image-20240518091304577"></p>
<ul>
<li>这里步骤一是想用copy命令拷贝，不要直接在command：里头输入copy，他会提示：invalid command。我们需要用cmd.exe &#x2F;c copy来执行拷贝，Command填入cmd.exe即可， &#x2F;c copy 填在arguments里头。</li>
<li>windeployqt指示部署依赖的QT库，项目中用到的第三方库需要自己手动部署（自行拷贝到发布目录）</li>
</ul>
<h2 id="Q-构建库并且使用"><a href="#Q-构建库并且使用" class="headerlink" title="Q: 构建库并且使用"></a>Q: 构建库并且使用</h2><p>A：创建mylib库。文件 - new project - 库 - c++library，输入名称mylib，下一步build system选择qmake，下一步 define project details 库类型设置为static library，其他默认，后面一路next，最后选择build套件，结束。</p>
<p>​		创建好mylib库之后，直接构建就可以，构建输出目录设置为mylib&#x2F;debug。</p>
<p>​		可以看下mylib.pro文件，在pro文件中，用TEMPLATE &#x3D; lib 指示这是一个库工程（app用app）；CONFIG +&#x3D; staticlib指示静态库（动态库是dll），其他的SOURCES指示源代码文件列表；HEADERS指示头文件列表；</p>
<p>​		修改app.pro文件，假如头文件包含和头文件搜搜目录以及依赖库和库目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HEADERS += \</span><br><span class="line">    cperson.h \</span><br><span class="line">    myspinbox.h \</span><br><span class="line">    textfinder.h \</span><br><span class="line">    mylib.h</span><br><span class="line">    </span><br><span class="line">INCLUDEPATH += $$PWD/../mylib</span><br><span class="line">// 注意这里指示演示，没有区分debug和release</span><br><span class="line">LIBS += -L$$PWD/../mylib/debug/ -lmylib</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h1><p>1、<a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学开源软件镜像站</a></p>
<p>2、<a target="_blank" rel="noopener" href="https://download.qt.io/">qt官方下载站</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jerrywang2013.github.io/2024/05/18/QT/" data-id="clwbg5x4k0003z44q9fcu4qwg" data-title="QT" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/05/27/c-11/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          c++11
        
      </div>
    </a>
  
  
    <a href="/2024/05/14/c-%E8%B0%83%E8%AF%95/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">c++调试</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/06/22/cuda%E5%88%9D%E6%8E%A5%E8%A7%A6/">cuda初接触</a>
          </li>
        
          <li>
            <a href="/2024/06/11/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/">git常用操作</a>
          </li>
        
          <li>
            <a href="/2024/06/06/QObject%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/">QObject简单笔记</a>
          </li>
        
          <li>
            <a href="/2024/05/27/c-11/">c++11</a>
          </li>
        
          <li>
            <a href="/2024/05/18/QT/">QT</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>windows网络编程 | Jerry Blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="网络常见知识 大小端​	一般用于指示多字节数据存储方式。  ​	大端（Little Endian)： 高位字节（MSB）存储在起始地址，低位字节（LSB）存储在结束地址。换句话说：数据的高位存储在内存的低地址处，低位字节存储在高地址处。  ​	小端（Little Endian)： 和大端相反。 举例：假设一个32位整数num，其十六进制表示为 **0x12345678**，在内存中存储如下： 大端">
<meta property="og:type" content="article">
<meta property="og:title" content="windows网络编程">
<meta property="og:url" content="https://jerrywang2013.github.io/2024/05/01/windows%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Jerry Blogs">
<meta property="og:description" content="网络常见知识 大小端​	一般用于指示多字节数据存储方式。  ​	大端（Little Endian)： 高位字节（MSB）存储在起始地址，低位字节（LSB）存储在结束地址。换句话说：数据的高位存储在内存的低地址处，低位字节存储在高地址处。  ​	小端（Little Endian)： 和大端相反。 举例：假设一个32位整数num，其十六进制表示为 **0x12345678**，在内存中存储如下： 大端">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-05-01T09:42:08.000Z">
<meta property="article:modified_time" content="2024-05-05T07:34:59.503Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="c++ lua php js python">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Jerry Blogs" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Jerry Blogs</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://jerrywang2013.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-windows网络编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/05/01/windows%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2024-05-01T09:42:08.000Z" itemprop="datePublished">2024-05-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      windows网络编程
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="网络常见知识"><a href="#网络常见知识" class="headerlink" title="网络常见知识"></a>网络常见知识</h1><ul>
<li><h2 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h2><p>​	一般用于指示多字节数据存储方式。</p>
<ul>
<li><p>​	<strong>大端（Little Endian)：</strong> 高位字节（MSB）存储在起始地址，低位字节（LSB）存储在结束地址。换句话说：数据的高位存储在内存的低地址处，低位字节存储在高地址处。</p>
</li>
<li><p>​	<strong>小端（Little Endian)：</strong> 和大端相反。</p>
<p>举例：假设一个32位整数<code>num</code>，其十六进制表示为 **<code>0x12345678</code>**，在内存中存储如下：</p>
<p><strong>大端字节序</strong>：存储方式为<code>**12 34 56 78**</code></p>
<p><strong>小端字节序：</strong>存储方式为<code>**78 56 34 12**</code></p>
</li>
</ul>
</li>
</ul>
<h1 id="重要函数"><a href="#重要函数" class="headerlink" title="重要函数"></a>重要函数</h1><ul>
<li><p><strong>WSAGetLastError</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">WSAGetLastError</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p><strong>描述：</strong>获取WinSocket函数调用的错误码</p>
<p><strong>说明：</strong>WinSocket错误码定义在winsocket2.h文件中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define WSABASEERR              10000</span><br></pre></td></tr></table></figure>

<p>​		错误码基础偏移是WSABASEERR，通过WSAGetLastError()获取到的错误码可以直接通过VS自带的错误查找工具查找对应错误码的信息。</p>
</li>
<li><p><strong>WSAStartup</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">WSAStartup</span><span class="params">(wVersion,  &amp;wsadata)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>描述：</strong>初始化WinSocket库</p>
<p><strong>说明：</strong></p>
<p>​		应作为Socket库首个函数被调用。wVersion指定winsocket库版本。此函数直接返回错误码（0表示正常），无需额外调用WSAGetLastError()获取错误码。</p>
</li>
<li><p><strong>WSACleanup</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">WSACleanup</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p><strong>描述：</strong>终于使用Winsock2 DLL(ws2_32.dll)</p>
<p><strong>返回值：</strong>成功返回0，否则返回SOCKET_ERROR</p>
<p><strong>说明：</strong></p>
<p>​		失败时可以调用WSAGetLastError获取错误码。在多线程环境下，WSACleanup调用会终止所有线程的Windows套接字操作。</p>
</li>
<li><p><strong>socket</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SOCKET <span class="title">socket</span><span class="params">(<span class="type">int</span> af, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>描述：</strong>创建套接字**</p>
<p><strong>返回值：</strong></p>
<p>​		如果没有错误会返回新创建的套接字描述符（整数），否则返回INVALID_SOCKET，并且可以调用WSAGetLastError()获取错误。</p>
<p><strong>说明：</strong></p>
<p>​	af： 地址家族，常见的有<strong>AF_INET</strong>（IPV4）、 <strong>AF_INET6</strong>（IPV6）</p>
<p>​	type: 套接字类型，常见有<strong>SOCK_STREAM</strong>、<strong>SOCK_DGRAM</strong>、<strong>SOCK_RAW</strong>(原始套接字)</p>
<p>​	protocol：协议，常见有<strong>IPPROTO_TCP</strong>、**IPPROTO_UDP</p>
</li>
<li><p><strong>bind</strong> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(SOCKET s, <span class="type">const</span> sockaddr *addr, <span class="type">int</span> namelen)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>描述：</strong>socket绑定地址</p>
<p><strong>返回值：</strong>如果没有错误，返回0；否则返回SOCKET_ERROR；</p>
<p><strong>说明：</strong></p>
<ul>
<li><p>如果不指定IP，可以使用INADDR_ANY（IPV4）或者in6addr_any（IPV6）</p>
</li>
<li><p>如果指定端口为0，则自动选择一个可用的动态端口（vista之后系统动态端口区间49152 - 65535）。</p>
</li>
<li><p>注意sockaddr结构会根据所选协议不同而不同的。比如IPV4，我们使用的是sockaddr_in； IPV6我们使用的是sockaddr_in6</p>
</li>
<li><p>bind之后可以用getsockname来获取分配给套接字的地址和端口。如果指定绑定IP是INADDR_ANY，则在连接建立之前getsockname不一定提供地址，因为如果主机是多宿主，可能有多个地址。客户端程序一般指定port为0避免端口冲突。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// bind  and listen</span><br><span class="line">SOCKADDR_IN serverAddr;</span><br><span class="line">serverAddr.sin_family = AF_INET;</span><br><span class="line">serverAddr.sin_addr.S_un.S_addr = htonl(INADDR_ANY);</span><br><span class="line">serverAddr.sin_port = htons(8889);</span><br><span class="line">ret = bind(listen_socket, (const sockaddr*)&amp;serverAddr, sizeof(serverAddr));</span><br><span class="line">if (SOCKET_ERROR == ret) &#123;</span><br><span class="line">	Helper::log(&quot;bind listen socket failed with error:%d\n&quot;, WSAGetLastError());</span><br><span class="line">	closesocket(listen_socket);</span><br><span class="line">	WSACleanup();</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">SOCKADDR_IN bind_addr;</span><br><span class="line">int bind_addr_len = sizeof(bind_addr);</span><br><span class="line">ret = getsockname(listen_socket, (sockaddr*)&amp;bind_addr, &amp;bind_addr_len);</span><br><span class="line">if (SOCKET_ERROR == ret) &#123;</span><br><span class="line">	Helper::log(&quot;get listen socket bind addr failed with error:%d\n&quot;, WSAGetLastError());</span><br><span class="line">	closesocket(listen_socket);</span><br><span class="line">	WSACleanup();</span><br><span class="line">	return false;</span><br><span class="line"></span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>listen</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int listen(SOCKET s, int backlog)</span><br></pre></td></tr></table></figure>

<p><strong>描述：</strong>将套接字设置为监听模式。</p>
<p><strong>返回值：</strong>成功返回0，失败返回SOCKET_ERROR。</p>
<p><strong>说明：</strong></p>
<p>​		backlog是后台等待连接队列。将套接字设置为监听模式后，os会维护等待连接队列，这个参数指定了此队列长度。当有客户尝试连接时，如果等待连接队列已满，则客户端可能收到连接被拒绝的错误。</p>
<p>​		距离说明如果设置了backlog为2，有两个客户端连接服务器，服务器暂时还没有处理客户端的连接（就是没有accept），如果这时候再来第三个客户端连接就会出现连接被拒绝。</p>
<p>​		</p>
</li>
<li><p><strong>accept</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SOCKET accept(SOCKET s, sockaddr *addr, int *addrlen)</span><br></pre></td></tr></table></figure>

<p><strong>描述：</strong>在套接字上进行连接操作</p>
<p><strong>返回值</strong>：如果没有错误，返回新建连接的SOCKET；否则返回INVALID_SOCKET。</p>
<p><strong>说明：</strong></p>
<ul>
<li><p>accept会一直阻塞直到有客户连接的到来；</p>
</li>
<li><p>addr返回的是新建连接的客户地址信息，可以用inet_ntop将IPV4&#x2F;6的网络地址(sockaddr.sin_addr)转为internet标准格式字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char ipstr[INET_ADDRSTRLEN] = &#123; 0 &#125;;</span><br><span class="line">inet_ntop(AF_INET, &amp;(clientAddr.sin_addr), ipstr, sizeof(ipstr));</span><br><span class="line">WORD port = ntohs(clientAddr.sin_port);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>send</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int send(SOCKET s, const char *buf, int len, int flags)</span><br></pre></td></tr></table></figure>

<p><strong>描述：</strong>在建立连接的套接字上发送数据</p>
<p><strong>返回值：</strong>如果没有错误，返回发送的总字节数，字节数可能小于请求发送的长度(len)；否则返回SOCKET_ERROR。</p>
<p><strong>说明：</strong></p>
<ul>
<li>发送函数成功完成并不表示数据传递并接收给，只是指示待发送数据已经成功写入套接字的发送缓冲区。</li>
<li>如果发送缓冲区没有空间，此函数会block；如果是非阻塞套接字，那么send会立刻返回，写入字节数取决于缓冲区可用性。</li>
<li>数据成功写入缓冲区后，操作系统会负责将数据通过网络发送给目标主机。</li>
</ul>
</li>
<li><p><strong>recv</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int recv(SOCKET s, char *buf, int len, int flags)</span><br></pre></td></tr></table></figure>

<p><strong>描述：</strong>从套接字上接收数据</p>
<p><strong>返回值：</strong>成功返回接收的字节数；失败返回SOCKET_ERROR。</p>
<p><strong>说明：</strong></p>
<ul>
<li><p>当套接字接收缓冲区没有数据的时候，recv调用会阻塞</p>
</li>
<li><p>当套接字接收缓冲区有数据的时候，recv会尝试将套接字缓冲区的内容拷贝到recv定义的用户缓冲区中，实际接收的数据和用户缓冲区buf大小以及套接字接收缓冲区数据的长度有关。</p>
</li>
<li><p>阻塞模式下，recv返回0意味着对方调用了closesocket或者shutdown关闭了连接。</p>
</li>
</ul>
</li>
<li><p><strong>shutdown</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int shutdown(SOCKET s, int how)</span><br></pre></td></tr></table></figure>

<p><strong>描述：</strong>关闭套接字的发送和接收</p>
<p><strong>返回值：</strong>成功返回0，失败返回SOCKET_ERROR</p>
<p><strong>说明：</strong></p>
<ul>
<li>how可选 SD_SEND | SD_RECEIVE | SD_BOTH</li>
<li>shutdown是关闭套接字功能；closesocket是关闭套接字功能，清理套接字资源</li>
</ul>
</li>
<li><p><strong>closesocket</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int closesocket(SOCKET s)</span><br></pre></td></tr></table></figure>

<p><strong>描述：</strong>关闭套接字</p>
<p><strong>返回值：</strong>成功返回0，失败返回SOCKET_ERROR</p>
<p><strong>说明：</strong></p>
<ul>
<li>可以结合linger选项来控制closesocket后的套接字接收发送行为</li>
</ul>
</li>
<li><p>select</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const timeval *timeout)</span><br></pre></td></tr></table></figure>

<p><strong>描述：</strong>确定套接字状态，并在必要时等待执行同步IO</p>
<p>返回值：成功返回fd_set中已就绪的套接字数量；如果超时时间到，返回0；如果有错误，返回SOCKET_ERROR。</p>
<p><strong>说明：</strong></p>
<ul>
<li><p>nfds 参数已忽略。</p>
</li>
<li><p>如果用select查询套接字状态，需要将套接字设置为非阻塞。利用ioctlsocket设置套接字的IO模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unsigned long nonBlocking = 1;</span><br><span class="line"></span><br><span class="line">ioctlsocket(pSockInfo-&gt;sock, FIONBIO, &amp;nonBlocking)</span><br></pre></td></tr></table></figure>

<p>注意，WSAEventSelect和WSAAsyncSelect函数会自动将socket设置为NonBlock模式，无需手动设置。</p>
</li>
<li><p>放大</p>
</li>
</ul>
</li>
<li></li>
</ul>
<h1 id="套接字模式"><a href="#套接字模式" class="headerlink" title="套接字模式"></a>套接字模式</h1><ul>
<li><p>同步模式</p>
<p>​	默认行为，套接字的读写(包括accept)都是阻塞式的。</p>
</li>
<li><p>异步模式</p>
<p>​	套接字读写都是非阻塞的，可以通过ioctlsocket设置套接字为非阻塞。</p>
</li>
</ul>
<h1 id="常见IO模型"><a href="#常见IO模型" class="headerlink" title="常见IO模型"></a>常见IO模型</h1><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>​		类似unix的select模型，注意，windows下select最多支持64个套接字。可以使用WSAPoll。</p>
<h3 id="WSAAsyncSelect"><a href="#WSAAsyncSelect" class="headerlink" title="WSAAsyncSelect"></a>WSAAsyncSelect</h3><p>​		和select不同，他不是同步等待，是基于windows消息来通知socket的变化，换句话说，需要windows窗口和消息循环。另外，使用了WSAAsyncSelect会自动将套接字设置为非阻塞。</p>
<h3 id="WSAEventSelect"><a href="#WSAEventSelect" class="headerlink" title="WSAEventSelect"></a>WSAEventSelect</h3><p>​		和WSAAsyncSelect类似，不过是基于事件来异步通知套接字状态的变化，使用了WSAAsyncSelect会自动将套接字设置为非阻塞。他是基于windows事件，不需要windows窗口。</p>
<h3 id="WSAPoll"><a href="#WSAPoll" class="headerlink" title="WSAPoll"></a>WSAPoll</h3><p>​		类似select的轮询方式，没有套接字数量限制。</p>
<h3 id="重叠模型"><a href="#重叠模型" class="headerlink" title="重叠模型"></a>重叠模型</h3><h3 id="IOCP"><a href="#IOCP" class="headerlink" title="IOCP"></a>IOCP</h3><p>​		windows下高性能高并发量常用的模型，通过将套接字与完成端口关联来完成高性能异步操作。IOCP提供了一种高性能方式处理大并发量的异步操作，它是一种基于事件驱动的模型，基于事件通知机制来实现异步操作结束的通知。通过IOCP，避免了传统的同步和select的轮询，提高性能。</p>
<ul>
<li><p>使用流程</p>
<ul>
<li><strong>创建端口</strong>：首先，需要创建一个 I&#x2F;O 完成端口对象（IOCP 对象），通过调用 <code>CreateIoCompletionPort()</code> 函数来完成。</li>
<li><strong>关联套接字</strong>：然后，将需要进行异步 I&#x2F;O 操作的套接字句柄与创建的 IOCP 对象关联起来，可以关联一个或多个套接字。这通常通过调用 <code>CreateIoCompletionPort()</code> 函数来实现。</li>
<li><strong>发起异步操作</strong>：一旦套接字与 IOCP 关联成功，就可以通过调用异步 I&#x2F;O 函数（如 <code>WSASend()</code>、<code>WSARecv()</code>）来发起异步 I&#x2F;O 操作。在调用这些函数时，需要传递一个与操作相关的 <code>OVERLAPPED</code> 结构体，用于接收完成通知。</li>
<li><strong>处理完成通知</strong>：当异步 I&#x2F;O 操作完成时，系统会将完成结果通知到关联的 IOCP 对象上。应用程序可以通过调用 <code>GetQueuedCompletionStatus()</code> 函数来获取完成的 I&#x2F;O 操作，并进行相应的处理。</li>
</ul>
</li>
<li><p>简单流程分析</p>
<ul>
<li>通过CreateIoCompletionPort()创建IOCP对象，这个IOCP对象就充当了事件队列的管理者，负责管理所有与该IOCP相关的IO操作；</li>
<li>对某个IO（这里我们值得是套接字）对象上进行异步IO操作之前，我们需要将此IO对象与前面创建的IOCP关联起来，关联之后，此对象的完成事件就会被通知到该IOCO对象；</li>
<li>在IO对象上执行异步操作（WSASend &#x2F; WSAReceive，包括ReadFileEx &#x2F; WriteFileEx等），这些操作都会立即返回，不会阻塞当前线程；</li>
<li>当一个异步IO操作在后台完成时，系统会将对应的完成事件放入到IOCP对象的事件队列中，这个完成事件包含了操作相关的信息，包括操作类型和结果等；</li>
<li>应用程序的一个或多个线程调用GetQueuedCompletionStatus函数等待并处理事件队列中的完成事件，这些线程我们通常称之为完成端口线程。一旦某个完成事件进入队列，一个完成端口线程就会被唤醒；</li>
<li>当完成端口被唤醒，我们可以根据完成事件的信息来处理，比如某个异步Read操作完成，我们可以获取读取的内容往上派发给上层进行处理，同时，我们可以通过投递一个新的异步Read操作用于继续读取内容（等待新数据的到来）；</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jerrywang2013.github.io/2024/05/01/windows%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" data-id="clvoyrkal0000jc4q2jkcazjd" data-title="windows网络编程" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2024/04/30/Hexo-%E7%AE%80%E4%BB%8B/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">在Github上部署Hexo</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/05/01/windows%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">windows网络编程</a>
          </li>
        
          <li>
            <a href="/2024/04/30/Hexo-%E7%AE%80%E4%BB%8B/">在Github上部署Hexo</a>
          </li>
        
          <li>
            <a href="/2024/04/27/ThinkPHP%E4%B9%8BDB-Query/">ThinkPHP之DB::Query</a>
          </li>
        
          <li>
            <a href="/2024/04/23/MarkDown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">MarkDown基本语法</a>
          </li>
        
          <li>
            <a href="/2024/04/23/SelectPage/">SelectPage</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
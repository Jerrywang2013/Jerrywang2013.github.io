<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Jerry Blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="learning records">
<meta property="og:type" content="website">
<meta property="og:title" content="Jerry Blogs">
<meta property="og:url" content="https://jerrywang2013.github.io/index.html">
<meta property="og:site_name" content="Jerry Blogs">
<meta property="og:description" content="learning records">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="c++ lua php js python">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Jerry Blogs" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Jerry Blogs</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://jerrywang2013.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-c-11" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/05/27/c-11/" class="article-date">
  <time class="dt-published" datetime="2024-05-27T03:49:14.000Z" itemprop="datePublished">2024-05-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/05/27/c-11/">c++11</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>接触QT，里头用到C++11新特性，打算简单了解一下。</p>
<h1 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h1><p>​		扩大列表初始化使用范围，对所有内置类型和自定义类型都可以用列表初始化方法，并且可以省略&#x3D;号。另外还支持部分内置容器的初始化列表</p>
<ul>
<li><p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">​		int x;</span><br><span class="line">​		int y;</span><br><span class="line">&#125;</span><br><span class="line">Point p=&#123;1,2&#125;; // OK</span><br><span class="line">Point p&#123;1,2&#125;; // 自定义类型OK 省略=</span><br><span class="line">int a&#123;100&#125;;  // 内置类型OK 省略=</span><br><span class="line">std::vector&lt;int&gt; v&#123;1,2,3&#125;; // OK</span><br><span class="line">std::initializer_list&lt;int&gt; il&#123; 2,3,4,5 &#125;;</span><br><span class="line">v = il; // OK</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="变量类型推导"><a href="#变量类型推导" class="headerlink" title="变量类型推导"></a>变量类型推导</h1><p>​		c++11提供了多种简化声明的方式，特别是使用模板时。</p>
<ul>
<li><p>auto关键字		</p>
<p>​		自动类型推导，要求显示初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void sum(int a, int b)&#123;&#125;</span><br><span class="line">int aaa = 1;</span><br><span class="line">auto ap1 = aaa;</span><br><span class="line">auto ap2 = sum;</span><br><span class="line">auto it = vec.begin(); // vec::iterator</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>auto elem 是推导出值类型，不影响原始数据；auto &amp;elem是推导出引用类型，直接影响原始数据。</p>
</li>
<li><p>decltype</p>
<p>​	将变量类型声明为表达式指定的类型。注意，参数是一个表达式，不能是一个类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto ap2 = sum;</span><br><span class="line">decltype(ap2) c;</span><br><span class="line">cout &lt;&lt; typeid(c).name() &lt;&lt; endl; // int (__cdecl*)(int,int)</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h1><p>​	c++11之前空指针用NULL，这个起始和0没区别，容易引起歧义（比如函数重载）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void fn(int); </span><br><span class="line">void fn(int*)</span><br><span class="line">fn(NULL)可能会调用fn(int)</span><br><span class="line">fn(nullptr)明确调用fn(int*)</span><br></pre></td></tr></table></figure>



<h1 id="范围循环"><a href="#范围循环" class="headerlink" title="范围循环"></a>范围循环</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (auto&amp; elem : vec) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;   item:&quot; &lt;&lt; elem &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>修饰类时，指示类不可被继承；修饰函数时，指示函数不可被重写。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A final </span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">class B : public A  // error</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virutal void fun() final</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B : public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void fun() &#123;  // error    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="override"><a href="#override" class="headerlink" title="override"></a>override</h1><p>检查派生类虚函数是否是重写了基类的某个虚函数，如果没有重写则编译报错</p>
<h1 id="新增容器"><a href="#新增容器" class="headerlink" title="新增容器"></a>新增容器</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array</span><br><span class="line">forward_list</span><br><span class="line">unordered_map</span><br><span class="line">unordered_set</span><br></pre></td></tr></table></figure>



<h1 id="default"><a href="#default" class="headerlink" title="default"></a>default</h1><p><code>default</code> 关键字可以用于以下几种成员函数：</p>
<ol>
<li><strong>默认构造函数</strong></li>
<li><strong>析构函数</strong></li>
<li><strong>拷贝构造函数</strong></li>
<li><strong>拷贝赋值运算符</strong></li>
<li><strong>移动构造函数</strong></li>
<li><strong>移动赋值运算符</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123; </span><br><span class="line">public:    </span><br><span class="line">	MyClass() = default;                     // 默认构造函数    </span><br><span class="line">	~MyClass() = default;                    // 析构函数    </span><br><span class="line">	MyClass(const MyClass&amp;) = default;       // 拷贝构造函数    </span><br><span class="line">	MyClass&amp; operator=(const MyClass&amp;) = default;  // 拷贝赋值运算符</span><br><span class="line">	MyClass(MyClass&amp;&amp;) = default;            // 移动构造函数    </span><br><span class="line">	MyClass&amp; operator=(MyClass&amp;&amp;) = default; // 移动赋值运算符 </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>应用场景：</p>
<p>比如你写了一个自定义带参数的构造函数，那么编译器不会给你生成默认构造函数，此时你直接用MyClass()会报错，这种情况下，可以用MyClass()&#x3D;default;就可以用MyClass c;</p>
<h1 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h1><p>​	在c++11之前只有左值引用。所谓左值是指出现在等号左边，比如常见的变量可以在等号左边，它是左值。常量不能出现在等号左边，所以它是右值。</p>
<h2 id="左值-右值"><a href="#左值-右值" class="headerlink" title="左值&amp;右值"></a>左值&amp;右值</h2><p>​		左值：可以取其地址，例如：变量、引用等；</p>
<p>​		右值：表示一个临时对象或者字面值，通常无法取其地址。例如：字面值、临时对象、表达式的结果等；</p>
<h2 id="右值引用语法："><a href="#右值引用语法：" class="headerlink" title="右值引用语法：&amp;&amp;"></a>右值引用语法：&amp;&amp;</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int&amp;&amp; rvalueRef = 10;</span><br></pre></td></tr></table></figure>

<h2 id="右值引用用途"><a href="#右值引用用途" class="headerlink" title="右值引用用途"></a>右值引用用途</h2><h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><p>​		移动语义让我们‘移动’资源而不是拷贝资源，提高性能。移动操作只需要转移资源的所有权，而不需要实际的数据拷贝。</p>
<h3 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h3><ul>
<li><p>通用引用(universal reference) </p>
<p>template<T> void func(T&amp;&amp; value){}</T></p>
<p>​		当模版参数T是通过类型推导获得时，T&amp;&amp;被称之为通用引用，通用引用是可以绑定到左值或者右值的，而不是表面上看上去的右值。</p>
</li>
<li><p>折叠规则</p>
<p>c++有一套引用折叠规则：</p>
<ul>
<li>T&amp; &amp;、T&amp; &amp;&amp;和T&amp;&amp; &amp;都折叠为T&amp;</li>
<li>T&amp;&amp; &amp;&amp;折叠为T&amp;&amp;</li>
</ul>
</li>
</ul>
<p>完美转发示例：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void processValue(int&amp; value)</span><br><span class="line"> &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Lvalue: &quot; &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    value = 42;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void processValue(int&amp;&amp; value) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Rvalue: &quot; &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void forwardValue(T&amp;&amp; value) </span><br><span class="line">&#123;</span><br><span class="line">    processValue(std::forward&lt;T&gt;(value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int x = 10;</span><br><span class="line">    forwardValue(x);  // 传递左值</span><br><span class="line">    std::cout &lt;&lt; &quot;After forwarding, x = &quot; &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    forwardValue(20);  // 传递右值</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>右值引用规则</p>
<ul>
<li>引用折叠</li>
<li>标准库中的右值引用</li>
</ul>
</li>
</ul>
<p>​	左值引用只能引用左值，不能引用右值；</p>
<p>​	通常临时变量是不能左值引用的，例如int &amp;a &#x3D; 123;这个就是错误的。但是通过常量引用，可以对临时变量或者函数返回的临时对象进行引用，此举相当于告诉编译器将临时变量的生命空间延长，与引用变量的生命空间保持一致。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> int a = 10;</span><br><span class="line"> int&amp; b = a;</span><br><span class="line"> int&amp; c = 10;  // error 非常量引用的初始值必须为左值</span><br><span class="line"> const int&amp; d = 10; // ok</span><br><span class="line"> const string&amp; str2 = &quot;abc&quot;; // ok，提升临时变量的生命空间和str2保持一致</span><br><span class="line"> const string&amp; str3 = [str2](const char *str) -&gt; string&#123;</span><br><span class="line">	return str + str2;</span><br><span class="line">	&#125;(&quot;123&quot;);// ok 提升临时变量的生命空间和str3一致</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">bool isOdd(int&amp; num)</span><br><span class="line">&#123;</span><br><span class="line">	return 0 == num % 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isOdd_r(int&amp;&amp; num) &#123;</span><br><span class="line">	return 0 == num % 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test() &#123;</span><br><span class="line">	int a = 10;</span><br><span class="line">	cout &lt;&lt; isOdd(2); // error 非常量引用的初始值必须为左值</span><br><span class="line">	cout &lt;&lt; isOdd(a); // ok</span><br><span class="line">    cout &lt;&lt; isOdd(a+2); // error 非常量引用的初始值必须为左值</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; isOdd_r(2);  // ok</span><br><span class="line">	cout &lt;&lt; isOdd_r(a); // error 右值引用初始值必须是右值</span><br><span class="line">	cout &lt;&lt; isOdd_r(a + 2); // ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	右值除了可以是字面常量、还可以是临时对象，例如表达式返回值、传值返回类型的返回值（不能是引用返回类型）等。</p>
<p>​	右值引用允许我们操作右值（临时对象、字面常量等），从而避免不必要的拷贝。右值引用其实是告诉编译器这是一个可移动对象。当我们写 MyClass c &#x3D; xxx; 时，编译器会根据 xxx 的类型来选择合适的构造函数。如果 xxx 是一个可移动的对象（即右值引用），并且 MyClass 有一个移动构造函数，那么编译器会调用移动构造函数来构造 c 对象。</p>
<p><strong>构造函数选择的规则</strong></p>
<ul>
<li><p>如果 xxx 是一个右值：</p>
<ul>
<li>​	编译器会优先选择移动构造函数（MyClass(MyClass&amp;&amp;)），如果存在的话。</li>
<li>如果没有移动构造函数，编译器会尝试使用拷贝构造函数（MyClass(const MyClass&amp;)）。</li>
</ul>
</li>
<li><p>如果 xxx 是一个左值：</p>
<p>编译器会选择拷贝构造函数（MyClass(const MyClass&amp;)）。</p>
</li>
</ul>
<p><strong>移动构造函数和移动赋值操作</strong></p>
<ul>
<li><p>手动实现拷贝构造和拷贝赋值函数</p>
</li>
<li><p>如果没有手动实现拷贝构造和拷贝赋值方法，编译器会生成默认的移动构造和移动赋值函数。</p>
<p>如果是可移动对象，但是没有移动构造（比如手动实现了拷贝构造但是没有实现移动构造）和移动赋值函数，那么编译器会用拷贝构造和赋值操作替代。</p>
</li>
</ul>
<h1 id="using"><a href="#using" class="headerlink" title="using"></a>using</h1><p>在以前的c++中，using用于引入命名空间，在c++11中，using可以用于定义类型别名，相当于typedef。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个 vector&lt;int&gt; 的别名</span></span><br><span class="line"><span class="keyword">using</span> IntVector = std::vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="comment">// 定义一个 map&lt;string, int&gt; 的别名</span></span><br><span class="line"><span class="keyword">using</span> StringIntMap = std::map&lt;std::string, <span class="type">int</span>&gt;;</span><br><span class="line">IntVector vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">StringIntMap map = &#123;&#123;<span class="string">&quot;one&quot;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&quot;two&quot;</span>, <span class="number">2</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="std-iota"><a href="#std-iota" class="headerlink" title="std::iota"></a>std::iota</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">iota</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">1</span>);</span><br></pre></td></tr></table></figure>



<h1 id="std-generate"><a href="#std-generate" class="headerlink" title="std::generate"></a>std::generate</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">generate</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [&amp;n]() &#123; <span class="keyword">return</span> n += <span class="number">2</span>; &#125;); <span class="comment">// 生成2的倍数</span></span><br></pre></td></tr></table></figure>



<h1 id="std-fill"><a href="#std-fill" class="headerlink" title="std::fill"></a>std::fill</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">fill</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">42</span>);</span><br></pre></td></tr></table></figure>



<h1 id="资源管理指针"><a href="#资源管理指针" class="headerlink" title="资源管理指针"></a>资源管理指针</h1><ul>
<li><p>unique_ptr</p>
<p>独占式智能指针，用于管理唯一对象，确保只有一个指针可以访问该对象；unique_ptr可以自动释放动态分配的内存，当指针超过作用域或者被重置，会自动删除所管理的对象。</p>
<p>注意：unique_ptr是不能用左值赋值的，只能用右值引用赋值，因为默认拷贝构造函数和赋值运算符操作都被禁止。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr(const unique_ptr&amp;)            = delete;</span><br><span class="line"> unique_ptr&amp; operator=(const unique_ptr&amp;) = delete;</span><br></pre></td></tr></table></figure>
</li>
<li><p>shared_ptr</p>
<p>共享智能指针，引用计数技术实现。当引用技术为0时自动销毁对象，com技术里头主要用到的就是共享智能指针。</p>
</li>
<li><p>weak_ptr</p>
<p>弱指针，不会增长引用计数，它可以解决shared_ptr循环引用问题。当所有的shared_ptr超出作用域之后，哪怕还有weak_ptr，所管理的对象也会被销毁。</p>
<p>例如：两个share_ptr<Node> 指针AB，Node里头又有一个shared_ptr<Node> next，A的next成员指向B，B的next成员指向A，这样就会出现循环引用。解决办法是将Node的next成员改为weak_ptr类型。</Node></Node></p>
<p>注意：weak_ptr弱引用是维护的智能指针控制块的weak_refcount，shared_ptr维护的是refcount，是两个独立的计数。weakptr需要和sharedptr引用的是同一个控制块！</p>
</li>
</ul>
<h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><p>语法：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[capture list](parameters) -&gt; return_type &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>capture_list：要捕获的变量列表（类似其他语言的using），匿名函数中需要用到的外部变量列表</p>
<p>parameters：参数列表</p>
<p>return_type： 返回值类型，可以用auto自动推导</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto f_sum = [](int a, int b)-&gt;auto &#123;</span><br><span class="line">		return a * b;</span><br><span class="line">	&#125;;</span><br><span class="line">cout &lt;&lt; f_sum(2, 3) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>



<h1 id="变参模版"><a href="#变参模版" class="headerlink" title="变参模版"></a>变参模版</h1><p>​		允许函数或者类模版接受可变数量参数，使用…表示可变参数。</p>
<p>例如：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// c++10/14</span><br><span class="line">// 处理单个参数的函数</span><br><span class="line">void print() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;End of recursion\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 处理参数包的函数</span><br><span class="line">template&lt;typename T, typename... Args&gt;</span><br><span class="line">void print(T first, Args... args) &#123;</span><br><span class="line">    std::cout &lt;&lt; first &lt;&lt; &quot; &quot;;</span><br><span class="line">    print(args...); // 递归调用，展开参数包</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    print(1, 2, 3.5, &quot;Hello&quot;, &#x27;c&#x27;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">对于c++17</span><br><span class="line">// 使用折叠表达式处理参数包</span><br><span class="line">template&lt;typename... Args&gt;</span><br><span class="line">void print(Args... args) &#123;</span><br><span class="line">    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; &#x27;\n&#x27;; // 左折叠表达式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c++11&#x2F;14采用递归方式来进行可变参数展开；c++17采用折叠表达式展开可变参数。</p>
<p>折叠表达式的基本形式如下：</p>
<ol>
<li><strong>一元左折叠</strong>：<code>(... op pack)</code></li>
<li><strong>一元右折叠</strong>：<code>(pack op ...)</code></li>
<li><strong>二元左折叠</strong>：<code>(init op ... op pack)</code></li>
<li><strong>二元右折叠</strong>：<code>(pack op ... op init)</code></li>
</ol>
<p>其中，<code>op</code> 是一个二元运算符，<code>pack</code> 是参数包，<code>init</code> 是初始值。</p>
<h2 id="一元左折叠"><a href="#一元左折叠" class="headerlink" title="一元左折叠"></a>一元左折叠</h2><p>一元左折叠的语法是 <code>(... op pack)</code>，表示从左到右依次将参数包中的每个参数与运算符 <code>op</code> 进行运算。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (... + args); <span class="comment">// 一元左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 输出 15</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一元右折叠"><a href="#一元右折叠" class="headerlink" title="一元右折叠"></a>一元右折叠</h2><p>一元右折叠的语法是 <code>(pack op ...)</code>，表示从右到左依次将参数包中的每个参数与运算符 <code>op</code> 进行运算。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args + ...); <span class="comment">// 一元右折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 输出 15</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二元左折叠"><a href="#二元左折叠" class="headerlink" title="二元左折叠"></a>二元左折叠</h2><p>二元左折叠的语法是 <code>(init op ... op pack)</code>，其中 <code>init</code> 是初始值，表示从左到右依次将初始值和参数包中的每个参数与运算符 <code>op</code> 进行运算。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span> + ... + args); <span class="comment">// 二元左折叠，初始值为 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 输出 15</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二元右折叠"><a href="#二元右折叠" class="headerlink" title="二元右折叠"></a>二元右折叠</h2><p>二元右折叠的语法是 <code>(pack op ... op init)</code>，其中 <code>init</code> 是初始值，表示从右到左依次将参数包中的每个参数和初始值与运算符 <code>op</code> 进行运算。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args + ... + <span class="number">0</span>); <span class="comment">// 二元右折叠，初始值为 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 输出 15</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="支持的运算符"><a href="#支持的运算符" class="headerlink" title="支持的运算符"></a>支持的运算符</h2><p>折叠表达式支持多种二元运算符，包括但不限于：</p>
<ul>
<li>算术运算符：<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code></li>
<li>逻辑运算符：<code>&amp;&amp;</code>, <code>||</code></li>
<li>位运算符：<code>&amp;</code>, <code>|</code>, <code>^</code></li>
<li>比较运算符：<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></li>
<li>其他运算符：<code>,</code>, <code>.*</code>, <code>-&gt;*</code></li>
</ul>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>Q：vs宏__cplusplus始终显示199711L</p>
<p>A：在vs项目属性设置里头的“c++语言标准”里头设置了c++11或者c++17版本，代码里头看到__cplusplus宏始终显示199711L，这是考虑到历史代码兼容性问题（很多老代码用到此宏），编译器不会修改此宏，除非通过 &#x2F;Zc:cplusplus显示设置。在vc中可以使用_MSVC_LANG宏来获取当前用的语言标准版本</p>
<p>Q：MSVC中函数传值返回一个对象，调试发现并没有调用移动构造函数</p>
<p>A：这是因为MSVC编译器有可能做了RVO（返回值优化），通常是默认开启的，测试发现哪怕禁用优化，RVO还是生效。此种情况下，编译器可能直接在调用者的变量空间中构造返回的对象。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/650986900">https://zhuanlan.zhihu.com/p/650986900</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/455848360">https://zhuanlan.zhihu.com/p/455848360</a></p>
<p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/">https://en.cppreference.com/w/</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/650986900">https://zhuanlan.zhihu.com/p/650986900</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/139515439">https://zhuanlan.zhihu.com/p/139515439</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jerrywang2013.github.io/2024/05/27/c-11/" data-id="clwofja4x0000oo4q1oi39uw7" data-title="c++11" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-QT" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/05/18/QT/" class="article-date">
  <time class="dt-published" datetime="2024-05-18T00:56:13.000Z" itemprop="datePublished">2024-05-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/05/18/QT/">QT</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h1><h2 id="Q：如何理解qt中的signal和slot"><a href="#Q：如何理解qt中的signal和slot" class="headerlink" title="Q：如何理解qt中的signal和slot"></a>Q：<strong>如何理解qt中的signal和slot</strong></h2><p>A：简单点说，signal类似事件或者消息，slot类似事件或者消息handler；常见的需求是动作发生后对应的事件（或者消息）被触发进而触发对应的handler处理，这样的话，只需要捕获动作对应的事件和消息即可。slot这里可以自定义，也有一部分预先定义好的，比如window有一个关闭的slot，那么我们可以将一个按钮的点击信号关联到窗口的关闭handler，实现点击按钮就关闭窗口的效果。</p>
<p>​		用slot这个概念很形象，功能handler就像一个插槽一样，这里的siganal和slot就像将电线接到插槽上形成通路一样，signal发出就会触发handler执行。</p>
<p>signale和slot的连接通过 <code>**QObject::connect**</code>实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FooObjectA *fooA = new FooObjectA();</span><br><span class="line">FooObjectB *fooB = new FooObjectB();</span><br><span class="line"></span><br><span class="line">QObject::connect(fooA, SIGNAL (bared()), fooB, SLOT (baz()));</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>signal可以连接signal，从这个角度看，signal可以充当信号中转</p>
<h2 id="Q：Qt-Designer对mainwindow重置布局就会导致程序崩溃"><a href="#Q：Qt-Designer对mainwindow重置布局就会导致程序崩溃" class="headerlink" title="Q：Qt Designer对mainwindow重置布局就会导致程序崩溃"></a><strong>Q：Qt Designer对mainwindow重置布局就会导致程序崩溃</strong></h2><p><strong>A：</strong>暂时不知！</p>
<h2 id="Q：界面ui文件如何生成相应的代码"><a href="#Q：界面ui文件如何生成相应的代码" class="headerlink" title="Q：界面ui文件如何生成相应的代码"></a><strong>Q：界面ui文件如何生成相应的代码</strong></h2><p><strong>A：</strong>默认情况下，通过designer创建一个界面(例如mainwindow.ui)文件，会同步自动创建对应的界面类mainwindow.h和mainwindow.cpp文件，并且在编译之后在编译目录生成ui_mainwindow.h文件，此文件是解析界面mainwindow.ui文件(xml)，生成对应窗口的创建代码。</p>
<p>​		对应的mainwindow.h定义的是类MainWindow，生成的ui_mainwindow.h对应的是界面类UI::MainWindow(等价于编译生成文件中的Ui_MainWindow类)，然后MainWindow类中成员ui指针类型是UI::MainWindow*，MainWindow构造函数会new UI::MainWindow对象赋值给ui，然后调用UI::MainWindow::setupUi来初始化界面元素。</p>
<h2 id="Q：为何有些ui文件编译时不会生成对应的ui-xxx-h文件？"><a href="#Q：为何有些ui文件编译时不会生成对应的ui-xxx-h文件？" class="headerlink" title="Q：为何有些ui文件编译时不会生成对应的ui_xxx.h文件？"></a><strong>Q：为何有些ui文件编译时不会生成对应的ui_xxx.h文件？</strong></h2><p><strong>A：</strong>项目编译的时候，会用预处理工具uic对ui文件进行处理，生成对应的头文件，并非所有的ui文件在编译的时候都会生成对应的头文件，因为uic只会对工程pro文件中的FORMS参数中的ui进行预编译生成对应的头文件。用qt creator创建ui文件一般会自动添加到项目中，会自动修改pro文件，将ui追加到FORMS变量中。</p>
<h2 id="Q：mainwindow-cpp为何可以直接-include-“ui-mainwindow-h”？他们并不在同一个目录"><a href="#Q：mainwindow-cpp为何可以直接-include-“ui-mainwindow-h”？他们并不在同一个目录" class="headerlink" title="Q：mainwindow.cpp为何可以直接#include “ui_mainwindow.h”？他们并不在同一个目录"></a><strong>Q：mainwindow.cpp为何可以直接#include “ui_mainwindow.h”？他们并不在同一个目录</strong></h2><p><strong>A：</strong>ui文件不一定非要放在项目目录下，比如放在&#x2F;ui&#x2F;mainwindow.ui，只需要修改pro文件FORMS中ui文件的路径即可，例如FORMS +&#x3D; ui&#x2F;mainwindow.ui。ui编译后生成的ui_mainwindow.h文件在build目录下，mainwindow.cpp是直接include ui_mainwindow.h，哪里头文件搜索路径在哪里设置的？pro文件并没有看到include文件搜索路径。</p>
<p>​		pro文件确实没有，这个是qt默认的生成规则，qmake在处理pro文件的时候会生成makefile文件，我们可以打开makefile.debug文件看一下，里头INCPATH并没有包括了build目录。这是因为生成的ui_mainwindow.h文件和makefile文件是同一个目录，所以对ui_mainwindow.h文件的引用并不需要在incpath中添加路径。但是mainwindow.cpp文件在项目目录而不是build目录，和ui_mainwindow.h文件不在同一个目录之所以能直接#include “ui_maindown.h”，是因为makefile文件中mainwindow.cpp目标依赖是..\..\mainwindow.cpp。</p>
<h2 id="Q：除了用uic编译ui文件生成-h文件，还有没有其他办法使用ui文件？"><a href="#Q：除了用uic编译ui文件生成-h文件，还有没有其他办法使用ui文件？" class="headerlink" title="Q：除了用uic编译ui文件生成.h文件，还有没有其他办法使用ui文件？"></a><strong>Q：除了用uic编译ui文件生成.h文件，还有没有其他办法使用ui文件？</strong></h2><p><strong>A：</strong>还可以用QUiLoader，需要使用QtUiTools库（修改pro文件的QT +&#x3D; widgets uitools）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 这里calculatorform.ui是在资源文件下的forms过滤器下</span><br><span class="line">QFile file(&quot;:/forms/calculatorform.ui&quot;);</span><br><span class="line">file.open(QFile::ReadOnly);</span><br><span class="line">QWidget *formWidget = loader.load(&amp;file, this);</span><br><span class="line">file.close();</span><br></pre></td></tr></table></figure>



<h2 id="Q-QObject-findChild"><a href="#Q-QObject-findChild" class="headerlink" title="Q:  QObject::findChild"></a><strong>Q:  QObject::findChild</strong></h2><p><strong>A:</strong> 可用于Widget查找子窗体。todo…</p>
<h2 id="Q-QObject-staticMetaObject"><a href="#Q-QObject-staticMetaObject" class="headerlink" title="Q: QObject::staticMetaObject"></a><strong>Q: QObject::staticMetaObject</strong></h2><p><strong>A:</strong><code>staticMetaObject</code> 是 Qt 中 QObject 类的静态成员，它返回与特定对象类型相关联的元对象。元对象（Meta Object）是 QObject 的一个重要概念，它包含了有关对象类型的元信息，比如对象的类名、父类、属性、信号和槽等信息。</p>
<p>对于任何继承自 QObject 的类，都可以使用 <code>staticMetaObject</code> 来获取与其相关联的元对象。这个元对象是在编译时生成的，包含了所有静态信息，因此可以在运行时快速地访问对象的元信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QObject&gt;</span><br><span class="line"></span><br><span class="line">// 定义一个继承自 QObject 的类</span><br><span class="line">class MyClass : public QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    // 其他类定义</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 在需要获取元对象的地方，使用 staticMetaObject</span><br><span class="line">const QMetaObject *metaObject = MyClass::staticMetaObject;</span><br></pre></td></tr></table></figure>

<p>​		上面的代码定义了一个继承自 QObject 的类 MyClass，并在需要的地方使用了 <code>staticMetaObject</code> 获取了 MyClass 类的元对象。一旦获取了元对象，就可以通过元对象访问对象的各种属性、信号和槽等元信息。</p>
<ul>
<li><p><strong>访问属性信息</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 获取属性个数</span><br><span class="line">int propertyCount = metaObject-&gt;propertyCount();</span><br><span class="line"></span><br><span class="line">// 遍历所有属性</span><br><span class="line">for (int i = 0; i &lt; propertyCount; ++i) &#123;</span><br><span class="line">    QMetaProperty property = metaObject-&gt;property(i);</span><br><span class="line">    qDebug() &lt;&lt; &quot;Property Name: &quot; &lt;&lt; property.name();</span><br><span class="line">    qDebug() &lt;&lt; &quot;Property Type: &quot; &lt;&lt; property.typeName();</span><br><span class="line">    qDebug() &lt;&lt; &quot;Is Readable: &quot; &lt;&lt; property.isReadable();</span><br><span class="line">    qDebug() &lt;&lt; &quot;Is Writable: &quot; &lt;&lt; property.isWritable();</span><br><span class="line">    // 其他属性信息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>访问信号信息</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 获取信号个数</span><br><span class="line">int signalCount = metaObject-&gt;methodCount();</span><br><span class="line">for (int i = metaObject-&gt;methodOffset(); i &lt; signalCount; ++i) &#123;</span><br><span class="line">    QMetaMethod method = metaObject-&gt;method(i);</span><br><span class="line">    if (method.methodType() == QMetaMethod::Signal) &#123;</span><br><span class="line">        qDebug() &lt;&lt; &quot;Signal Name: &quot; &lt;&lt; method.name();</span><br><span class="line">        qDebug() &lt;&lt; &quot;Parameter Types: &quot; &lt;&lt; method.parameterTypes();</span><br><span class="line">        // 其他信号信息</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>访问slot信息</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 获取槽个数</span><br><span class="line">int slotCount = metaObject-&gt;methodCount();</span><br><span class="line">for (int i = metaObject-&gt;methodOffset(); i &lt; slotCount; ++i) &#123;</span><br><span class="line">    QMetaMethod method = metaObject-&gt;method(i);</span><br><span class="line">    if (method.methodType() == QMetaMethod::Slot) &#123;</span><br><span class="line">        qDebug() &lt;&lt; &quot;Slot Name: &quot; &lt;&lt; method.name();</span><br><span class="line">        qDebug() &lt;&lt; &quot;Parameter Types: &quot; &lt;&lt; method.parameterTypes();</span><br><span class="line">        // 其他槽信息</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>调用槽函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个对象</span><br><span class="line">QObject *obj = new QObject();</span><br><span class="line"></span><br><span class="line">// 获取槽函数的索引</span><br><span class="line">int slotIndex = metaObject-&gt;indexOfSlot(&quot;slotFunctionName()&quot;);</span><br><span class="line"></span><br><span class="line">// 调用槽函数</span><br><span class="line">if (slotIndex != -1) &#123;</span><br><span class="line">    QMetaMethod slotMethod = metaObject-&gt;method(slotIndex);</span><br><span class="line">    slotMethod.invoke(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Q：解析一下：moc-classname-cpp文件"><a href="#Q：解析一下：moc-classname-cpp文件" class="headerlink" title="Q：解析一下：moc_classname.cpp文件"></a><strong>Q：解析一下：moc_classname.cpp文件</strong></h2><p><strong>A：</strong>对象声明文件中如果有Q_OBJECT宏，则会生成moc_classname.cpp文件。</p>
<p><code>qt_meta_stringdata_TextFinder</code>：signal和slot声明的函数原型涉及到的返回值、函数名、参数类型、参数名等等的字符串表。本质是一个字符串表，里头把所有用到的字符串去重后统一存在一个字符数组中，然后建立一个索引表（索引数组，可以用于遍历字符串表），每个索引项记录了字符串的起始指针和长度</p>
<p><code>qt_meta_data_TextFinder</code>: uint数组，内部结构其实是QMetaObjectPrivate，在QMetaObjectPrivate后面跟着是method(signal&#x2F;slot)的原型定义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct QMetaObjectPrivate</span><br><span class="line">&#123;</span><br><span class="line">  // revision 7 is Qt 5.0 everything lower is not supported</span><br><span class="line">  // revision 8 is Qt 5.12: It adds the enum name to QMetaEnum</span><br><span class="line">  enum &#123; OutputRevision = 8 &#125;; // Used by moc, qmetaobjectbuilder and qdbus</span><br><span class="line">  int revision;</span><br><span class="line">  int className;</span><br><span class="line">  int classInfoCount, classInfoData;</span><br><span class="line">  int methodCount, methodData;</span><br><span class="line">  int propertyCount, propertyData;</span><br><span class="line">  int enumeratorCount, enumeratorData;</span><br><span class="line">  int constructorCount, constructorData;</span><br><span class="line">  int flags;</span><br><span class="line">  int signalCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例（相关的注释在代码中）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// 字符串表总体结构，其中data是字符串表的索引信息，stringdata0是压缩在一起的所有字符串的字节数组。</span><br><span class="line">// 字符串表 = 字符串索引表 + 所有字符串连接起来的大字节数组</span><br><span class="line">struct qt_meta_stringdata_TextFinder_t &#123;</span><br><span class="line">    QByteArrayData data[16];</span><br><span class="line">    char stringdata0[160];</span><br><span class="line">&#125;;</span><br><span class="line">// 计算字字符串表中的每个字符串的索引信息，每个字符串在字符串表中的索引信息</span><br><span class="line">// 注意：字符串的索引信息包括字符串长度size和字符串偏移offset。其中offset并非在字符串表中的偏移，而是相对于当前字符串索引项指针的偏移</span><br><span class="line">// 例如：假设ptr是执行字符串表的索引表的第n个字符串指针，是QByteArrayData*ptr，那么对应的字符串的地址是(char *)ptr+offset</span><br><span class="line">// 可以参考下面QArrayData::data()代码实现来理解</span><br><span class="line">#define QT_MOC_LITERAL(idx, ofs, len) \</span><br><span class="line">    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \</span><br><span class="line">    qptrdiff(offsetof(qt_meta_stringdata_TextFinder_t, stringdata0) + ofs \</span><br><span class="line">        - idx * sizeof(QByteArrayData)) \</span><br><span class="line">    )</span><br><span class="line">    // 构造字符串表：字符串索引表 + 大的字符串字节数组</span><br><span class="line">static const qt_meta_stringdata_TextFinder_t qt_meta_stringdata_TextFinder = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">QT_MOC_LITERAL(0, 0, 10), // &quot;TextFinder&quot;</span><br><span class="line">QT_MOC_LITERAL(1, 11, 14), // &quot;custom_clicked&quot;</span><br><span class="line">QT_MOC_LITERAL(2, 26, 0), // &quot;&quot;</span><br><span class="line">QT_MOC_LITERAL(3, 27, 7), // &quot;checked&quot;</span><br><span class="line">QT_MOC_LITERAL(4, 35, 15), // &quot;custom_clicked2&quot;</span><br><span class="line">QT_MOC_LITERAL(5, 51, 1), // &quot;a&quot;</span><br><span class="line">QT_MOC_LITERAL(6, 53, 11), // &quot;const char*&quot;</span><br><span class="line">QT_MOC_LITERAL(7, 65, 1), // &quot;s&quot;</span><br><span class="line">QT_MOC_LITERAL(8, 67, 15), // &quot;custom_clicked3&quot;</span><br><span class="line">QT_MOC_LITERAL(9, 83, 1), // &quot;c&quot;</span><br><span class="line">QT_MOC_LITERAL(10, 85, 5), // &quot;char*&quot;</span><br><span class="line">QT_MOC_LITERAL(11, 91, 1), // &quot;b&quot;</span><br><span class="line">QT_MOC_LITERAL(12, 93, 15), // &quot;custom_clicked4&quot;</span><br><span class="line">QT_MOC_LITERAL(13, 109, 6), // &quot;int8_t&quot;</span><br><span class="line">QT_MOC_LITERAL(14, 116, 20), // &quot;on_btnSearch_clicked&quot;</span><br><span class="line">QT_MOC_LITERAL(15, 137, 22) // &quot;on_btnSearch_pressdown&quot;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    //</span><br><span class="line">    &quot;TextFinder\0custom_clicked\0\0checked\0&quot;</span><br><span class="line">    &quot;custom_clicked2\0a\0const char*\0s\0&quot;</span><br><span class="line">    &quot;custom_clicked3\0c\0char*\0b\0custom_clicked4\0&quot;</span><br><span class="line">    &quot;int8_t\0on_btnSearch_clicked\0&quot;</span><br><span class="line">    &quot;on_btnSearch_pressdown&quot;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">#undef QT_MOC_LITERAL</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct Q_CORE_EXPORT QArrayData</span><br><span class="line">&#123;</span><br><span class="line">  QtPrivate::RefCount ref;</span><br><span class="line">  int size;</span><br><span class="line">  uint alloc : 31;</span><br><span class="line">  uint capacityReserved : 1;</span><br><span class="line">  qptrdiff offset; // in bytes from beginning of header</span><br><span class="line">  // QArrayData::data()就是上述获取其指向的数据的内容，可以看到offset是相对于自己(QArrayData *this)而言的</span><br><span class="line">  void *data()</span><br><span class="line">  &#123;</span><br><span class="line">​    Q_ASSERT(size == 0</span><br><span class="line">​        || offset &lt; 0 || size_t(offset) &gt;= sizeof(QArrayData));</span><br><span class="line">​    return reinterpret_cast&lt;char *&gt;(this) + offset;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><code>staticMetaObject</code>: QObject对象的静态metaobject</p>
<p>另外还有为用户定义的信号（signal函数）生成实现代码。注意，用户定义的信号只需要在头文件的类中给出函数申明即可，不需要定义。</p>
<p><strong>Q：QT布局</strong></p>
<p><strong>A：</strong>QT UI系统通过Layout&#x2F;sizePolicy&#x2F;StretchFactor来控制布局和控件的大小。</p>
<ul>
<li>布局控制<strong>子元素</strong>的排列，比如如果widget是QHBoxLayout布局，那么其所有子元素会水平布局</li>
<li>sizePolicy控制<strong>控件自己</strong>尺寸的行为，有下列选项<ul>
<li><strong>Fixed</strong>：控件将保持其固定大小，并不会改变。</li>
<li><strong>Minimum</strong>：控件将尽可能小，以适应其内容，但不会超过其最小尺寸。</li>
<li><strong>Maximum</strong>：控件将尽可能大，以填充可用空间，但不会超过其最大尺寸。</li>
<li><strong>Preferred</strong>：控件希望具有适当的大小，以显示其内容，但它可能会根据可用空间进行扩展或收缩。</li>
<li><strong>Expanding</strong>：控件希望尽可能大，以填充可用空间。如果可用空间增加，它将尝试扩展以填充更多空间。</li>
<li><strong>MinimumExpanding</strong>：控件希望尽可能大，以填充可用空间，并且具有最小尺寸。</li>
<li><strong>Ignored</strong>：布局管理器会忽略控件的大小，控件可以是任何大小。</li>
</ul>
</li>
<li>StretchFactor</li>
</ul>
<p><strong>备注：</strong>在水平布局中，假设里头有2个子控件，默认设置sizePolicy水平方向均为prefered或者extended，父窗口调整大小，两个子控件会自动调整宽度以完全适应父窗口宽度。如果想在中间假如间隔，可以假如一个horzSpacer弹簧。如果想控制其中一个子控件宽度不变，修改该子控件sizePolicy水平为fixed还不行，还需要修改minimumsize.x为你相设置的宽度（不要尝试修改geometry的宽度，在布局下面，控件的geometry无法修改）</p>
<h2 id="Q：qrc文件"><a href="#Q：qrc文件" class="headerlink" title="Q：qrc文件"></a><strong>Q：qrc文件</strong></h2><p><strong>A：</strong>通过makefile可以看到编译时会用rcc.exe来编译qrc文件，生成对应的cpp文件。然后在程序入口地方可以用Q_INIT_RESOURCE(XXX);来初始化资源，内部调用qRegisterResourceData函数来注册资源数据。</p>
<h2 id="Q：-在线安装频繁提示网络错误，用代理和不用代理一样"><a href="#Q：-在线安装频繁提示网络错误，用代理和不用代理一样" class="headerlink" title="Q： 在线安装频繁提示网络错误，用代理和不用代理一样"></a><strong>Q： 在线安装频繁提示网络错误，用代理和不用代理一样</strong></h2><p><strong>A：</strong>尝试使用离线安装包（qt-creator-opensource-windows-x86_64-13.0.1.exe），里头可选择安装项目。</p>
<h2 id="Q：QtCreator编译后如何部署"><a href="#Q：QtCreator编译后如何部署" class="headerlink" title="Q：QtCreator编译后如何部署"></a><strong>Q：QtCreator编译后如何部署</strong></h2><p>A：编译后会生成可执行环境，进入到生成目录直接运行exe文件无法启动，提示依赖库不存在，不过可以在Creator中调试（会自动设置好依赖库路径）。发布的时候需要部署，qt自带了部署工具windeployqt.exe，具体的在开发包5.12.12\msvc2017_64\bin\（x64）或者5.12.12\msvc2017\bin\（x86）下面，此命令只需要一个exe文件名即可。例如：你可以将生成的output.exe文件拷贝到你要部署的目录，然后在部署目录下执行windeployqt.exe output.exe即可。</p>
<p>​		当然，我们也可以借助QtCreator工具来部署，在Kit中点击Run，打开运行配置，最上面就是部署配置，可以创建部署步骤(Customer Process Step)，例如我们先拷贝输出文件到部署目录然后部署，下面是示例&gt;2：</p>
<p><img src="/2024/05/18/QT/image-20240518091304577.png" alt="image-20240518091304577"></p>
<p><strong>注意：</strong>这里步骤一是想用copy命令拷贝，不要直接在command：里头输入copy，他会提示：invalid command。我们需要用cmd.exe &#x2F;c copy来执行拷贝，Command填入cmd.exe即可， &#x2F;c copy 填在arguments里头。</p>
<h1 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h1><p>1、<a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学开源软件镜像站</a></p>
<p>2、<a target="_blank" rel="noopener" href="https://download.qt.io/">qt官方下载站</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jerrywang2013.github.io/2024/05/18/QT/" data-id="clwbg5x4k0003z44q9fcu4qwg" data-title="QT" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-c-调试" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/05/14/c-%E8%B0%83%E8%AF%95/" class="article-date">
  <time class="dt-published" datetime="2024-05-13T22:52:45.000Z" itemprop="datePublished">2024-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/05/14/c-%E8%B0%83%E8%AF%95/">c++调试</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>好多年都没怎用c&#x2F;c++了，最近因为用到某个库写个小工具用到c++，这里简单记录下c++调试。</p>
<p>环境：VS2022</p>
<p>编译环境：x64 debug</p>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="简单的函数调用示例"><a href="#简单的函数调用示例" class="headerlink" title="简单的函数调用示例"></a>简单的函数调用示例</h2><ul>
<li><p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> s = <span class="built_in">sum</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sum:&quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码只有一个简单的函数调用，我们通过这个案例主要了解一下c++代码背后的机器码的样子，以及程序运行过程中栈和寄存器的变化。</p>
</li>
<li><p>反汇编</p>
<ul>
<li><p><strong>sum() 反汇编</strong>(被调用函数)</p>
<p><img src="/2024/05/14/c-%E8%B0%83%E8%AF%95/image-20240514070514439.png" alt="image-20240514070514439"></p>
<p>部分反汇编代码解释：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">push rbp; rbp值入栈，用于保存rbp寄存器，后面恢复用</span><br><span class="line">push rdi; rdi寄存器入栈，后面会用到rdi寄存器，这里值先保存</span><br><span class="line">sub rsp 0e8h; 将rsp减去0e8h，保留栈空间用于本函数(局部变量等）的使用</span><br><span class="line">mov eax, dword ptr[a]; 将a值赋值给eax寄存器</span><br><span class="line">mov ecx, dword ptr[b]; 将b值赋值给ecx寄存器</span><br><span class="line">lea eax, [rax+rcx+1]; 计算rax+rcx+1结果保存到eax</span><br><span class="line">lea rsp,[rbp+0c8h]; 恢复rsp，之前rsp用rbp+0e8h,然后rbp-=20h</span><br><span class="line">pop rdi; 恢复rdi寄存器</span><br><span class="line">pop rbp; 恢复rbp寄存器</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>main() 反汇编</strong>(调用函数)</p>
<p><img src="/2024/05/14/c-%E8%B0%83%E8%AF%95/image-20240514070345762.png" alt="image-20240514070345762"></p>
<p>主要看main函数调用sum()前后部分反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov edx, dword ptr[b];   变量b的值赋值给edx寄存器</span><br><span class="line">mov ecx, dword ptr[a];  变量a的值赋值给ecx寄存器</span><br><span class="line">call sum(07FF71D5411E5h); 调用sum函数</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>x64架构调用约定：</strong></p>
<ul>
<li><p>在x64 window平台下，函数参数传递默认情况下前四个整形或者指针参数统计寄存器传递(rcx, rdx, r8, r9)，后面的参数通过压栈传参。可以看到，这里2个参数是用了ecx和edx传参。</p>
<p>测试5个参数的传参：</p>
<pre><code>00007FF758712370  push        rbp  
00007FF758712372  push        rdi  
00007FF758712373  sub         rsp,158h  
00007FF75871237A  lea         rbp,[rsp+30h]
int s = sum(a, b, 3, 4, 5);
00007FF758712399  mov         dword ptr [rsp+20h],5    
00007FF7587123A1  mov         r9d,4  
00007FF7587123A7  mov         r8d,3  
00007FF7587123AD  mov         edx,dword ptr [b]  
00007FF7587123B0  mov         ecx,dword ptr [a]  
00007FF7587123B3  call        sum (07FF758711465h) 
</code></pre>
<p>​		可以看到参数处理是从左往右，前面四个参数用rcx、rdx、r8、r9传递，后面的参数压入栈传递（自左往右）， 第五个参数压入到rsp+20h位置，如果有第六个参数，则第六个参数在第五个参数之后入栈，对应位置在rsp+28h;</p>
</li>
<li><p>前4个参数如果是浮点参数，通过SSE寄存器xmm0-xmm3传递</p>
</li>
<li><p>由调用者为寄存器中的参数传递保留栈上的空间（至少分配32字节的阴影空间），被调用者可以访问这个栈空间来讲寄存器中的内容写回栈空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lea rbp,[rsp+30h]; </span><br><span class="line">这个代码就是为参数保留栈空间，以便调用者调用到。一般来说总长度是(总的参数个数)*8</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>不要以为前面四个参数是通过寄存器传递给被调用函数可以不用为参数保留栈空间，哪怕调用者这边不用，也需要保留参数的栈空间，因为被调用者那边约定是将寄存器的内容写入到栈中。有个疑问，这样用寄存器传递参数不是多此一举，比直接用栈传递参数还少拷贝两次吗？</p>
</li>
<li><p>返回整数或者指针通过rax寄存器完成，浮点数返回值通过xmm0传递</p>
</li>
<li><p>堆栈保持16字节对齐（叶函数除外）</p>
</li>
<li><p>x64没有x86的stdcall&#x2F;cdecl&#x2F;fastcall&#x2F;thiscall等，只有一个x64调用约定</p>
</li>
</ul>
<p> 备注：</p>
<ol>
<li><p>call会将返回地址压入堆栈（esp&#x3D;esp-8)</p>
</li>
<li><p>栈是沿低地址延伸的，栈底地址是大于栈顶地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push rax  等价于 rsp--; *rsp = rax;</span><br><span class="line">pop rax 等价于rax = *rsp; rsp++;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>栈布局图</strong></p>
<img src="/2024/05/14/c-%E8%B0%83%E8%AF%95/image-20240515000343120.png" alt="image-20240515000343120" style="zoom:50%;">



<p><img src="https://learn.microsoft.com/en-us/cpp/build/media/vcamd_conv_ex_5.png?view=msvc-170" alt="Diagram of the stack layout for the x64 conversion example."></p>
<p><img src="/2024/05/14/c-%E8%B0%83%E8%AF%95/image-20240516120003269.png" alt="image-20240516120003269"></p>
<img src="/2024/05/14/c-%E8%B0%83%E8%AF%95/image-20240517133710237.png" alt="image-20240517133710237" style="zoom:80%;">

<h2 id="volatile-non-volatile-register"><a href="#volatile-non-volatile-register" class="headerlink" title="volatile &amp; non-volatile register"></a>volatile &amp; non-volatile register</h2><p>​		volatile register通常又称之为可变寄存器。可变的意思是在函数调用过程中寄存器值可能发生变化。</p>
<ul>
<li><p>常见volatile register</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RAX, RCX, RDX, R8, R9, R10, R11</span><br><span class="line">// 这几个寄存器常用语参数传递</span><br></pre></td></tr></table></figure>
</li>
<li><p>常见的non-volatile register</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RBX，RDI,RSI,RBP,RSP,R12,R13,R14,R15</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="x64函数中的Prolog和Epilog"><a href="#x64函数中的Prolog和Epilog" class="headerlink" title="x64函数中的Prolog和Epilog"></a>x64函数中的Prolog和Epilog</h2><p>x64 push&#x2F;pop指令限定在prolog和epilog中使用，因为在prolog和epilog之间rsp是不会被修改的。</p>
<h3 id="prolog"><a href="#prolog" class="headerlink" title="prolog"></a>prolog</h3><ul>
<li><p>将寄存器参数保存到调用函数分配的参数所在的栈空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">   通常代码如下，上面的4个mov指令是将寄存器参数保存到栈里头，对被调用函数而言，这段代码寻址是固定的，因为rsp指向的是返回地址，它的上面才是参数，所以第一个参数地址永远是rsp+8；第二个参数地址是rsp+10h，以此类推。</span><br><span class="line">*/</span><br><span class="line"> mov     dword ptr [rsp+20h],r9d</span><br><span class="line"> mov     dword ptr [rsp+18h],r8d</span><br><span class="line"> mov     dword ptr [rsp+10h],edx</span><br><span class="line"> mov     dword ptr [rsp+8],ecx</span><br><span class="line"> sub     rsp,18h</span><br></pre></td></tr></table></figure>


</li>
<li><p>保存本函数可能修改的volatile寄存器的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 类似如下反汇编代码，保存non-volatile寄存器</span><br><span class="line">00007FF78B541CE2  push        rbp  </span><br><span class="line">00007FF78B541CE3  push        rdi</span><br></pre></td></tr></table></figure>


</li>
<li><p>为函数局部变量分配栈空间，如果此函数有调用其他函数，还要为调用函数的参数分配空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00007FF78B541CE4  sub         rsp,108h  </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Epilog"><a href="#Epilog" class="headerlink" title="Epilog"></a>Epilog</h3><ul>
<li>清理函数在prolog中为其变量分配的堆栈空间以及函数参数堆栈空间</li>
<li>恢复non-volatile寄存器</li>
<li>返回到调用者</li>
</ul>
<p>x86堆栈操作与x64主要差别</p>
<p>​	x86堆栈操作严重以来ebp；而x64不依赖。</p>
<h1 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h1><p>​	在c&#x2F;c++中，调用约定指的是编译器如果安排函数调用中参数传递顺序、调用栈空间的清理、函数返回值传递等规则。不同平台和编译器有不同的函数调用约定，主要有三个：</p>
<ul>
<li><p>__cdecl</p>
<p>​	默认调用约定。参数从右往左压入堆栈，调用方负责清理堆栈，返回值通过寄存器传递。</p>
</li>
<li><p>__stdcall</p>
<p>​	windows平台常用。参数从右往左压入堆栈，被调用函数清理堆栈，返回值通过寄存器传递。</p>
</li>
<li><p>__thiscall</p>
<p>​		常用语类成员函数，将this指针作为隐式参数传递给函数，其它参数从右往左压入堆栈，调用者负责清理堆栈。</p>
</li>
</ul>
<p>​		不用太纠结用那个调用约定，本身只是一个规则而已。一般来说，通过返回指令ret 和 ret X能判断出是否是stdcall或者cdecl。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64">x86-64 上的堆栈框架布局 - Eli Bendersky 的网站 (thegreenplace.net)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wingsummer/p/16076345.html">x64 番外篇——知识铺垫 - 寂静的羽夏 - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/cpp/build/x64-software-conventions?view=msvc-170&redirectedfrom=MSDN">x64 ABI 约定 |Microsoft学习</a></p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170">x64 calling convention | Microsoft Learn</a></p>
<p><a target="_blank" rel="noopener" href="https://medium.com/@sruthk/cracking-assembly-introduction-to-assembly-language-a4ad14e601a1">破解程序集 — 程序集语言简介 |由 Sruthi K |中等 (medium.com)</a></p>
<h1 id="常用windbg命令"><a href="#常用windbg命令" class="headerlink" title="常用windbg命令"></a>常用windbg命令</h1><p>​		这里仅仅记录调试常用的命令，不全。需要详细的命令可以查看dbghelp.chm文件(debug tools for windwos包)</p>
<ul>
<li>设置符号&#x2F;源文件路径</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.sympath + &lt;pdb文件路径&gt;</span><br><span class="line">.srcpath + &lt;.cpp文件路径&gt;</span><br></pre></td></tr></table></figure>

<p>​		也可以在界面’文件‘菜单中点击’Symbol File Path‘设置符号文件路径；点击”Source File Path”打开代码文件路径。</p>
<ul>
<li><p>d </p>
<p>查看内存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d addr</span><br><span class="line">// 默认以字节为单位显示，也可以用db | dw | dd | dq来显示指定显示格式</span><br><span class="line">// 查看堆栈附近内存</span><br><span class="line">d rsp</span><br></pre></td></tr></table></figure>
</li>
<li><p>uf </p>
<p>查看函数汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uf [Module!]Function</span><br><span class="line">uf [Module!]Address</span><br><span class="line">address是函数地址，可以用名称，例如 </span><br><span class="line">uf ConsoleApplicaiton!main</span><br><span class="line">uf main</span><br></pre></td></tr></table></figure>
</li>
<li><p>切换调试模型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l+t 设置调试模式为源码模式</span><br><span class="line">l-t 设置调试模式为反汇编模式</span><br><span class="line">l+s 命令行显示行号</span><br><span class="line">l-s 命令行不显示行号</span><br></pre></td></tr></table></figure>
</li>
<li><p>!analyze</p>
<p>分析dump文件用到。</p>
</li>
<li><p>lm</p>
<p>显示模块信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lmOptions [a Address] [m Pattern | M Pattern]</span><br><span class="line">eg:</span><br><span class="line">lmDvm *Console*!*</span><br></pre></td></tr></table></figure>
</li>
<li><p>x</p>
<p>查看符号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x [opts] Module!Symbol</span><br><span class="line">x * // ！！！注意，这个是显示局部变量！！！</span><br><span class="line">eg:</span><br><span class="line">x sample!*main*</span><br><span class="line">支持*通配符，列出sample模块的所有含有字符串main的函数</span><br></pre></td></tr></table></figure>
</li>
<li><p>b</p>
<p>设置断点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bm sample!*main*   // bm设置函数断点</span><br><span class="line">bp address  // 设置地址断点</span><br></pre></td></tr></table></figure>
</li>
<li><p>r</p>
<p>显示寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; r</span><br><span class="line">rax=0000000000000006 rbx=0000000000000000 rcx=0000000000000006</span><br><span class="line">rdx=0000000000000001 rsi=0000000000000000 rdi=0000000000000000</span><br><span class="line">rip=00007ff696776656 rsp=00000051766ff640 rbp=00000051766ff670</span><br><span class="line"> r8=0000000000000002  r9=00000051766ff728 r10=0000000000000012</span><br><span class="line">r11=00000051766ff7d0 r12=0000000000000000 r13=0000000000000000</span><br><span class="line">r14=0000000000000000 r15=0000000000000000</span><br></pre></td></tr></table></figure>
</li>
<li><p>k</p>
<p>查看堆栈，如果要显示所有线程的堆栈：~*k</p>
</li>
<li><p>.formats</p>
<p>显示表达式和符号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.formats expression</span><br></pre></td></tr></table></figure>
</li>
<li><p>常见操作片段</p>
<p>假设调试ConsoleApplication1.exe</p>
<p>查看模块	 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//所有模块，然后点击某个模块可以列出函数</span><br><span class="line">lm</span><br><span class="line">// 查看某个模块</span><br><span class="line">lmv m Console*</span><br></pre></td></tr></table></figure>

<p>查看ConsoleApplicaiton1中的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 列出ConsoleApplication1中所有函数</span><br><span class="line">x ConsoleA*!*</span><br><span class="line">// 如果函数太多，可以用DML格式来显示。注意/D 后面接的是modulename（可统配），不要带方法</span><br><span class="line">x /D Console*!a*</span><br><span class="line">// 查看某个方法地址，从上面的DML显示中直接点击或者用通配符 找到函数符号和地址</span><br><span class="line">x /D ConsoleApplicati*!s*</span><br><span class="line">// 用bm或者bp设置断点。注意bp不会检测断点地址；bm会检测符号是否存在</span><br><span class="line">bm ConsoleApplication1!sum</span><br><span class="line">bp 00007ff7`8b541cc0</span><br><span class="line">// 恢复程序运行</span><br><span class="line">g</span><br><span class="line">// ....</span><br><span class="line">// 运行到断点处触发断点，程序中断</span><br><span class="line">// 显示局部变量</span><br><span class="line">dv</span><br><span class="line">dv /v 显示变量和变量的地址</span><br><span class="line">// 显示堆栈</span><br><span class="line">k</span><br><span class="line">// 显示内存</span><br><span class="line">db Address</span><br><span class="line">// 看寄存器</span><br><span class="line">r</span><br><span class="line">// 查看汇编</span><br><span class="line">u Address</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>​</p>
</li>
</ul>
<p>	</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jerrywang2013.github.io/2024/05/14/c-%E8%B0%83%E8%AF%95/" data-id="clwbg5x4l0005z44qcmrhab55" data-title="c++调试" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-用libharu完成一个小作业" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/05/11/%E7%94%A8libharu%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AA%E5%B0%8F%E4%BD%9C%E4%B8%9A/" class="article-date">
  <time class="dt-published" datetime="2024-05-10T23:35:56.000Z" itemprop="datePublished">2024-05-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/05/11/%E7%94%A8libharu%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AA%E5%B0%8F%E4%BD%9C%E4%B8%9A/">用libharu完成一个小作业</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>libharu是一个开源的pdf文件操作的C语言库。</p>
<p>因一个小作业需要用libharu而初步接触haru，这里简单记录一下自己的理解。	</p>
<h1 id="下载-安装"><a href="#下载-安装" class="headerlink" title="下载 &amp; 安装"></a>下载 &amp; 安装</h1><ul>
<li><p><strong>下载</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/libharu/libharu.git</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>安装</strong></p>
<p>​		参考readme和install说明。在windows下利用CMake进行安装。		</p>
<pre><code>    mkdir libharu_build
    cd libharu_build
    cmake ..\libharu
</code></pre>
<p>​		本机安装了vs2022, CMake会自动生成VS2022的工程文件。</p>
</li>
<li><p><strong>编译</strong></p>
<p>​		打开VS2022，打开libharu_build\libharu.sln文件，可正常编译通过，生成库文件在libharu_build\src\debug\，配置文件在libharu_build\include。可自行修改项目配置设置编译后生成的库文件目录，或者直接在postbuild里头加个脚本做生成后的发布（拷贝）。</p>
<p>​</p>
</li>
</ul>
<p>		</p>
<h1 id="libharu-功能"><a href="#libharu-功能" class="headerlink" title="libharu 功能"></a>libharu 功能</h1><p>​		简单看了下 <code>https://github.com/libharu/libharu/wiki</code>，了解一下haru的基本概念和一些设计思想。</p>
<h3 id="图形"><a href="#图形" class="headerlink" title="图形"></a>图形</h3><ul>
<li><h5 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h5><p>​		默认坐标轴原点(0,0)是页面左下角，右上角坐标是(页面宽，页面高)，xy轴方向分别是往右和往上；默认分辨率是72dpi。</p>
<p>​		可以用HPDF_Page_Concat()修改默认坐标系。	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HPDF_STATUS HPDF_Page_Concat  (HPDF_Page    page,</span><br><span class="line">                               HPDF_REAL    a,</span><br><span class="line">                               HPDF_REAL    b,</span><br><span class="line">                               HPDF_REAL    c,</span><br><span class="line">                               HPDF_REAL    d,</span><br><span class="line">                               HPDF_REAL    x,</span><br><span class="line">                               HPDF_REAL    y);</span><br></pre></td></tr></table></figure>

<p>​		wiki中没有讲参数含义，大概猜测这里的abcd是旋转矩阵的四个变量，xy应该是偏移量。</p>
<p><strong>例如：</strong></p>
<p>将坐标系沿着XY正方向偏移（100， 100）像素，新的原点是原来坐标系(100, 100)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HPDF_Page_Concat(page, 1, 0, 0, 1, 100, 100);</span><br></pre></td></tr></table></figure>

<p>​		</p>
</li>
<li><p><strong>图形模式</strong></p>
<p>​		libharu为每个pdf文档的每一页维护一个图形模式标志，用于控制绘图操作。图形模式不需要显示的去设置，而是通过相关的绘图函数来控制的，同样的，不同的图像模式下可以调用的函数也是不同的，必须保证函数能在合适的图像模式下调用，常见的调用错误是：</p>
<table>
<thead>
<tr>
<th align="left">HPDF_PAGE_INVALID_GMODE</th>
<th>0x1051</th>
<th>See Graphics mode.</th>
</tr>
</thead>
<tbody><tr>
<td align="left"></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>常见的三种GMode</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define  HPDF_GMODE_PAGE_DESCRIPTION    0x0001</span><br><span class="line">  </span><br><span class="line">#define  HPDF_GMODE_PATH_OBJECT       0x0002</span><br><span class="line">  </span><br><span class="line">#define  HPDF_GMODE_TEXT_OBJECT       0x0004</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>HPDF_GMODE_PAGE_DESCRIPTION</strong></p>
<p>可用操作：</p>
<ul>
<li><p>General graphics state</p>
</li>
<li><p>Special graphics state</p>
</li>
<li><p>Color</p>
</li>
<li><p>Text state</p>
</li>
</ul>
</li>
<li><p><strong>HPDF_GMODE_PATH_OBJECT</strong></p>
<p>可用操作：</p>
<ul>
<li>Path Construction</li>
</ul>
<p>	</p>
<p><strong>状态机：</strong></p>
<ul>
<li><p>调用绘图函数(Path Construction)进入</p>
</li>
<li><p>调用Path Painting Operators退出到<strong>HPDF_GMODE_PAGE_DESCRIPTION</strong></p>
</li>
</ul>
</li>
<li><p><strong>HPDF_GMODE_TEXT_OBJECT</strong></p>
<p><strong>可用操作：</strong></p>
<ul>
<li>Graphics state</li>
<li>Color</li>
<li>Text state</li>
<li>Text-showing</li>
<li>Text-positioning</li>
</ul>
<p><strong>状态机：</strong></p>
<ul>
<li><p>调用HPDF_Page_BeginText()进入</p>
</li>
<li><p>调用HPDF_Page_EndText()退出到<strong>HPDF_GMODE_PAGE_DESCRIPTION</strong></p>
</li>
</ul>
</li>
</ul>
<p><strong>Graphpics State</strong> 操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HPDF_Page_Concat()</span><br><span class="line">HPDF_Page_SetDash()</span><br><span class="line">HPDF_Page_SetFlat()</span><br><span class="line">HPDF_Page_SetLineCap()</span><br><span class="line">HPDF_Page_SetLineJoin()</span><br><span class="line">HPDF_Page_SetLineWidth()</span><br><span class="line">HPDF_Page_SetMiterLimit()</span><br></pre></td></tr></table></figure>

<p><strong>Color</strong>操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HPDF_Page_SetCMYKFill()</span><br><span class="line">HPDF_Page_SetCMYKStroke()</span><br><span class="line">HPDF_Page_SetGrayFill()</span><br><span class="line">HPDF_Page_SetGrayStroke()</span><br><span class="line">HPDF_Page_SetRGBFill()</span><br><span class="line">HPDF_Page_SetRGBStroke()</span><br></pre></td></tr></table></figure>

<p><strong>Path Construction</strong>操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HPDF_Page_Arc()</span><br><span class="line">HPDF_Page_Circle()</span><br><span class="line">HPDF_Page_CurveTo()</span><br><span class="line">HPDF_Page_CurveTo2()</span><br><span class="line">HPDF_Page_CurveTo3()</span><br><span class="line">HPDF_Page_LineTo()</span><br><span class="line">HPDF_Page_MoveTo()</span><br><span class="line">HPDF_Page_Rectangle()</span><br></pre></td></tr></table></figure>

<p><strong>Path Painting</strong>操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HPDF_Page_ClosePathFillStroke()</span><br><span class="line">HPDF_Page_ClosePathEofillStroke()</span><br><span class="line">HPDF_Page_ClosePathStroke()</span><br><span class="line">HPDF_Page_Eofill()</span><br><span class="line">HPDF_Page_EofillStroke()</span><br><span class="line">HPDF_Page_EndPath()</span><br><span class="line">HPDF_Page_Fill()</span><br><span class="line">HPDF_Page_FillStroke()</span><br><span class="line">HPDF_Page_Stroke()</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<p>​	简单说就是在description状态下调用绘图函数(Path Construction)进入绘图状态，调用绘图结束函数Path Painting)结束绘图；调用HPDF_Page_BeginText()进入文字绘制状态，调用HPDF_Page_EndText()退出文字绘制状态。</p>
<p>​	特别注意绘制状态，刚接触很容易碰到绘制状态不对导致的绘制函数调用错误（错误码0x1051）</p>
</li>
<li><p><strong>图形绘制</strong></p>
<p>​		大部分功能和windows的gdi绘制差不多，有stoke和fill相关的设置；有绘制line&#x2F;rectangle&#x2F;triangle&#x2F;cricle等等，方法也都类似。</p>
<ul>
<li><p><strong>HPDF_Page_Stroke</strong>  绘制路径</p>
</li>
<li><p>**HPDF_Page_FillStroke  **填充路径</p>
</li>
<li><p><strong>HPDF_Page_ClosePathFillStroke</strong> 封闭路径并且填充</p>
</li>
<li><p><strong>HPDF_Page_ClosePathStroke</strong> 封闭路径然后绘制路径</p>
</li>
<li><p><strong>HPDF_Page_EndPath</strong> 指示路径结束</p>
</li>
<li><p><strong>HPDF_Page_SetRGBFill</strong> 设置填充颜色</p>
</li>
<li><p><strong>HPDF_Page_SetRGBStroke</strong> 设置描边颜色</p>
</li>
<li><p><strong>HPDF_Page_SetRGBFill</strong> 设置填充灰度颜色</p>
</li>
<li><p><strong>HPDF_Page_SetGrayStroke</strong> 设置描边灰度颜色</p>
</li>
</ul>
</li>
<li><p><strong>高级绘制功能</strong></p>
<p>libharu提供了extgstate相关的函数，可以控制透明度、混合模式，具体实现在hpdf_ext_gstate.c，示例代码：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HPDF_Page_GSave (page);</span><br><span class="line">gstate = HPDF_CreateExtGState (pdf);</span><br><span class="line">HPDF_ExtGState_SetAlphaFill (gstate, 0.8);</span><br><span class="line">HPDF_ExtGState_SetAlphaStroke (gstate, 0.8);</span><br><span class="line">HPDF_Page_SetExtGState (page, gstate);</span><br><span class="line">draw_circles (page, &quot;alpha fill = 0.8&quot;, 230.0f, PAGE_HEIGHT - 170);</span><br><span class="line">HPDF_Page_GRestore (page);</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>文字绘制</strong></p>
<p>​	绘制文字接口有HPDF_Page_ShowText()、TextOut()、TextRect()、ShowTextNextLine()等接口。关于文字绘制，需要注意的地方：</p>
<ul>
<li><p>位置属性的更新。比如我们要在指定位置绘制文字，可以用TextOut()方法指定posx&#x2F;posy绘制，也可以用ShowText()方法。使用ShowText()方法要注意，需要先定位好位置，也就是调用HPDF_Page_MoveTextPos()方法，此方法的参数x&#x2F;y是相对当前未知的偏移，这个特别要注意。另外，当你在同一行用MoveTextPos()在x轴偏移了，然后当你想换行在最左开始绘制新的文字，这时候要注意了，需要将位置重定位到x&#x3D;0的位置，而MoveTextPos()方法是偏移相对位置。</p>
</li>
<li><p>中英文汉字绘制问题。需要设置字体和编码，字体用GB-EUC-H编码，文字用GBK可以。</p>
<ul>
<li><strong>GB编码支持</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HPDF_Font font = HPDF_GetFont(pdf, fontName, &quot;GB-EUC-H&quot;);</span><br><span class="line">HPDF_REAL size = 32;</span><br><span class="line">HPDF_Page_SetFontAndSize(page, font, size);</span><br></pre></td></tr></table></figure>

<p>注意，需要在之前调用HPDF_UseCNSEncodings(pdf);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HPDF_UseCNSFonts(pdf);</span><br><span class="line">HPDF_UseCNSEncodings(pdf);</span><br></pre></td></tr></table></figure>

<p>​		GB-EUC-H支持GB2312简体中文编码，实现文件在hpdf_encoder_cns.c，可以看看文件中的GB_EUC_IsLeadByte函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static HPDF_BOOL</span><br><span class="line">GB_EUC_IsLeadByte (HPDF_Encoder encoder, HPDF_BYTE b)</span><br><span class="line">&#123;</span><br><span class="line">  HPDF_UNUSED (encoder);</span><br><span class="line">  return (b &gt;= 0xa1 &amp;&amp; b &lt;= 0xfe);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		可以看出这个是简单的判断是否是GB2312 汉字的首字节编码范围。</p>
<ul>
<li><strong>UTF8支持</strong></li>
</ul>
<p>	</p>
<p>GB-EUC-H不支持多国语言，想要更通用的多国语言支持，建议使用UTF8编码。调用HPDF_UseUTFEncodings来开启UTF8编码的支持，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HPDF_EXPORT(HPDF_STATUS) HPDF_UseUTFEncodings(HPDF_Doc pdf)</span><br></pre></td></tr></table></figure>

<p>​		libharu对于utf8的支持在hpdf_encoder_utf.c文件实现，主要有下面几个函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static HPDF_ByteType UTF8_Encoder_ByteType_Func (HPDF_Encoder encoder, HPDF_ParseText_Rec  *state);</span><br><span class="line"></span><br><span class="line">static HPDF_UNICODE UTF8_Encoder_ToUnicode_Func(HPDF_Encoder  encoder,         HPDF_UINT16 code);</span><br></pre></td></tr></table></figure>

<p>​		这里主要是完成utf8-&gt;unicode的编码转换，其中UTF8_Encoder_ByteType_Func用于获取utf8字符串的字符个数（不是字节）；UTF8_Encoder_ToUnicode_Func用于将utf8编码的字符串转为unicode字符串。这里没有用第三方库进行编码转换，直接跟进UTF8编码规则，完成UTF和Unicode的编码拆组。</p>
</li>
<li><p><strong>文字高级渲染</strong></p>
<ul>
<li><p>HPDF_Page_SetTextMatrix</p>
<p>控制文字变换矩阵。</p>
<p>例如： </p>
<p><strong>旋转矩阵</strong>：		</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a  b  0 </span><br><span class="line">c  d  0 </span><br><span class="line">0  0  1</span><br><span class="line"></span><br><span class="line">a = cos(θ)</span><br><span class="line">b = -sin(θ)</span><br><span class="line">c = sin(θ)</span><br><span class="line">d = cos(θ)</span><br></pre></td></tr></table></figure>

<p><strong>斜切矩阵：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1           tan(α)  0 </span><br><span class="line">tan(β)      1       0 </span><br><span class="line">0           0       1</span><br></pre></td></tr></table></figure>

<p><strong>缩放：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2  0  0</span><br><span class="line">0  2  0</span><br><span class="line">0  0  1</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>HPDF_Page_SetCharSpace</strong></p>
<p>设置字符间距</p>
</li>
<li><p><strong>HPDF_Page_SetWordSpace</strong></p>
<p>设置单词间距</p>
</li>
<li><p><strong>HPDF_Page_TextRect</strong></p>
<p>支持文字绘制的对齐模式设置</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>大纲绘制</strong>		</p>
<p>​		利用HPDF_CreateOutline函数可以创建树形大纲列表，HPDF_Outline_SetOpened函数可以设置大纲项打开状态，HPDF_Outline_SetDestination可以用于目标位置的关联。</p>
<ul>
<li><pre><code>HPDF_Outline HPDF_CreateOutline(HPDF_Doc pdf, 
            HPDF_Outline parent, 
            const char *title, 
            HPDF_Encoder encoder);
HPDF_STATUS HPDF_Outline_SetOpened  (HPDF_Outline outline, HPDF_BOOL opened)
HPDF_STATUS HPDF_Outline_SetDestination (HPDF_Outline outline, HPDF_Destination dst)
</code></pre>
</li>
</ul>
</li>
</ul>
<p>​		</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jerrywang2013.github.io/2024/05/11/%E7%94%A8libharu%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AA%E5%B0%8F%E4%BD%9C%E4%B8%9A/" data-id="clwbg5x4n000az44qe72ffg9u" data-title="用libharu完成一个小作业" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-宝塔面板ApacheServer配置" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/05/09/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BFApacheServer%E9%85%8D%E7%BD%AE/" class="article-date">
  <time class="dt-published" datetime="2024-05-09T06:31:22.000Z" itemprop="datePublished">2024-05-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/05/09/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BFApacheServer%E9%85%8D%E7%BD%AE/">宝塔面板ApacheServer配置</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>​	Windows + Apache2.4 + PHP7.4 + Mysql5.6</p>
<p>​	直接安装宝塔面板，然后通过宝塔面板安装Apache、PHP、Mysql即可。</p>
<h1 id="WebServer配置"><a href="#WebServer配置" class="headerlink" title="WebServer配置"></a>WebServer配置</h1><p>​	启动宝塔面板，进入宝塔控制后台，点击左侧菜单“网站”，点击“新建站点”，创建一个Web服务器，设置好域名、默认文档、伪静态、网站目录等，下面记录常见可能出问题的点。</p>
<ul>
<li><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>​	在网站设置里头，可以点击左侧“域名管理”来配置域名，域名形如：<a href="http://www.domain.com:port，可以指定端口，不显示指定端口默认就是80。">www.domain.com:port，可以指定端口，不显示指定端口默认就是80。</a></p>
<p>​	这里假设设置的域名是<a href="http://www.crm.com，端口80，这里对应的配置有两个地方：">www.crm.com，端口80，这里对应的配置有两个地方：</a></p>
<ul>
<li><p><strong>告诉apache监听端口</strong></p>
</li>
<li><p><strong>设置站点的VirtualHost配置</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​	需要注意的是，如果我们修改站点的域名映射，比如新加一个域名<a href="http://www.crm-mini.com:8090，宝塔面板会修改apache/conf/httpd.conf文件，在顶部增加Listen">www.crm-mini.com:8090，宝塔面板会修改apache/conf/httpd.conf文件，在顶部增加Listen</a> 8090。问题是这个操作不是可靠的，反复修改站点域名映射有时候就能发现Listen的端口混乱，所以如果发现修改配置后没效果，可以检查下httpd.conf文件配置，手动修改；</p>
<p>​	另外，同一个站点配置多个域名，不要用不同的端口，否则宝塔也会弄混淆，搞错监听端口。不同域名是通过在VirtualHost里头的ServerAlias来配置，例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerAlias www.crm-mini.com 127.0.0.1</span><br></pre></td></tr></table></figure>


</li>
<li><h3 id="伪静态"><a href="#伪静态" class="headerlink" title="伪静态"></a>伪静态</h3><p>​	伪静态是利用url重写技术，实现类似静态url的效果，本质是url rewrite。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mod_rewrite.c&gt;</span><br><span class="line"> RewriteEngine on</span><br><span class="line"> RewriteBase /</span><br><span class="line"> RewriteCond %&#123;REQUEST_FILENAME&#125; !-d</span><br><span class="line"> RewriteCond %&#123;REQUEST_FILENAME&#125; !-f</span><br><span class="line"> RewriteRule ^(.*)$ index.php?s=/$1 [QSA,PT,L]</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure>

<p>​	在web服务器的根目录的.htaccess文件中加入上述伪静态指令，当请求<a target="_blank" rel="noopener" href="http://doamin.com/aaa%E4%BC%9A%E5%B0%86%E8%AE%BF%E9%97%AE%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0index.php/s=aaa%EF%BC%88%E5%BD%93aaa%E4%B8%8D%E6%98%AF%E6%96%87%E4%BB%B6%E6%88%96%E8%80%85%E7%9B%AE%E5%BD%95%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%89">http://doamin.com/aaa会将访问重定向到index.php/s=aaa（当aaa不是文件或者目录的情况下）</a></p>
<p>​	利用mod_rewrite功能，我们可以定义一些规则做请求的重定向。</p>
</li>
<li><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><ul>
<li><p><strong>Rewrite url</strong></p>
<p>​		宝塔面板的重定向也是配置RewriteRule，尝试将&#x2F;crm的请求映射到另外一个web站点失败。</p>
<p>例如：有两个站点 <a target="_blank" rel="noopener" href="http://www.crm-mini.com/">http://www.crm-mini.com</a> 和  <a target="_blank" rel="noopener" href="http://www.crm-normal.com对应本地的两个web目录,现在想只通过http//www.crm-mini.com%E4%B8%80%E4%B8%AA%E5%85%A5%E5%8F%A3%E8%AE%BF%E9%97%AE%E4%B8%A4%E4%B8%AAweb%E7%9B%AE%E5%BD%95%EF%BC%8C%E6%AF%94%E5%A6%82http://www.crm-mini.com/normal/%E8%87%AA%E5%8A%A8%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0crm-normal%E7%9B%AE%E5%BD%95">http://www.crm-normal.com对应本地的两个web目录，现在想只通过http://www.crm-mini.com一个入口访问两个web目录，比如http://www.crm-mini.com/normal/自动重定向到crm-normal目录</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mod_rewrite.c&gt;</span><br><span class="line"> RewriteEngine on</span><br><span class="line"> RewriteRule ^crm(.*)$ http://www.crm-normal.com/$1 [L,R=301]</span><br><span class="line"></span><br><span class="line"> RewriteBase /</span><br><span class="line"> RewriteCond %&#123;REQUEST_FILENAME&#125; !-d</span><br><span class="line"> RewriteCond %&#123;REQUEST_FILENAME&#125; !-f</span><br><span class="line"> RewriteRule ^(.*)$ index.php?s=/$1 [QSA,PT,L]</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure>

<p>​		注意上述第三行，碰到dowmain&#x2F;后面接着是crm就跳转到<a href="http://www.crm-normal.com。`[L,R=301]`">http://www.crm-normal.com。`[L,R=301]`</a> 则指示 Apache 使用 301 永久重定向，L表示停止进一步的重写规则匹配。</p>
</li>
<li><p><strong>Alias</strong></p>
<p>​	用到的一种另外实现方法是在VirtualHost中配置Alias</p>
<pre><code>&lt;VirtualHost *:80&gt;
    ServerAdmin webmaster@yourdomain.com
    DocumentRoot &quot;/var/www/html&quot;
    ServerName www.yourdomain.com
    # 配置针对 crm-normal 的请求
    Alias &quot;/crm-normal&quot; &quot;/var/www/html/crm-normal&quot;
    &lt;Directory &quot;/var/www/html/crm-normal&quot;&gt;
        Options Indexes FollowSymLinks
        AllowOverride All
        Require all granted
    &lt;/Directory&gt;

    # 配置针对 crm-mini 的请求
    Alias &quot;/crm-mini&quot; &quot;/var/www/html/crm-mini&quot;
    &lt;Directory &quot;/var/www/html/crm-mini&quot;&gt;
        Options Indexes FollowSymLinks
        AllowOverride All
        Require all granted
    &lt;/Directory&gt;

    ErrorLog &quot;/var/log/apache2/yourdomain-error.log&quot;
    CustomLog &quot;/var/log/apache2/yourdomain-access.log&quot; combined
&lt;/VirtualHost&gt;
</code></pre>
<p>​		这样配置后，当访问 <code>http://www.yourdomain.com/crm-normal</code> 时，会展示 <code>crm-normal</code> 站点的内容，而访问 <code>http://www.yourdomain.com/crm-mini</code> 则会展示 <code>crm-mini</code> 站点的内容。</p>
<p>​	</p>
<p>重定向能解决只用一个域名一个端口绑定多个web站点，无需每个域名对应一个站点。</p>
</li>
</ul>
</li>
<li></li>
</ul>
<p>​	</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jerrywang2013.github.io/2024/05/09/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BFApacheServer%E9%85%8D%E7%BD%AE/" data-id="clwbg5x4n0009z44q663wfnwo" data-title="宝塔面板ApacheServer配置" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-vscode调试php" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/05/07/vscode%E8%B0%83%E8%AF%95php/" class="article-date">
  <time class="dt-published" datetime="2024-05-07T07:04:35.000Z" itemprop="datePublished">2024-05-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/05/07/vscode%E8%B0%83%E8%AF%95php/">vscode调试php</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><ul>
<li><p>已经安装apache、php（本地测试是用的宝塔面板批量安装的apache2.4以及php7.4)</p>
</li>
<li><p>已经安装vscode（测试安装的是vscode v1.87.0)</p>
</li>
<li><p>安装xdebug。vscode调试借助于xdebug，确保你的php已经安装了此插件，如果没有安装，可以去下载php_xdebug.dll，将其放入到php的ext目录。</p>
</li>
<li><p>vscode安装php debug插件（xdebug.org出品）</p>
</li>
</ul>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ul>
<li><p>在php中配置xdebug</p>
<p>​		打开php.ini文件，假如如下配置，注意端口配置项要和后面项目调试配置json文件中的端口保持一致；最后一行xdebug.remote_autostart&#x3D;1要加上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[XDebug]</span><br><span class="line"></span><br><span class="line">xdebug.profiler_append = 0</span><br><span class="line"></span><br><span class="line">xdebug.profiler_enable = 1</span><br><span class="line"></span><br><span class="line">xdebug.profiler_enable_trigger = 0</span><br><span class="line"></span><br><span class="line">xdebug.profiler_output_dir =&quot;D:\BtSoft\temp\xdebug&quot;</span><br><span class="line"></span><br><span class="line">xdebug.trace_output_dir =&quot;D:\BtSoft\temp\xdebug&quot;</span><br><span class="line"></span><br><span class="line">xdebug.profiler_output_name = &quot;cache.out.%t-%s&quot;</span><br><span class="line"></span><br><span class="line">xdebug.remote_enable = 1</span><br><span class="line"></span><br><span class="line">xdebug.remote_handler = &quot;dbgp&quot;</span><br><span class="line"></span><br><span class="line">xdebug.remote_host = &quot;127.0.0.1&quot;</span><br><span class="line"></span><br><span class="line">xdebug.remote_port = 9999</span><br><span class="line"></span><br><span class="line">zend_extension=php_xdebug.dll</span><br><span class="line"></span><br><span class="line">xdebug.remote_autostart = 1</span><br></pre></td></tr></table></figure>


</li>
<li><p>配置php项目</p>
<p>​	打开php项目，点击调试php，生成项目配置文件.vscode&#x2F;launch.json</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&quot;configurations&quot;: [</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      &quot;name&quot;: &quot;Listen for Xdebug&quot;,</span><br><span class="line"></span><br><span class="line">​      &quot;type&quot;: &quot;php&quot;,</span><br><span class="line"></span><br><span class="line">​      &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line"></span><br><span class="line">​      &quot;port&quot;: 9999,</span><br><span class="line"></span><br><span class="line">​      &quot;xdebugSettings&quot;: &#123;</span><br><span class="line"></span><br><span class="line">​        &quot;max_data&quot;: 10240</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​    &#125;,</span><br></pre></td></tr></table></figure>

<p>​		这里这里的port要和php.ini中配置xdebug的debug监听端口保持一致</p>
<p>​	</p>
<p>​	到此就可以愉快的断点、单步了！</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jerrywang2013.github.io/2024/05/07/vscode%E8%B0%83%E8%AF%95php/" data-id="clwbg5x4m0007z44q41aabiul" data-title="vscode调试php" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-libevent" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/05/05/libevent/" class="article-date">
  <time class="dt-published" datetime="2024-05-05T14:54:09.000Z" itemprop="datePublished">2024-05-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/05/05/libevent/">libevent</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>libevent是一个跨平台高效的异步网络库，支持各平台最高效的异步模型，例如epoll和iocp。</p>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><ul>
<li><p><strong>设置debug级别日志记录策略</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void event_enable_debug_logging(ev_uint32_t which)</span><br></pre></td></tr></table></figure>

<p>描述：</p>
<p>说明： which可为 EVENT_DBG_NONE 和 EVENT_DBG_ALL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define EVENT_DBG_NONE 0</span><br><span class="line"></span><br><span class="line">#define EVENT_DBG_ALL 0xffffffffu</span><br></pre></td></tr></table></figure>

<p>注意：设置为EVENT_DBG_NONE仍可用event_warn(“&#x3D;”);输出日志，因为此函数只控制debug级别的日志策略。</p>
</li>
<li><p><strong>设置自定义日志handler</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef void (*event_log_cb)(int severity, const char *msg);</span><br><span class="line">void event_set_log_callback(event_log_cb cb)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>设置自定义fatal日志handler</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef void (*event_fatal_cb)(int err);</span><br><span class="line">void event_set_fatal_callback(event_fatal_cb cb)</span><br></pre></td></tr></table></figure>

<p>说明：默认libevent检测到不可恢复的内部错误默认行为是调用abort()或者exit()结束当前的进场，你也可以自定义处理致命错误。</p>
</li>
</ul>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>自定义内存分配&#x2F;释放函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void event_set_mem_functions(void *(*malloc_fn)(size_t sz),</span><br><span class="line">                             void *(*realloc_fn)(void *ptr, size_t sz),</span><br><span class="line">                             void (*free_fn)(void *ptr));</span><br></pre></td></tr></table></figure>

<p>说明：比如可以自定义malloc等来实现更加安全的内存管理函数</p>
<h1 id="锁和线程"><a href="#锁和线程" class="headerlink" title="锁和线程"></a>锁和线程</h1><p>Libevent 结构通常可以通过三种方式处理多线程。</p>
<ul>
<li>有些结构本质上是单线程的：同时从多个线程使用它们永远是不安全的。</li>
<li>有些结构可以选择锁定：您可以告诉 Libevent 对于每个对象是否需要同时从多个线程使用它。</li>
<li>有些结构始终是锁定的：如果 Libevent 在锁定支持下运行，那么它们始终可以安全地同时从多个线程使用。</li>
</ul>
<p>​	可以使用windows thread和posix thread，在windows平台，也是可以选择默认的os thread或者pthread。另外还可以使用自定义的线程库，写好自己的内存管理以及同步函数后，需要注册之：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int evthread_set_lock_callbacks(const struct evthread_lock_callbacks *);</span><br><span class="line">void evthread_set_id_callback(unsigned long (*id_fn)(void));</span><br><span class="line">int evthread_set_condition_callbacks(const struct evthread_condition_callbacks *);</span><br></pre></td></tr></table></figure>

<p>​		上述的自定义线程库注册这种c的代码风格你可以理解为面向对象的的接口重写，比如IThread接口定义了create() &#x2F; destroy() &#x2F; lock() &#x2F; unlock()，自定义Thread库需要实现IThread的功能接口。</p>
<h1 id="Event使用"><a href="#Event使用" class="headerlink" title="Event使用"></a>Event使用</h1><h3 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h3><p>​	libevent的event代表一组条件，包括：</p>
<h3 id="事件标志"><a href="#事件标志" class="headerlink" title="事件标志"></a>事件标志</h3><ul>
<li><p>EV_TIMEOUT</p>
<p>​	构造事件的时候EV_TIMEOUT会被忽略，需要在event_add()中设置操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ev1 = event_new(base, 0, EV_TIMEOUT|EV_PERSIST, cb_func,(char*)&quot;Reading event&quot;);</span><br><span class="line">struct timeval tv;</span><br><span class="line">tv.tv_sec = 5;</span><br><span class="line">tv.tv_usec = 0;</span><br><span class="line">event_add(timeout_event, &amp;tv); </span><br></pre></td></tr></table></figure>

<p>相关函数或者宏：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">evtimer_assign(ev, b, cb, arg)</span><br><span class="line">evtimer_new(b, cb, arg)	</span><br><span class="line">evtimer_add(ev, tv)</span><br><span class="line">evtimer_del(ev)</span><br><span class="line">evtimer_pending(ev, tv)</span><br><span class="line">evtimer_initialized(ev)</span><br></pre></td></tr></table></figure>


</li>
<li><p>EV_READ</p>
</li>
<li><p>EV_WRITE</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE); </span><br><span class="line">bufferevent_setcb(bev, conn_readcb, conn_writecb, conn_eventcb, NULL);</span><br><span class="line">bufferevent_enable(bev, EV_READ | EV_WRITE);</span><br></pre></td></tr></table></figure>
</li>
<li><p>EV_SIGNAL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">signal_event = evsignal_new(base, SIGINT, signal_cb, (void *)base);</span><br><span class="line">event_add(signal_event, NULL)</span><br></pre></td></tr></table></figure>

<p>相关函数或者宏：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">evsignal_add(ev, tv)</span><br><span class="line">evsignal_assign(ev, b, x, cb, arg)</span><br><span class="line">evsignal_new(b, x, cb, arg)</span><br><span class="line">evsignal_del(ev)</span><br><span class="line">evsignal_pending(ev, tv)</span><br><span class="line">evsignal_initialized(ev)</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>​		对于大多数后端来说，每个进程只有一个event_base可以监听信号，如果同时向多个event_base添加信号事件，即便信号不同，也只有一个event_base会收到新招。kqueeue后端没有此限制。</p>
</li>
<li><p>用户触发事件</p>
<p>所谓的用户事件就是不与预定义那些事件关联，一般我们把event_new()参数的event参数设置为0即可。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct event_base *base = event_base_new(); </span><br><span class="line">struct event *user_event = event_new(base, -1, 0, user_event_cb, NULL); </span><br><span class="line">event_add(user_event, NULL); </span><br><span class="line">event_active(user_event, EV_WRITE, 0);  // 触发用户事件 </span><br><span class="line">event_base_dispatch(base);</span><br><span class="line">event_free(user_event);</span><br><span class="line">event_base_free(base); </span><br></pre></td></tr></table></figure>

<p>相关函数或者宏：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">evuser_new(b, cb, arg)</span><br><span class="line">evuser_del(ev)</span><br><span class="line">evuser_pending(ev, tv)</span><br><span class="line">evuser_initialized(ev)</span><br><span class="line">evuser_trigger(ev)	</span><br></pre></td></tr></table></figure>


</li>
<li><p>EV_PERSIST</p>
<p>​		通常情况下，当事件被激活后，它会被移除并在回调函数中处理。但是，如果事件被设置了 <code>EV_PERSIST</code> 标志，那么即使在回调函数中处理后，它仍然会留在事件循环中，并等待下一次相同类型的事件发生。使用 <code>EV_PERSIST</code> 标志的事件通常用于需要持续监听某种类型事件的场景，例如长期监听套接字的可读、可写事件等。</p>
</li>
</ul>
<h3 id="event-self-cbarg"><a href="#event-self-cbarg" class="headerlink" title="event_self_cbarg()"></a>event_self_cbarg()</h3><p>​		这个函数是libevent预定义的一个函数，用于返回一个magic指针，告诉event_new创建一个接受自己作为回调函数参数的event。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ev = event_new(base, -1, EV_PERSIST, cb_func, event_self_cbarg());</span><br></pre></td></tr></table></figure>

<p>此函数创建一个event，并且让事件触发的时候执行cb_func()时，将ev参数传给cb_func()。因为调用者调用event_new()时对象还不存在，这里用event_self_cbarg()原理也很简单，相当于给传一个flag告知event_new()。</p>
<h3 id="事件待处理-非待处理"><a href="#事件待处理-非待处理" class="headerlink" title="事件待处理&#x2F;非待处理"></a>事件待处理&#x2F;非待处理</h3><p>​		事件被创建后，不会执行任何操作，直到你通过event_add()将其处于挂起状态。</p>
<ul>
<li><p>event_add</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int event_add(struct event *ev, const struct timeval *tv);</span><br></pre></td></tr></table></figure>

<p>​		对于已挂起的事件调用event_add()，会将其保持挂起状态，并使用提供的超时重新设置。如果事件已经挂起，然后使用超时NULL重新设置它，则event_add()不起作用。</p>
</li>
<li><p>event_del</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int event_del(struct event *ev);</span><br></pre></td></tr></table></figure>

<p>​		event_del会使得事件变为非挂起 、非活动状态。如果event本来是非挂起非激活状态，调用event_del没有效果。</p>
</li>
<li><p>event_remove_timer</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int event_remove_timer(struct event *ev);</span><br></pre></td></tr></table></figure>

<p>​		删除挂起事件的超时，而无需删除事件的IO或者信号组件。如果event没有超时挂起，则event_remove_timer()无效。如果event只有超时但没有IO或者信号组件，则event_remove_timer()和event_del()效果一样。</p>
</li>
</ul>
<h3 id="event优先级"><a href="#event优先级" class="headerlink" title="event优先级"></a>event优先级</h3><ul>
<li><p>event_priority_set</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int event_priority_set(struct event *event, int priority);</span><br></pre></td></tr></table></figure>

<p>​		priority是0-1的数字。当多个事件变为活动状态时，低优先级的不会运行。libevent会运行高优先级事件，然后再次检测事件，只有没有高优先级事件处于活动状态时，低优先级事件才会运行。</p>
</li>
</ul>
<h3 id="检测事件状态"><a href="#检测事件状态" class="headerlink" title="检测事件状态"></a>检测事件状态</h3><ul>
<li><p>常用接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int event_pending(const struct event *ev, short what, struct timeval *tv_out);</span><br><span class="line"></span><br><span class="line">#define event_get_signal(ev) /* ... */</span><br><span class="line">evutil_socket_t event_get_fd(const struct event *ev);</span><br><span class="line">struct event_base *event_get_base(const struct event *ev);</span><br><span class="line">short event_get_events(const struct event *ev);</span><br><span class="line">event_callback_fn event_get_callback(const struct event *ev);</span><br><span class="line">void *event_get_callback_arg(const struct event *ev);</span><br><span class="line">int event_get_priority(const struct event *ev);</span><br><span class="line"></span><br><span class="line">void event_get_assignment(const struct event *event,</span><br><span class="line">        struct event_base **base_out,</span><br><span class="line">        evutil_socket_t *fd_out,</span><br><span class="line">        short *events_out,</span><br><span class="line">        event_callback_fn *callback_out,</span><br><span class="line">        void **arg_out);</span><br><span class="line">struct event *event_base_get_running_event(struct event_base *base);</span><br></pre></td></tr></table></figure>

<p>event_pending()： 判断event是待处理还是活动的。</p>
<p>event_get_fd()&#x2F;event_get_signal()： 返回event的描述符或者信号</p>
<p>event_get_base(): 返回event的event_base</p>
<p>event_get_events(): 返回event的时间标记(EV_READ&#x2F;EV_WRITE等)</p>
<p>event_get_callback(): 返回callback函数</p>
<p>event_get_callback_arg(): 返回回调函数参数指针</p>
<p>event_get_priority(): 返回event优先级</p>
<p>event_base_get_running_event(): 获得指向当前正在运行的event指针</p>
</li>
</ul>
<h3 id="配置一次性事件"><a href="#配置一次性事件" class="headerlink" title="配置一次性事件"></a>配置一次性事件</h3><ul>
<li><p>event_base_once()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int event_base_once(struct event_base *, evutil_socket_t, short,</span><br><span class="line">  void (*)(evutil_socket_t, short, void *), void *, const struct timeval *);</span><br></pre></td></tr></table></figure>

<p>​		参数和event_new()类似，只不过它不支持EV_SIGNAL和EV_PERSIST。在回调完成后，libevent会释放event结构。event_base_once()插入的事件无法删除或者手动激活；如果想取消event，只能使用常规的event_new()或者event_assign()创建。</p>
</li>
</ul>
<h3 id="手动激活"><a href="#手动激活" class="headerlink" title="手动激活"></a>手动激活</h3><ul>
<li><p>event_active</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void event_active(struct event *ev, int what, short ncalls);</span><br></pre></td></tr></table></figure>

<p>​		手动激活的事件不需要先处于挂起状态，并且激活它也不会使其处于挂起状态。</p>
</li>
</ul>
<h3 id="定时器事件优化"><a href="#定时器事件优化" class="headerlink" title="定时器事件优化"></a>定时器事件优化</h3><p><strong>公共超时</strong></p>
<p>​		Libevent 使用二进制堆算法来跟踪待处理事件的超时。二叉堆为添加和删除每个事件超时提供了 O(lg n) 阶的性能。如果您要添加具有随机分布的超时值集的事件，则这是最佳选择，但如果您有大量具有相同超时值的事件，则这不是最佳选择。</p>
<p>例如，假设您有一万个事件，每个事件都应在添加后五秒触发超时。在这种情况下，通过使用双链接队列实现，您可以在每次超时时获得 O(1) 性能。</p>
<p>当然，您不会希望对所有超时值使用队列，因为队列仅对于恒定超时值更快。如果某些超时或多或少是随机分布的，那么将其中一个超时添加到队列将花费 O(n) 时间，这比二进制堆要糟糕得多。</p>
<p>Libevent 可以让您通过将一些超时放入队列中，将其他超时放入二进制堆中来解决此问题。为此，您需要向 Libevent 请求一个特殊的“公共超时”时间值，然后使用该时间值添加具有该时间值的事件。如果您有大量具有单个公共超时的事件，则使用此优化应该可以提高超时性能。</p>
<ul>
<li><strong>TODO 这块得研究一下</strong></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jerrywang2013.github.io/2024/05/05/libevent/" data-id="clwbg5x4m0006z44qf23gch0w" data-title="libevent" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-windows网络编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/05/01/windows%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2024-05-01T09:42:08.000Z" itemprop="datePublished">2024-05-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/05/01/windows%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">windows网络编程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="网络常见知识"><a href="#网络常见知识" class="headerlink" title="网络常见知识"></a>网络常见知识</h1><ul>
<li><h2 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h2><p>​	一般用于指示多字节数据存储方式。</p>
<ul>
<li><p>​	<strong>大端（Little Endian)：</strong> 高位字节（MSB）存储在起始地址，低位字节（LSB）存储在结束地址。换句话说：数据的高位存储在内存的低地址处，低位字节存储在高地址处。</p>
</li>
<li><p>​	<strong>小端（Little Endian)：</strong> 和大端相反。</p>
<p>举例：假设一个32位整数<code>num</code>，其十六进制表示为 **<code>0x12345678</code>**，在内存中存储如下：</p>
<p><strong>大端字节序</strong>：存储方式为<code>**12 34 56 78**</code></p>
<p><strong>小端字节序：</strong>存储方式为<code>**78 56 34 12**</code></p>
</li>
</ul>
</li>
</ul>
<h1 id="重要函数"><a href="#重要函数" class="headerlink" title="重要函数"></a>重要函数</h1><ul>
<li><p><strong>WSAGetLastError</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">WSAGetLastError</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p><strong>描述：</strong>获取WinSocket函数调用的错误码</p>
<p><strong>说明：</strong>WinSocket错误码定义在winsocket2.h文件中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define WSABASEERR              10000</span><br></pre></td></tr></table></figure>

<p>​		错误码基础偏移是WSABASEERR，通过WSAGetLastError()获取到的错误码可以直接通过VS自带的错误查找工具查找对应错误码的信息。</p>
</li>
<li><p><strong>WSAStartup</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">WSAStartup</span><span class="params">(wVersion,  &amp;wsadata)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>描述：</strong>初始化WinSocket库</p>
<p><strong>说明：</strong></p>
<p>​		应作为Socket库首个函数被调用。wVersion指定winsocket库版本。此函数直接返回错误码（0表示正常），无需额外调用WSAGetLastError()获取错误码。</p>
</li>
<li><p><strong>WSACleanup</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">WSACleanup</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p><strong>描述：</strong>终于使用Winsock2 DLL(ws2_32.dll)</p>
<p><strong>返回值：</strong>成功返回0，否则返回SOCKET_ERROR</p>
<p><strong>说明：</strong></p>
<p>​		失败时可以调用WSAGetLastError获取错误码。在多线程环境下，WSACleanup调用会终止所有线程的Windows套接字操作。</p>
</li>
<li><p><strong>socket</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SOCKET <span class="title">socket</span><span class="params">(<span class="type">int</span> af, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>描述：</strong>创建套接字**</p>
<p><strong>返回值：</strong></p>
<p>​		如果没有错误会返回新创建的套接字描述符（整数），否则返回INVALID_SOCKET，并且可以调用WSAGetLastError()获取错误。</p>
<p><strong>说明：</strong></p>
<p>​	af： 地址家族，常见的有<strong>AF_INET</strong>（IPV4）、 <strong>AF_INET6</strong>（IPV6）</p>
<p>​	type: 套接字类型，常见有<strong>SOCK_STREAM</strong>、<strong>SOCK_DGRAM</strong>、<strong>SOCK_RAW</strong>(原始套接字)</p>
<p>​	protocol：协议，常见有<strong>IPPROTO_TCP</strong>、**IPPROTO_UDP</p>
</li>
<li><p><strong>bind</strong> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(SOCKET s, <span class="type">const</span> sockaddr *addr, <span class="type">int</span> namelen)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>描述：</strong>socket绑定地址</p>
<p><strong>返回值：</strong>如果没有错误，返回0；否则返回SOCKET_ERROR；</p>
<p><strong>说明：</strong></p>
<ul>
<li><p>如果不指定IP，可以使用INADDR_ANY（IPV4）或者in6addr_any（IPV6）</p>
</li>
<li><p>如果指定端口为0，则自动选择一个可用的动态端口（vista之后系统动态端口区间49152 - 65535）。</p>
</li>
<li><p>注意sockaddr结构会根据所选协议不同而不同的。比如IPV4，我们使用的是sockaddr_in； IPV6我们使用的是sockaddr_in6</p>
</li>
<li><p>bind之后可以用getsockname来获取分配给套接字的地址和端口。如果指定绑定IP是INADDR_ANY，则在连接建立之前getsockname不一定提供地址，因为如果主机是多宿主，可能有多个地址。客户端程序一般指定port为0避免端口冲突。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// bind  and listen</span><br><span class="line">SOCKADDR_IN serverAddr;</span><br><span class="line">serverAddr.sin_family = AF_INET;</span><br><span class="line">serverAddr.sin_addr.S_un.S_addr = htonl(INADDR_ANY);</span><br><span class="line">serverAddr.sin_port = htons(8889);</span><br><span class="line">ret = bind(listen_socket, (const sockaddr*)&amp;serverAddr, sizeof(serverAddr));</span><br><span class="line">if (SOCKET_ERROR == ret) &#123;</span><br><span class="line">	Helper::log(&quot;bind listen socket failed with error:%d\n&quot;, WSAGetLastError());</span><br><span class="line">	closesocket(listen_socket);</span><br><span class="line">	WSACleanup();</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">SOCKADDR_IN bind_addr;</span><br><span class="line">int bind_addr_len = sizeof(bind_addr);</span><br><span class="line">ret = getsockname(listen_socket, (sockaddr*)&amp;bind_addr, &amp;bind_addr_len);</span><br><span class="line">if (SOCKET_ERROR == ret) &#123;</span><br><span class="line">	Helper::log(&quot;get listen socket bind addr failed with error:%d\n&quot;, WSAGetLastError());</span><br><span class="line">	closesocket(listen_socket);</span><br><span class="line">	WSACleanup();</span><br><span class="line">	return false;</span><br><span class="line"></span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>listen</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int listen(SOCKET s, int backlog)</span><br></pre></td></tr></table></figure>

<p><strong>描述：</strong>将套接字设置为监听模式。</p>
<p><strong>返回值：</strong>成功返回0，失败返回SOCKET_ERROR。</p>
<p><strong>说明：</strong></p>
<p>​		backlog是后台等待连接队列。将套接字设置为监听模式后，os会维护等待连接队列，这个参数指定了此队列长度。当有客户尝试连接时，如果等待连接队列已满，则客户端可能收到连接被拒绝的错误。</p>
<p>​		距离说明如果设置了backlog为2，有两个客户端连接服务器，服务器暂时还没有处理客户端的连接（就是没有accept），如果这时候再来第三个客户端连接就会出现连接被拒绝。</p>
<p>​		</p>
</li>
<li><p><strong>accept</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SOCKET accept(SOCKET s, sockaddr *addr, int *addrlen)</span><br></pre></td></tr></table></figure>

<p><strong>描述：</strong>在套接字上进行连接操作</p>
<p><strong>返回值</strong>：如果没有错误，返回新建连接的SOCKET；否则返回INVALID_SOCKET。</p>
<p><strong>说明：</strong></p>
<ul>
<li><p>accept会一直阻塞直到有客户连接的到来；</p>
</li>
<li><p>addr返回的是新建连接的客户地址信息，可以用inet_ntop将IPV4&#x2F;6的网络地址(sockaddr.sin_addr)转为internet标准格式字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char ipstr[INET_ADDRSTRLEN] = &#123; 0 &#125;;</span><br><span class="line">inet_ntop(AF_INET, &amp;(clientAddr.sin_addr), ipstr, sizeof(ipstr));</span><br><span class="line">WORD port = ntohs(clientAddr.sin_port);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>send</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int send(SOCKET s, const char *buf, int len, int flags)</span><br></pre></td></tr></table></figure>

<p><strong>描述：</strong>在建立连接的套接字上发送数据</p>
<p><strong>返回值：</strong>如果没有错误，返回发送的总字节数，字节数可能小于请求发送的长度(len)；否则返回SOCKET_ERROR。</p>
<p><strong>说明：</strong></p>
<ul>
<li>发送函数成功完成并不表示数据传递并接收给，只是指示待发送数据已经成功写入套接字的发送缓冲区。</li>
<li>如果发送缓冲区没有空间，此函数会block；如果是非阻塞套接字，那么send会立刻返回，写入字节数取决于缓冲区可用性。</li>
<li>数据成功写入缓冲区后，操作系统会负责将数据通过网络发送给目标主机。</li>
</ul>
</li>
<li><p><strong>recv</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int recv(SOCKET s, char *buf, int len, int flags)</span><br></pre></td></tr></table></figure>

<p><strong>描述：</strong>从套接字上接收数据</p>
<p><strong>返回值：</strong>成功返回接收的字节数；失败返回SOCKET_ERROR。</p>
<p><strong>说明：</strong></p>
<ul>
<li><p>当套接字接收缓冲区没有数据的时候，recv调用会阻塞</p>
</li>
<li><p>当套接字接收缓冲区有数据的时候，recv会尝试将套接字缓冲区的内容拷贝到recv定义的用户缓冲区中，实际接收的数据和用户缓冲区buf大小以及套接字接收缓冲区数据的长度有关。</p>
</li>
<li><p>阻塞模式下，recv返回0意味着对方调用了closesocket或者shutdown关闭了连接。</p>
</li>
</ul>
</li>
<li><p><strong>shutdown</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int shutdown(SOCKET s, int how)</span><br></pre></td></tr></table></figure>

<p><strong>描述：</strong>关闭套接字的发送和接收</p>
<p><strong>返回值：</strong>成功返回0，失败返回SOCKET_ERROR</p>
<p><strong>说明：</strong></p>
<ul>
<li>how可选 SD_SEND | SD_RECEIVE | SD_BOTH</li>
<li>shutdown是关闭套接字功能；closesocket是关闭套接字功能，清理套接字资源</li>
</ul>
</li>
<li><p><strong>closesocket</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int closesocket(SOCKET s)</span><br></pre></td></tr></table></figure>

<p><strong>描述：</strong>关闭套接字</p>
<p><strong>返回值：</strong>成功返回0，失败返回SOCKET_ERROR</p>
<p><strong>说明：</strong></p>
<ul>
<li>可以结合linger选项来控制closesocket后的套接字接收发送行为</li>
</ul>
</li>
<li><p><strong>select</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const timeval *timeout)</span><br></pre></td></tr></table></figure>

<p><strong>描述：</strong>确定套接字状态，并在必要时等待执行同步IO</p>
<p>返回值：成功返回fd_set中已就绪的套接字数量；如果超时时间到，返回0；如果有错误，返回SOCKET_ERROR。</p>
<p><strong>说明：</strong></p>
<ul>
<li><p>nfds 参数已忽略。</p>
</li>
<li><p>如果用select查询套接字状态，需要将套接字设置为非阻塞。利用ioctlsocket设置套接字的IO模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unsigned long nonBlocking = 1;</span><br><span class="line"></span><br><span class="line">ioctlsocket(pSockInfo-&gt;sock, FIONBIO, &amp;nonBlocking)</span><br></pre></td></tr></table></figure>

<p>注意，WSAEventSelect和WSAAsyncSelect函数会自动将socket设置为NonBlock模式，无需手动设置。</p>
</li>
<li><p>放大</p>
</li>
</ul>
</li>
<li></li>
</ul>
<h1 id="套接字模式"><a href="#套接字模式" class="headerlink" title="套接字模式"></a>套接字模式</h1><ul>
<li><p>同步模式</p>
<p>​	默认行为，套接字的读写(包括accept)都是阻塞式的。</p>
</li>
<li><p>异步模式</p>
<p>​	套接字读写都是非阻塞的，可以通过ioctlsocket设置套接字为非阻塞。</p>
</li>
</ul>
<h1 id="常见IO模型"><a href="#常见IO模型" class="headerlink" title="常见IO模型"></a>常见IO模型</h1><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>​		类似unix的select模型，注意，windows下select最多支持64个套接字。可以使用WSAPoll。</p>
<h3 id="WSAAsyncSelect"><a href="#WSAAsyncSelect" class="headerlink" title="WSAAsyncSelect"></a>WSAAsyncSelect</h3><p>​		和select不同，他不是同步等待，是基于windows消息来通知socket的变化，换句话说，需要windows窗口和消息循环。另外，使用了WSAAsyncSelect会自动将套接字设置为非阻塞。</p>
<h3 id="WSAEventSelect"><a href="#WSAEventSelect" class="headerlink" title="WSAEventSelect"></a>WSAEventSelect</h3><p>​		和WSAAsyncSelect类似，不过是基于事件来异步通知套接字状态的变化，使用了WSAAsyncSelect会自动将套接字设置为非阻塞。他是基于windows事件，不需要windows窗口。</p>
<h3 id="WSAPoll"><a href="#WSAPoll" class="headerlink" title="WSAPoll"></a>WSAPoll</h3><p>​		类似select的轮询方式，没有套接字数量限制。</p>
<h3 id="重叠模型"><a href="#重叠模型" class="headerlink" title="重叠模型"></a>重叠模型</h3><h3 id="IOCP"><a href="#IOCP" class="headerlink" title="IOCP"></a>IOCP</h3><p>​		windows下高性能高并发量常用的模型，通过将套接字与完成端口关联来完成高性能异步操作。IOCP提供了一种高性能方式处理大并发量的异步操作，它是一种基于事件驱动的模型，基于事件通知机制来实现异步操作结束的通知。通过IOCP，避免了传统的同步和select的轮询，提高性能。</p>
<ul>
<li><p>使用流程</p>
<ul>
<li><strong>创建端口</strong>：首先，需要创建一个 I&#x2F;O 完成端口对象（IOCP 对象），通过调用 <code>CreateIoCompletionPort()</code> 函数来完成。</li>
<li><strong>关联套接字</strong>：然后，将需要进行异步 I&#x2F;O 操作的套接字句柄与创建的 IOCP 对象关联起来，可以关联一个或多个套接字。这通常通过调用 <code>CreateIoCompletionPort()</code> 函数来实现。</li>
<li><strong>发起异步操作</strong>：一旦套接字与 IOCP 关联成功，就可以通过调用异步 I&#x2F;O 函数（如 <code>WSASend()</code>、<code>WSARecv()</code>）来发起异步 I&#x2F;O 操作。在调用这些函数时，需要传递一个与操作相关的 <code>OVERLAPPED</code> 结构体，用于接收完成通知。</li>
<li><strong>处理完成通知</strong>：当异步 I&#x2F;O 操作完成时，系统会将完成结果通知到关联的 IOCP 对象上。应用程序可以通过调用 <code>GetQueuedCompletionStatus()</code> 函数来获取完成的 I&#x2F;O 操作，并进行相应的处理。</li>
</ul>
</li>
<li><p>简单流程分析</p>
<ul>
<li>通过CreateIoCompletionPort()创建IOCP对象，这个IOCP对象就充当了事件队列的管理者，负责管理所有与该IOCP相关的IO操作；</li>
<li>对某个IO（这里我们值得是套接字）对象上进行异步IO操作之前，我们需要将此IO对象与前面创建的IOCP关联起来，关联之后，此对象的完成事件就会被通知到该IOCO对象；</li>
<li>在IO对象上执行异步操作（WSASend &#x2F; WSAReceive，包括ReadFileEx &#x2F; WriteFileEx等），这些操作都会立即返回，不会阻塞当前线程；</li>
<li>当一个异步IO操作在后台完成时，系统会将对应的完成事件放入到IOCP对象的事件队列中，这个完成事件包含了操作相关的信息，包括操作类型和结果等；</li>
<li>应用程序的一个或多个线程调用GetQueuedCompletionStatus函数等待并处理事件队列中的完成事件，这些线程我们通常称之为完成端口线程。一旦某个完成事件进入队列，一个完成端口线程就会被唤醒；</li>
<li>当完成端口被唤醒，我们可以根据完成事件的信息来处理，比如某个异步Read操作完成，我们可以获取读取的内容往上派发给上层进行处理，同时，我们可以通过投递一个新的异步Read操作用于继续读取内容（等待新数据的到来）；</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jerrywang2013.github.io/2024/05/01/windows%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" data-id="clwbg5x4m0008z44qb6jc0x1a" data-title="windows网络编程" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Hexo-简介" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/30/Hexo-%E7%AE%80%E4%BB%8B/" class="article-date">
  <time class="dt-published" datetime="2024-04-30T12:37:16.000Z" itemprop="datePublished">2024-04-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/30/Hexo-%E7%AE%80%E4%BB%8B/">在Github上部署Hexo</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>简述</strong>：用Hexo本地创建Blog，然后将博客部署到Github上</p>
<ul>
<li><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h2><h3 id="安装git和npm"><a href="#安装git和npm" class="headerlink" title="安装git和npm"></a>安装git和npm</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">此部分省略</span><br></pre></td></tr></table></figure>



<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>



<h3 id="进阶安装和使用"><a href="#进阶安装和使用" class="headerlink" title="进阶安装和使用"></a>进阶安装和使用</h3><p>​	局部安装hexo包 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo</span><br></pre></td></tr></table></figure>

<p>​	然后可以使用hexo 命令</p>
</li>
<li><h3 id="创建Hexo项目"><a href="#创建Hexo项目" class="headerlink" title="创建Hexo项目"></a><strong>创建Hexo项目</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line"></span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line"></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="创建SSH-Key"><a href="#创建SSH-Key" class="headerlink" title="创建SSH Key"></a>创建SSH Key</h1><ul>
<li><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t ras -C &quot;yourmail@xxx.com&quot;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>邮箱地址是你github账号关联的邮箱，配置的目的是将github仓库和本地机器连起来，这样可以将文件提交到仓库，不需要账号密码。进入github的对应仓库，点击‘setting’进入设置，点击“SSH and GPG key”，点击”New SSH Key”, 将前面生成的c:&#x2F;users&#x2F;用户名&#x2F;.ssh&#x2F;目录下的id_ras.pub内容	复制过去，title 随便取，点击保存，至此本地与github之间连接就配置好了。</p>
<p><strong>测试：</strong>   	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行命令：ssh -T git@github.com</span><br></pre></td></tr></table></figure>


</li>
<li><h1 id="配置git账号邮箱"><a href="#配置git账号邮箱" class="headerlink" title="配置git账号邮箱"></a>配置git账号邮箱</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;github账号&quot;</span><br><span class="line"></span><br><span class="line">git config --global user.email &quot;github账号关联的邮箱&quot;</span><br></pre></td></tr></table></figure>


</li>
<li><h1 id="创建github仓库目录"><a href="#创建github仓库目录" class="headerlink" title="创建github仓库目录"></a>创建github仓库目录</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># mkdir myblob</span><br><span class="line"></span><br><span class="line"># 	git clone xxxxx.git</span><br></pre></td></tr></table></figure>


</li>
<li><h2 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd myblob</span><br><span class="line"></span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure>


</li>
<li><h2 id="查看初始文件"><a href="#查看初始文件" class="headerlink" title="查看初始文件"></a>查看初始文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>


</li>
<li><h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>  服务会监听本地4000端口，可以访问<a target="_blank" rel="noopener" href="http://localhost:4000/">http://localhost:4000</a></p>
</li>
</ul>
<h1 id="上传blog到github"><a href="#上传blog到github" class="headerlink" title="上传blog到github"></a>上传blog到github</h1><ul>
<li><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><h2 id="修改根目录下的-config-yml中的deploy部分："><a href="#修改根目录下的-config-yml中的deploy部分：" class="headerlink" title="修改根目录下的_config.yml中的deploy部分："></a>修改根目录下的_config.yml中的deploy部分：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line"></span><br><span class="line"> type: git</span><br><span class="line"></span><br><span class="line"> repository: https://github.com/Jerrywang2013/Jerrywang2013.github.io.git</span><br><span class="line"></span><br><span class="line"> branch: main</span><br></pre></td></tr></table></figure>


</li>
<li><h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>


</li>
<li><h2 id="部署-提交"><a href="#部署-提交" class="headerlink" title="部署(提交)"></a>部署(提交)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo deplot</span><br></pre></td></tr></table></figure>

<p><strong>备注</strong>：如果出现 ERROR Deployer not found: git w，请安装hexo部署插件： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-gi</span><br></pre></td></tr></table></figure>


</li>
<li><h2 id="访问博客"><a href="#访问博客" class="headerlink" title="访问博客"></a>访问博客</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">浏览： &lt;Github用户名&gt;.github.io</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="hexo使用"><a href="#hexo使用" class="headerlink" title="hexo使用"></a>hexo使用</h1><ul>
<li><h2 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-theme-volantis</span><br></pre></td></tr></table></figure>


</li>
<li><h2 id="添加文章"><a href="#添加文章" class="headerlink" title="添加文章"></a>添加文章</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new 英语测试</span><br></pre></td></tr></table></figure>



<h2 id="编辑文章"><a href="#编辑文章" class="headerlink" title="编辑文章"></a>编辑文章</h2><p>进入source__posts\英语测试.md 下编写具体内容即可</p>
</li>
<li><h2 id="生成文件"><a href="#生成文件" class="headerlink" title="生成文件"></a>生成文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate | hexo g</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><h2 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server | hexo s</span><br></pre></td></tr></table></figure>

<p>可选参数</p>
<p>​        -p –port 监听端口</p>
<p>​        -s –static 只使用静态文件</p>
<p>​        -l –log 启动日记记录，使用覆盖记录格式</p>
</li>
<li><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy | hexo d</span><br></pre></td></tr></table></figure>

<p>​	-g –generate 部署之前预先生成静态文件</p>
</li>
<li><h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo render &lt;file1&gt; &lt;file2&gt;...</span><br></pre></td></tr></table></figure>

<p>​	 -o –output 设置输出路径</p>
</li>
<li><h2 id="清除缓存"><a href="#清除缓存" class="headerlink" title="清除缓存"></a>清除缓存</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>

<p>​	清除缓存文件(db.json)和已生成的静态文件(public)</p>
<p>​	在某些情况下（更换主题后）如果发现对站点的更改无论如何也不生效，可以尝试此命令。</p>
</li>
<li><h2 id="列出网站数据"><a href="#列出网站数据" class="headerlink" title="列出网站数据"></a>列出网站数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo list &lt;type&gt;</span><br></pre></td></tr></table></figure>


</li>
<li><h2 id="显示版本"><a href="#显示版本" class="headerlink" title="显示版本"></a>显示版本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo version</span><br></pre></td></tr></table></figure>


</li>
<li><h2 id="列出网站配置"><a href="#列出网站配置" class="headerlink" title="列出网站配置"></a>列出网站配置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo config [key] [value]</span><br></pre></td></tr></table></figure>

<p>​	列出网站的配置(_config.yml)，如果指定了key，则只展示对应key的值，如果同时指定key和value，则将此key值修改为value。</p>
</li>
<li><h2 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo --debug</span><br></pre></td></tr></table></figure>


</li>
<li><h2 id="简洁模式"><a href="#简洁模式" class="headerlink" title="简洁模式"></a>简洁模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo --silent</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><strong>markdown基本语法</strong><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/nickchen121/p/10821946.html">https://www.cnblogs.com/nickchen121/p/10821946.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jerrywang2013.github.io/2024/04/30/Hexo-%E7%AE%80%E4%BB%8B/" data-id="clwbg5x4f0000z44qdvc2c6i5" data-title="在Github上部署Hexo" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-ThinkPHP之DB-Query" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/27/ThinkPHP%E4%B9%8BDB-Query/" class="article-date">
  <time class="dt-published" datetime="2024-04-27T09:16:13.000Z" itemprop="datePublished">2024-04-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/27/ThinkPHP%E4%B9%8BDB-Query/">ThinkPHP之DB::Query</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Query是ThinkPHP数据库操作的一个非常重要的类，大部分查询相关的操作功能都是通过此类来实现的，本文主要记录ThinkPHP5.0 Query类的部分重要函数。</p>
<h1 id="Query文件路径"><a href="#Query文件路径" class="headerlink" title="Query文件路径"></a>Query文件路径</h1><p><code>thinkphp\library\think\db\Query.php</code></p>
<h1 id="重要函数"><a href="#重要函数" class="headerlink" title="重要函数"></a>重要函数</h1><ul>
<li><strong>Query::table</strong><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定当前操作的数据表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@access</span> public</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mixed $table 表名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> $this</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">table</span>(<span class="params"><span class="variable">$table</span></span>)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>描述：</strong>设置当前操作的表，内部主要设置options的table属性：$this-&gt;options[‘table’] &#x3D; $table;</p>
<p><strong>范例：</strong>Db::table(‘fa_admin’)-&gt;where(“id”, 1)-&gt;find();</p>
<ul>
<li><strong>Query::name</strong><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定默认的数据表名（不含前缀）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@access</span> public</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> $this</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params"><span class="variable">$name</span></span>)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>描述</strong>：设置当前操作的表，和Query::table函数不同的是$name是不带前缀(前缀配置dbconfig[‘prefix’])的表名。</p>
<p><strong>范例</strong>：**Db::name(‘admin’)-&gt;where(“id”, 1)-&gt;find();</p>
<p><strong>备注:</strong> 也可以用helper函数db(“admin”)来获取dbconnection对象，例如：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">db</span>(<span class="string">&quot;admin&quot;</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>)-&gt;<span class="title function_ invoke__">find</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Query::value</strong><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 得到某个字段的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@access</span> public</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $field   字段名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mixed  $default 默认值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bool   $force   强制转为数字类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> mixed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">value</span>(<span class="params"><span class="variable">$field</span>, <span class="variable">$default</span> = <span class="literal">null</span>, <span class="variable">$force</span> = <span class="literal">false</span></span>)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>描述：</strong>查询符合条件的某个记录的某个字段的值，注意只查询一条记录(limit(1))</p>
<p><strong>范例：</strong> Db::table(‘fa_admin’)-&gt;where(“id”, 1)-&gt;value(“uername”);</p>
<ul>
<li><p><strong>Query::column</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 得到某个列的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@access</span> public</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $field 字段名 多个字段用逗号分隔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $key   索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">column</span>(<span class="params"><span class="variable">$field</span>, <span class="variable">$key</span> = <span class="string">&#x27;&#x27;</span></span>)</span></span><br></pre></td></tr></table></figure>
<p><strong>描述：</strong>指定符合条件记录的指定字段<br><strong>范例：</strong> Db::table(‘fa_admin’)-&gt;column(“nickname, id, nickname, username”);<br><strong>备注：</strong> $field是以逗号分隔的字段名字符串，形如”field1, field2…”。<br>column()函数会将$field去重；其次如果指定了$key，则以$key为返回记录的key；否则以$field字符串中第一个字段作为key</p>
</li>
<li><p><strong>Query::find</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找单条记录</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@access</span> public</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array|string|Query|\Closure $data</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> array|false|\PDOStatement|string|Model</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> DbException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ModelNotFoundException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> DataNotFoundException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params"><span class="variable">$data</span> = <span class="literal">null</span></span>)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>描述：</strong>查找单挑记录，返回的是</p>
<p><strong>范例：</strong> Db::name(‘admin’)-&gt;where(“id”, 1)-&gt;find();</p>
<ul>
<li><strong>Query::chunk</strong><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分批数据返回处理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@access</span> public</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> integer  $count    每次处理的数据数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> callable $callback 处理回调方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string   $column   分批处理的字段名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string   $order    排序规则</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> \LogicException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">chunk</span>(<span class="params"><span class="variable">$count</span>, <span class="variable">$callback</span>, <span class="variable">$column</span> = <span class="literal">null</span>, <span class="variable">$order</span> = <span class="string">&#x27;asc&#x27;</span></span>)</span></span><br></pre></td></tr></table></figure>
<strong>描述：</strong>分批处理数据<br><strong>范例：</strong></li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;think_user&#x27;</span>)-&gt;<span class="title function_ invoke__">chunk</span>(<span class="number">100</span>, function(<span class="variable">$users</span>) <span class="keyword">use</span>(&amp;$<span class="title">outer</span>) &#123;</span><br><span class="line">    <span class="title">foreach</span> ($<span class="title">users</span> <span class="keyword">as</span> $<span class="title">user</span>) &#123;</span><br><span class="line">        // 处理结果集...</span><br><span class="line">        <span class="title">if</span>($<span class="title">user</span>-&gt;<span class="title">status</span>==0)&#123;</span><br><span class="line">            <span class="title">return</span> <span class="title">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong> </p>
<ol>
<li>可以通过callback函数return false终止后续数据集的处理。这里，这里我们使用use将外部变量$outer传递给<br>   匿名函数，php中变量按照值传递，而不是引用，所以匿名函数内部的修改不会影响到外部$outer变量。这里我们如果想在<br>   匿名函数内部修改$outer，需要用**&amp;$outer**。</li>
<li>一般用于命令行处理db数据，不适合web访问处理大量数据，容易造成超时。</li>
</ol>
<ul>
<li><strong>Query::where</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 指定AND查询条件</span><br><span class="line"> * @access public</span><br><span class="line"> * @param mixed $field     查询字段</span><br><span class="line"> * @param mixed $op        查询表达式</span><br><span class="line"> * @param mixed $condition 查询条件</span><br><span class="line"> * @return $this</span><br><span class="line"> */</span><br><span class="line">public function where($field, $op = null, $condition = null)</span><br><span class="line">&#123;</span><br><span class="line">    $param = func_get_args();</span><br><span class="line">    array_shift($param);</span><br><span class="line">    $this-&gt;parseWhereExp(&#x27;AND&#x27;, $field, $op, $condition, $param);</span><br><span class="line">    return $this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>描述：</strong>设置AND查询条件，使用形式：where(‘字段名’, ‘表达式’, ‘查询条件’)<br><strong>表达式：</strong><br>  <strong>数值关系比较：</strong> &#x3D; | &lt;&gt; | &gt; | &gt;&#x3D; | &lt; | &lt;&#x3D;</li>
</ul>
<p>​	<strong>时间：</strong> &gt; TIME | &lt; TIME | &gt;&#x3D; TIME | &lt;&#x3D; TIME </p>
<p>​        <strong>其它：</strong> [NOT] LIKE | [NOT] BETWEEN | [NOT] IN | [NOT] NULL | [NOT] EXISTS | [NOT] REGEXP | [NOT] BETWEEN TIME </p>
<p>​	<strong>EXP：</strong> exp表达式</p>
<p><strong>范例：</strong></p>
<ul>
<li><p><strong>[NOT] LIKE</strong> 字符串模糊查询，<strong>支持数组</strong></p>
<p><strong>示例：</strong>where(‘name’, ‘like’, ‘%ab%’) | where(‘name’, ‘like’, [‘%ab’, ‘php%’]) </p>
</li>
<li><p><strong>[NOT] BETWEEN</strong></p>
<p><strong>示例：</strong>where(‘id’, ‘between’, ‘1,8’) | where(‘id’, ‘between’, [1,8])</p>
</li>
<li><p><strong>[NOT] In</strong></p>
<p><strong>示例：</strong>where(‘id’, ‘in’, ‘1,2,3’) | where(‘id’, ‘in’, [1,2,3]) | where(‘id’, ‘not in’, [1,2,3])</p>
</li>
<li><p><strong>[NOT]NULL</strong>         </p>
<p><strong>示例：</strong>where(‘name’, ‘null’) | where(‘name’, ‘not null’)</p>
</li>
<li><p><strong>时间查询</strong></p>
<p>where(‘createtime’, ‘&gt; time’, ‘2006-1-1’);</p>
<p>where(‘createtime’, ‘&lt; time’, ‘2006-1-1’); </p>
<p>where(‘createtime’, ‘between time’, [‘2006-1-1’,’2006-2-1’]);</p>
</li>
</ul>
<p>​	<strong>&gt;time | &lt;time**<br>​	和’&gt;|&lt;’类似，不同的是用&gt;time | &lt;time之类的操作符，后面的条件可以用形如</strong>today** | <strong>last week</strong> | <strong>-2 hour</strong>之类的时间区间，</p>
<p>​	例如：where(‘createtime’, ‘-2 hour’)</p>
<p>​	<strong>Query::whereTime</strong>用法和where类似，不同的是当参数3($range)为null时，$op可以用特殊字段来表示时间区间，支持的特殊日期时间区间格式有：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">where</span>(<span class="string">&#x27;birthday&#x27;</span>, <span class="string">&#x27;today&#x27;</span>)表示日期范围是今天</span><br><span class="line"><span class="title function_ invoke__">where</span>(<span class="string">&#x27;birthday&#x27;</span>, <span class="string">&#x27;yesterday&#x27;</span>)表示日期范围是今天</span><br><span class="line"><span class="title function_ invoke__">where</span>(<span class="string">&#x27;birthday&#x27;</span>, <span class="string">&#x27;week&#x27;</span>)表示日期范围是本周</span><br><span class="line"><span class="title function_ invoke__">where</span>(<span class="string">&#x27;birthday&#x27;</span>, <span class="string">&#x27;last week&#x27;</span>)表示日期范围是上周</span><br><span class="line"><span class="title function_ invoke__">where</span>(<span class="string">&#x27;birthday&#x27;</span>, <span class="string">&#x27;month&#x27;</span>)表示日期范围是本月</span><br><span class="line"><span class="title function_ invoke__">where</span>(<span class="string">&#x27;birthday&#x27;</span>, <span class="string">&#x27;last month&#x27;</span>)表示日期范围是上月</span><br><span class="line"><span class="title function_ invoke__">where</span>(<span class="string">&#x27;birthday&#x27;</span>, <span class="string">&#x27;year&#x27;</span>)表示日期范围是本年</span><br><span class="line"><span class="title function_ invoke__">where</span>(<span class="string">&#x27;birthday&#x27;</span>, <span class="string">&#x27;last year&#x27;</span>)表示日期范围是上年</span><br><span class="line"><span class="title function_ invoke__">whereTime</span>(<span class="string">&#x27;create_time&#x27;</span>,<span class="string">&#x27;-2 hours&#x27;</span>) 表示两小时以内 等价于 <span class="title function_ invoke__">where</span>(<span class="string">&#x27;create_time&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;-2 hours&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>EXP</strong></p>
<p><strong>使用：</strong></p>
<p>​	where(‘字段名’, ‘exp’, ‘条件字符串’)；</p>
<p>​	where(‘字段名’, null, Expression())  可以用DB::raw(“查询字符串”)构造Expression形式的查询条件</p>
<p><strong>示例：</strong></p>
<p>​	where(‘id’, ‘exp’, ‘in(1,2,3)’) <strong>[推荐使用]</strong> ；等价于where(‘id’, ‘in’, ‘1,2,3’) ;</p>
<p>​	where(‘id’, null, DB::raw(“FIND_IN_SET(1, id)”))，其内部也是转为where(‘id’, ‘exp’, ‘in (1,2,3)’);</p>
<p><strong>说明：</strong>exp查询条件不会被当做字符串，可以使用任何sql语法，包括函数和字段名称。</p>
</li>
</ul>
<p><strong>注意：</strong>使用字符串条件查找最好使用<em><strong>预处理机制</strong></em>，确保安全，例如：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;think_user&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&quot;id=:id and username=:name&quot;</span>)</span><br><span class="line">	-&gt;<span class="title function_ invoke__">bind</span>([<span class="string">&#x27;id&#x27;</span>=&gt;[<span class="number">1</span>,\PDO::<span class="variable constant_">PARAM_INT</span>],<span class="string">&#x27;name&#x27;</span>=&gt;<span class="string">&#x27;thinkphp&#x27;</span>])</span><br><span class="line"> 	-&gt;<span class="title function_ invoke__">select</span>();</span><br></pre></td></tr></table></figure>



<ul>
<li><p><strong>Query::whereOr</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 指定OR查询条件</span><br><span class="line"> * @access public</span><br><span class="line"> * @param mixed $field     查询字段</span><br><span class="line"> * @param mixed $op        查询表达式</span><br><span class="line"> * @param mixed $condition 查询条件</span><br><span class="line"> * @return $this</span><br><span class="line"> */</span><br><span class="line">public function whereOr($field, $op = null, $condition = null)    </span><br></pre></td></tr></table></figure>
<p><strong>描述：</strong>设置Or查询条件</p>
</li>
<li><p><strong>Query::whereXOR</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 指定XOR查询条件</span><br><span class="line"> * @access public</span><br><span class="line"> * @param mixed $field     查询字段</span><br><span class="line"> * @param mixed $op        查询表达式</span><br><span class="line"> * @param mixed $condition 查询条件</span><br><span class="line"> * @return $this</span><br><span class="line"> */</span><br><span class="line">public function whereXor($field, $op = null, $condition = null)</span><br></pre></td></tr></table></figure>
<p><strong>描述：</strong>设置XOR查询条件</p>
</li>
<li><p><strong>Query::parseWhereExp</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析查询表达式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@access</span> public</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string                $logic     查询逻辑 and or xor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string|array|\Closure $field     查询字段</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mixed                 $op        查询表达式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mixed                 $condition 查询条件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array                 $param     查询参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  bool                 $strict    严格模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">parseWhereExp</span>(<span class="params"><span class="variable">$logic</span>, <span class="variable">$field</span>, <span class="variable">$op</span>, <span class="variable">$condition</span>, <span class="variable">$param</span> = [], <span class="variable">$strict</span> = <span class="literal">false</span></span>)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>描述：</strong>查询条件表达式解析。</p>
<p><strong>示例：</strong></p>
<ul>
<li><p><strong>And条件</strong><br>  where(“id”, 25)<br>  where(“id &#x3D; 25”)<br>  where(“id”, ‘&#x3D;’, 25)<br>  where(“id”, “in”, [1,2,3])</p>
</li>
<li><p><strong>Or条件</strong><br>  whereOr(“id”, 25)</p>
</li>
<li><p>Xor条件</p>
<p>  whereXor</p>
</li>
<li><p>null条件</p>
<p>  whereNull | whereNotNull</p>
</li>
<li><p>time条件</p>
<p>  whereTime</p>
</li>
<li><p>raw条件</p>
<p>  whereRaw</p>
</li>
<li><p>Exists</p>
<p>  whereExists | whereNotExists</p>
</li>
<li><p>In</p>
<p>  whereIn | whereNotIn</p>
</li>
<li><p>like</p>
<p>  whereLike | whereNotLike</p>
</li>
<li><p>between</p>
<p>  whereBetween | whereNotBetween</p>
</li>
<li><p>EXP</p>
<p>  whereExp</p>
</li>
</ul>
<p><strong>注意：</strong></p>
<p>​	同一级条件中，And和Or平级，如果想实现Or的关系，一般用闭包查询，将Or的条件包在闭包里头，然后整体和外围的条件And<br>例如：想实现condA and condB &amp; (condC or condD)，就将condC&#x2F;condD通过闭包（内部or）然后和condA&#x2F;condB一起链如查询。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$where_extra</span> = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="variable">$query</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$query</span>-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;=&#x27;</span>, <span class="number">3</span>)</span><br><span class="line">        -&gt;<span class="title function_ invoke__">whereOr</span>(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;=&#x27;</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$result</span> = <span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;fa_admin&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;=&quot;</span>, <span class="number">25</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="variable">$where_extra</span>)</span><br><span class="line">    -&gt;<span class="title function_ invoke__">field</span>([<span class="string">&quot;id&quot;</span>, <span class="string">&quot;username&quot;</span> =&gt; <span class="string">&quot;name&quot;</span>])</span><br><span class="line">    -&gt;<span class="title function_ invoke__">fetchSql</span>(<span class="literal">true</span>)</span><br><span class="line">    -&gt;<span class="title function_ invoke__">select</span>();      </span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成的查询sql： &quot;SELECT `id`,`username` AS `name` FROM `fa_admin` WHERE  `id` = 25  AND (  `id` = 3 OR `id` = 4 )&quot;</span></span><br></pre></td></tr></table></figure>


<ul>
<li><strong>Query::fetchSql</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取执行的SQL语句</span><br><span class="line"> * @access public</span><br><span class="line"> * @param boolean $fetch 是否返回sql</span><br><span class="line"> * @return $this</span><br><span class="line"> */</span><br><span class="line">public function fetchSql($fetch = true)</span><br></pre></td></tr></table></figure>
<p><strong>描述：</strong>$fetch为ture则不执行sql，仅仅返回querySql，方便调试sql语句。</p>
<ul>
<li><strong>Builder::select</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 生成查询SQL</span><br><span class="line"> * @access public</span><br><span class="line"> * @param array $options 表达式</span><br><span class="line"> * @return string</span><br><span class="line"> */</span><br><span class="line">public function select($options = [])</span><br></pre></td></tr></table></figure>
<p><strong>描述：</strong>生成查询SQL语句。</p>
<ul>
<li><strong>Builder::alias</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 指定数据表别名</span><br><span class="line"> * @access public</span><br><span class="line"> * @param mixed $alias 数据表别名</span><br><span class="line"> * @return $this</span><br><span class="line"> */</span><br><span class="line">public function alias($alias)</span><br></pre></td></tr></table></figure>
<p><strong>描述：</strong>设置数据库别名<br><strong>范例：</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&quot;fa_admin&quot;</span>)-&gt;<span class="title function_ invoke__">alias</span>([<span class="string">&#x27;fa_admin&#x27;</span>=&gt;<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;fa_customer&quot;</span>=&gt;<span class="string">&quot;customer&quot;</span>])</span><br><span class="line">    -&gt;<span class="title function_ invoke__">join</span>(<span class="string">&#x27;fa_customer&#x27;</span>, <span class="string">&#x27;customer.id=admin.id&#x27;</span>)-&gt;<span class="title function_ invoke__">select</span>();</span><br><span class="line"><span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;fa_admin&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&quot;admin.id&quot;</span>, <span class="string">&quot;=&quot;</span>, <span class="number">25</span>)</span><br><span class="line">    -&gt;<span class="title function_ invoke__">field</span>(<span class="string">&quot;admin.id, admin.username, admin.nickname, staff.mobile, staff.id, staff.post&quot;</span>)</span><br><span class="line">    -&gt;<span class="title function_ invoke__">alias</span>([</span><br><span class="line">        <span class="string">&quot;fa_admin&quot;</span> =&gt; <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">        <span class="string">&quot;fa_qingdong_staff&quot;</span> =&gt; <span class="string">&quot;staff&quot;</span></span><br><span class="line">    ])-&gt;<span class="title function_ invoke__">join</span>(<span class="string">&#x27;fa_qingdong_staff&#x27;</span>, <span class="string">&#x27;staff.admin_id = admin.id&#x27;</span>)</span><br><span class="line">    -&gt;<span class="title function_ invoke__">fetchSql</span>(<span class="literal">false</span>)</span><br><span class="line">    -&gt;<span class="title function_ invoke__">select</span>();</span><br></pre></td></tr></table></figure>



<h1 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a><strong>高级查询</strong></h1><ul>
<li><p><strong>快速查询</strong></p>
<p>​	快捷查询是多个字段使用同一个查询条件的简写，在多个字段之间用|或者&amp;，表示Or和And查询，例如：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;think_user&#x27;</span>)</span><br><span class="line">    -&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;name|title&#x27;</span>,<span class="string">&#x27;like&#x27;</span>,<span class="string">&#x27;thinkphp%&#x27;</span>)</span><br><span class="line">    -&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;create_time&amp;update_time&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">    -&gt;<span class="title function_ invoke__">find</span>();</span><br></pre></td></tr></table></figure>

<p>生成的SQL：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `think_user` WHERE ( `name` LIKE &#x27;thinkphp%&#x27; OR `title` LIKE &#x27;thinkphp%&#x27; ) AND ( `create_time` &gt; 0 AND `update_time` &gt; 0 ) LIMIT 1</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>区间查询</strong></p>
<p>​	区间查询是同一个字段多个查询条件的简化写法，例如：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;think_user&#x27;</span>)</span><br><span class="line">    -&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;name&#x27;</span>,[<span class="string">&#x27;like&#x27;</span>,<span class="string">&#x27;thinkphp%&#x27;</span>],[<span class="string">&#x27;like&#x27;</span>,<span class="string">&#x27;%thinkphp&#x27;</span>])</span><br><span class="line">    -&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;id&#x27;</span>,[<span class="string">&#x27;&gt;&#x27;</span>,<span class="number">0</span>],[<span class="string">&#x27;&lt;&gt;&#x27;</span>,<span class="number">10</span>],<span class="string">&#x27;or&#x27;</span>)</span><br><span class="line">    -&gt;<span class="title function_ invoke__">find</span>();</span><br></pre></td></tr></table></figure>

<p>生成的SQL：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `think_user` WHERE ( `name` LIKE &#x27;thinkphp%&#x27; AND `name` LIKE &#x27;%thinkphp&#x27; ) AND ( `id` &gt; 0 OR `id` &lt;&gt; 10 ) LIMIT 1</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>批量查询</strong></p>
<p>​	批量查询可以进行多个条件的批量条件查询，例如：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;think_user&#x27;</span>)</span><br><span class="line">    -&gt;<span class="title function_ invoke__">where</span>([</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>  =&gt;  [<span class="string">&#x27;like&#x27;</span>,<span class="string">&#x27;thinkphp%&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span> =&gt;  [<span class="string">&#x27;like&#x27;</span>,<span class="string">&#x27;%thinkphp&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;id&#x27;</span>    =&gt;  [<span class="string">&#x27;&gt;&#x27;</span>,<span class="number">0</span>],</span><br><span class="line">        <span class="string">&#x27;status&#x27;</span>=&gt;  <span class="number">1</span></span><br><span class="line">    ])</span><br><span class="line">    -&gt;<span class="title function_ invoke__">select</span>();</span><br></pre></td></tr></table></figure>

<p>生成的SQL：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `think_user` WHERE `name` LIKE &#x27;thinkphp%&#x27; AND `title` LIKE &#x27;%thinkphp&#x27; AND `id` &gt; 0 AND `status` = &#x27;1&#x27;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>闭包查询</strong></p>
<p>​	闭包查询可以很好的执行多个查询条件的与或关系。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Db::table(&#x27;think_user&#x27;)-&gt;select(function($query)&#123;</span><br><span class="line">    $query-&gt;where(&#x27;name&#x27;,&#x27;thinkphp&#x27;)</span><br><span class="line">        -&gt;whereOr(&#x27;id&#x27;,&#x27;&gt;&#x27;,10);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>生成的SQL：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `think_user` WHERE `name` = &#x27;thinkphp&#x27; OR `id` &gt; 10</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>使用Query对象查询</strong></p>
<p>​	可以事先封装Query对象，并且传入select方法，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$query = new \think\db\Query;</span><br><span class="line">$query-&gt;name(&#x27;user&#x27;)</span><br><span class="line">    -&gt;where(&#x27;name&#x27;,&#x27;like&#x27;,&#x27;%think%&#x27;)</span><br><span class="line">    -&gt;where(&#x27;id&#x27;,&#x27;&gt;&#x27;,10)</span><br><span class="line">    -&gt;limit(10);</span><br><span class="line">Db::select($query);    </span><br></pre></td></tr></table></figure>

<p>注意：使用Query对象的话，select方法之前的调用的任何链式操作都是无效的。</p>
</li>
<li><p><strong>混合查询</strong></p>
<p>​	混合前面的查询方式，比如普通查询、快捷查询、批量查询、闭包查询。</p>
</li>
<li><p><strong>字符串条件查询</strong></p>
<p>​	对于一些复杂的查询，可以直接使用原生SQL语句查询，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Db::table(&#x27;think_user&#x27;)</span><br><span class="line">    -&gt;where(&#x27;id &gt; 0 AND name LIKE &quot;thinkphp%&quot;&#x27;)</span><br><span class="line">    -&gt;select();</span><br></pre></td></tr></table></figure>

<p>为了安全起见，我们可以对字符串查询条件使用参数绑定，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Db::table(&#x27;think_user&#x27;)</span><br><span class="line">    -&gt;where(&#x27;id &gt; 0 AND name LIKE &quot;thinkphp%&quot;&#x27;)</span><br><span class="line">    -&gt;select();</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>快捷方法</strong></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>whereNull</code></td>
<td align="left">查询字段是否为Null</td>
</tr>
<tr>
<td align="left"><code>whereNotNull</code></td>
<td align="left">查询字段是否不为Null</td>
</tr>
<tr>
<td align="left"><code>whereIn</code></td>
<td align="left">字段IN查询</td>
</tr>
<tr>
<td align="left"><code>whereNotIn</code></td>
<td align="left">字段NOT IN查询</td>
</tr>
<tr>
<td align="left"><code>whereBetween</code></td>
<td align="left">字段BETWEEN查询</td>
</tr>
<tr>
<td align="left"><code>whereNotBetween</code></td>
<td align="left">字段NOT BETWEEN查询</td>
</tr>
<tr>
<td align="left"><code>whereLike</code></td>
<td align="left">字段LIKE查询</td>
</tr>
<tr>
<td align="left"><code>whereNotLike</code></td>
<td align="left">字段NOT LIKE查询</td>
</tr>
<tr>
<td align="left"><code>whereExists</code></td>
<td align="left">EXISTS条件查询</td>
</tr>
<tr>
<td align="left"><code>whereNotExists</code></td>
<td align="left">NOT EXISTS条件查询</td>
</tr>
<tr>
<td align="left"><code>whereExp</code></td>
<td align="left">表达式查询</td>
</tr>
</tbody></table>
</li>
</ul>
<h1 id="视图查询"><a href="#视图查询" class="headerlink" title="视图查询"></a>视图查询</h1><p>​	视图查询主要是进行多表查询，不需要数据库支持视图。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Db::view(&#x27;User&#x27;,&#x27;id,name&#x27;)</span><br><span class="line">    -&gt;view(&#x27;Profile&#x27;,&#x27;truename,phone,email&#x27;,&#x27;Profile.user_id=User.id&#x27;)</span><br><span class="line">    -&gt;view(&#x27;Score&#x27;,&#x27;score&#x27;,&#x27;Score.user_id=Profile.id&#x27;)</span><br><span class="line">    -&gt;where(&#x27;score&#x27;,&#x27;&gt;&#x27;,80)</span><br><span class="line">    -&gt;select();</span><br></pre></td></tr></table></figure>

<p>生成的SQL语句类似于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT User.id,User.name,Profile.truename,Profile.phone,Profile.email,Score.score FROM think_user User </span><br><span class="line">INNER JOIN think_profile Profile ON Profile.user_id=User.id </span><br><span class="line">INNER JOIN think_socre Score ON Score.user_id=Profile.id WHERE Score.score &gt; 80</span><br></pre></td></tr></table></figure>

<p>默认是inner join，如果需要更改，可以使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Db::view(&#x27;User&#x27;,&#x27;id,name&#x27;)</span><br><span class="line">    -&gt;view(&#x27;Profile&#x27;,&#x27;truename,phone,email&#x27;,&#x27;Profile.user_id=User.id&#x27;,&#x27;LEFT&#x27;)</span><br><span class="line">    -&gt;view(&#x27;Score&#x27;,&#x27;score&#x27;,&#x27;Score.user_id=Profile.id&#x27;,&#x27;RIGHT&#x27;)</span><br><span class="line">    -&gt;where(&#x27;score&#x27;,&#x27;&gt;&#x27;,80)</span><br><span class="line">    -&gt;select();</span><br></pre></td></tr></table></figure>

<p>生成的SQL语句类似于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT User.id,User.name,Profile.truename,Profile.phone,Profile.email,Score.score FROM think_user User </span><br><span class="line">LEFT JOIN think_profile Profile ON Profile.user_id=User.id </span><br><span class="line">RIGHT JOIN think_socre Score ON Score.user_id=Profile.id WHERE Score.score &gt; 80</span><br></pre></td></tr></table></figure>

<p>可以使用别名，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Db::view(&#x27;User&#x27;,[&#x27;id&#x27;=&gt;&#x27;uid&#x27;,&#x27;name&#x27;=&gt;&#x27;account&#x27;])</span><br><span class="line">    -&gt;view(&#x27;Profile&#x27;,&#x27;truename,phone,email&#x27;,&#x27;Profile.user_id=User.id&#x27;)</span><br><span class="line">    -&gt;view(&#x27;Score&#x27;,&#x27;score&#x27;,&#x27;Score.user_id=Profile.id&#x27;)</span><br><span class="line">    -&gt;where(&#x27;score&#x27;,&#x27;&gt;&#x27;,80)</span><br><span class="line">    -&gt;select();</span><br></pre></td></tr></table></figure>

<p>生成的SQL语句类似于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT User.id AS uid,User.name AS account,Profile.truename,Profile.phone,Profile.email,Score.score </span><br><span class="line">FROM think_user User INNER JOIN think_profile Profile ON Profile.user_id=User.id </span><br><span class="line">INNER JOIN think_socre Score ON Score.user_id=Profile.id WHERE Score.score &gt; 80</span><br></pre></td></tr></table></figure>

<p>可以使用数组的方式定义表名以及别名，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Db::view([&#x27;think_user&#x27;=&gt;&#x27;member&#x27;],[&#x27;id&#x27;=&gt;&#x27;uid&#x27;,&#x27;name&#x27;=&gt;&#x27;account&#x27;])</span><br><span class="line">    -&gt;view(&#x27;Profile&#x27;,&#x27;truename,phone,email&#x27;,&#x27;Profile.user_id=member.id&#x27;)</span><br><span class="line">    -&gt;view(&#x27;Score&#x27;,&#x27;score&#x27;,&#x27;Score.user_id=Profile.id&#x27;)</span><br><span class="line">    -&gt;where(&#x27;score&#x27;,&#x27;&gt;&#x27;,80)</span><br><span class="line">    -&gt;select();</span><br></pre></td></tr></table></figure>

<p>生成的SQL语句类似于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT member.id AS uid,member.name AS account,Profile.truename,Profile.phone,Profile.email,Score.score </span><br><span class="line">FROM think_user member INNER JOIN think_profile Profile ON Profile.user_id=member.id </span><br><span class="line">INNER JOIN think_socre Score ON Score.user_id=Profile.id WHERE Score.score &gt; 80</span><br></pre></td></tr></table></figure>



<h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><ul>
<li><p><strong>使用select()</strong></p>
<p>Query::select()参数为false时，不进行查询而是返回构建的SQL语句，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT member.id AS uid,member.name AS account,Profile.truename,Profile.phone,Profile.email,</span><br><span class="line">Score.score FROM think_user member INNER JOIN think_profile Profile ON Profile.user_id=member.id </span><br><span class="line">INNER JOIN think_socre Score ON Score.user_id=Profile.id WHERE Score.score &gt; 80</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>使用fetchSql()</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$subQuery = Db::table(&#x27;think_user&#x27;)</span><br><span class="line">    -&gt;field(&#x27;id,name&#x27;)</span><br><span class="line">    -&gt;where(&#x27;id&#x27;,&#x27;&gt;&#x27;,10)</span><br><span class="line">    -&gt;fetchSql(true)</span><br><span class="line">    -&gt;select();</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>使用buildSql构造子查询</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$subQuery = Db::table(&#x27;think_user&#x27;)</span><br><span class="line">    -&gt;field(&#x27;id,name&#x27;)</span><br><span class="line">    -&gt;where(&#x27;id&#x27;,&#x27;&gt;&#x27;,10)</span><br><span class="line">    -&gt;buildSql();</span><br></pre></td></tr></table></figure>

<p>生成subQuery结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( SELECT `id`,`name` FROM `think_user` WHERE `id` &gt; 10 )</span><br></pre></td></tr></table></figure>

<p><em><strong>注意：此方法会自动加括号，前面两个方法需要手动添加括号。</strong></em></p>
<p>然后使用子查询构造新的查询：</p>
<p>生成的SQL语句为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM ( SELECT `id`,`name` FROM `think_user` WHERE `id` &gt; 10 ) a WHERE a.name LIKE &#x27;thinkphp&#x27;</span><br><span class="line">ORDER BY `id` desc</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>使用闭包构造子查询</strong></p>
<p><code>IN/NOT IN</code>和<code>EXISTS/NOT EXISTS</code>之类的查询可以直接使用闭包作为子查询，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Db::table(&#x27;think_user&#x27;)</span><br><span class="line">-&gt;where(&#x27;id&#x27;,&#x27;IN&#x27;,function($query)&#123;</span><br><span class="line">    $query-&gt;table(&#x27;think_profile&#x27;)-&gt;where(&#x27;status&#x27;,1)-&gt;field(&#x27;id&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">-&gt;select();</span><br></pre></td></tr></table></figure>

<p>生成的SQL语句类似：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `think_user` WHERE `id` IN ( SELECT `id` FROM `think_profile` WHERE `status` = 1 )</span><br></pre></td></tr></table></figure>

<p>又例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Db::table(&#x27;think_user&#x27;)</span><br><span class="line">-&gt;where(function($query)&#123;</span><br><span class="line">    $query-&gt;table(&#x27;think_profile&#x27;)-&gt;where(&#x27;status&#x27;,1);</span><br><span class="line">&#125;,&#x27;exists&#x27;)</span><br><span class="line">-&gt;find();</span><br></pre></td></tr></table></figure>

<p>生成的SQL语句类似：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `think_user` WHERE EXISTS ( SELECT * FROM `think_profile` WHERE `status` = 1 ) </span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="原生查询"><a href="#原生查询" class="headerlink" title="原生查询"></a>原生查询</h1><ul>
<li><p><strong>Query::query方法</strong></p>
<p>用于执行SQL查询操作，如果数据非法或者查询错误返回false，否则返回结果集。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Db::query(&quot;select * from think_user where status=1&quot;);</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>Query::execute()</strong></p>
<p>execute用于更新和写入数据的sql操作，如果数据非法或者查询错误则返回false ，否则返回影响的记录数。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Db::execute(&quot;update think_user set name=&#x27;thinkphp&#x27; where status=1&quot;);</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>参数绑定</strong></p>
<p>支持在原生查询的时候使用参数绑定，包括问号占位符或者命名占位符，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Db::query(&quot;select * from think_user where id=? AND status=?&quot;,[8,1]);</span><br><span class="line">// 命名绑定</span><br><span class="line">Db::execute(&quot;update think_user set name=:name where status=:status&quot;,[&#x27;name&#x27;=&gt;&#x27;thinkphp&#x27;,&#x27;status&#x27;=&gt;1]);</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>存储过程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$result = Db::query(&#x27;call sp_query(8)&#x27;);</span><br></pre></td></tr></table></figure>

<p>也可以用参数绑定：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$result = Db::query(&#x27;call sp_query(?)&#x27;,[8]);</span><br><span class="line">// 或者命名绑定</span><br><span class="line">$result = Db::query(&#x27;call sp_query(:id)&#x27;,[&#x27;id&#x27;=&gt;8]);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h1><ul>
<li><p>一对一关联</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hasOne(&#x27;关联模型名&#x27;,&#x27;外键名&#x27;,&#x27;主键名&#x27;,[&#x27;模型别名定义&#x27;],&#x27;join类型&#x27;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">belongsTo(&#x27;关联模型名&#x27;,&#x27;外键名&#x27;,&#x27;关联表主键名&#x27;,[&#x27;模型别名定义&#x27;],&#x27;join类型&#x27;);</span><br></pre></td></tr></table></figure>

<p>例如：customer表通过owner_staff_id关联到staff表，外键名为staff表的主键id，主键名为customer表的owner_staff_id，customer表通过字段owner_staff_id与staff表的id外键关联起来。这里的本地的称之为主键，关联的外部模型的字段称之为外键，这么说可能更容易理解：</p>
<p>hasOne(‘关联模型’, ‘关联模型的关联字段名’, ‘本地字段名’)  其中’本地字段名’和’关联模型的关联字段名’是相关联的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public function ownerStaff() &#123;</span><br><span class="line"></span><br><span class="line">    return $this-&gt;hasOne(Staff::class, &#x27;id&#x27;, &#x27;owner_staff_id&#x27;)-&gt;field(&#x27;id,name,group_ids&#x27;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>一对多关联</p>
</li>
<li><p>多对多关联</p>
</li>
<li><p>关联预载入</p>
</li>
<li><p>关联统计</p>
</li>
</ul>
<h1 id="ThinkPHP5-DB模块可能存在的问题"><a href="#ThinkPHP5-DB模块可能存在的问题" class="headerlink" title="ThinkPHP5 DB模块可能存在的问题"></a><strong>ThinkPHP5 DB模块可能存在的问题</strong></h1><ul>
<li><p><strong>参数绑定性能</strong></p>
<p>比如设置了一个查询条件where(‘id’, ‘in’, $idlist) 其中$idlist是一个数组格式的id集合，如果$idlist数据量比较大，在解析where参数的时候进行。当参数绑定耗时会比较多，此时可以用字符串的where代替，就是逻辑层直接用$idlist转为字符串$strids，然后where(“id in (${strids})”);<br><strong>例如：</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$idlist</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">25</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">28</span>,<span class="number">29</span>,<span class="number">30</span>];</span><br><span class="line"><span class="variable">$strids</span> = <span class="title function_ invoke__">implode</span>(<span class="string">&#x27;,&#x27;</span>, <span class="variable">$idlist</span>);</span><br><span class="line"><span class="variable">$result</span> = <span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;fa_admin&#x27;</span>)</span><br><span class="line">    <span class="comment">// 当$idlist很大时，用字符串where条件替代</span></span><br><span class="line">    <span class="comment">//-&gt;where(&quot;id&quot;, &#x27;in&#x27;, $idlist)</span></span><br><span class="line">    -&gt;<span class="title function_ invoke__">where</span>(<span class="string">&quot;id in ($&#123;strids&#125;)&quot;</span>)</span><br><span class="line">    -&gt;<span class="title function_ invoke__">field</span>([<span class="string">&quot;id&quot;</span>, <span class="string">&quot;username&quot;</span> =&gt; <span class="string">&quot;name&quot;</span>])</span><br><span class="line">    -&gt;<span class="title function_ invoke__">fetchSql</span>(<span class="literal">false</span>)</span><br><span class="line">    -&gt;<span class="title function_ invoke__">select</span>();</span><br></pre></td></tr></table></figure>

</li>
<li><p><strong>Model结果序列化性能</strong></p>
<p>​	通常情况下如果数据量比较大一般会采取分页机制来减少每次查询和处理的记录集。但是如果用户确实就想一次性查看大量数据比如(1000)条记录，测试发现通过Model查询db获取记录之后调用json(model)会触发Model::jsonSerialize()，进而调用Model::toArray()，此函数对Model中每个属性进行处理，很耗时。可行的优化方案如下：</p>
<ul>
<li><p><strong>降低查询的fields</strong></p>
<p>通过fields(“xxx”)来过滤需要的字段列表，或者通过设置模型的显示属性$visible和隐藏属性$hidden</p>
</li>
<li><p><strong>降低pageNum</strong></p>
<p>毕竟都有分页了，没必要将每页记录数量设置太大</p>
</li>
<li><p><strong>优化Model::toArray()</strong></p>
<p>测试从customer表中查出1000条件记录，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$result = Customer::where(&quot;id&quot;, &#x27;exp&#x27;, &quot;&gt; 0&quot;)-&gt;limit(1000)-&gt;select();</span><br><span class="line"></span><br><span class="line">$timeprofile[] = Debug::getUseTime();</span><br><span class="line"></span><br><span class="line">$result_json = json_encode($result);</span><br><span class="line"></span><br><span class="line">$timeprofile[] = Debug::getUseTime();</span><br></pre></td></tr></table></figure>

<p>打印出的时间：</p>
<p>​	select耗时：0.03s</p>
<p>​	json_encode耗时：6.95s</p>
<p>由上可见Model::toArray()耗时非常大。</p>
</li>
<li><p><strong>优化Query::select()</strong></p>
<p>select()会先准备要执行的最终查询sql，然后查询，查询完毕后还会对结果集进行处理，比如创建模型对象，并且用结果集中的每条记录数据来初始化模型对象，此过程也是非常耗时，对于大部分只需要数据并不会后续处理的应用场景而言，可以省略这一步操作。其实，Query::select()如果没有model对象，这一步本来就是可以省略的。</p>
</li>
</ul>
</li>
</ul>
<p>​	</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jerrywang2013.github.io/2024/04/27/ThinkPHP%E4%B9%8BDB-Query/" data-id="clwbg5x4l0004z44qfy6ab9hx" data-title="ThinkPHP之DB::Query" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/05/27/c-11/">c++11</a>
          </li>
        
          <li>
            <a href="/2024/05/18/QT/">QT</a>
          </li>
        
          <li>
            <a href="/2024/05/14/c-%E8%B0%83%E8%AF%95/">c++调试</a>
          </li>
        
          <li>
            <a href="/2024/05/11/%E7%94%A8libharu%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AA%E5%B0%8F%E4%BD%9C%E4%B8%9A/">用libharu完成一个小作业</a>
          </li>
        
          <li>
            <a href="/2024/05/09/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BFApacheServer%E9%85%8D%E7%BD%AE/">宝塔面板ApacheServer配置</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
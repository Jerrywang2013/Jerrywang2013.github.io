<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Jerry Blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="learning records">
<meta property="og:type" content="website">
<meta property="og:title" content="Jerry Blogs">
<meta property="og:url" content="https://jerrywang2013.github.io/index.html">
<meta property="og:site_name" content="Jerry Blogs">
<meta property="og:description" content="learning records">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="c++ lua php js python">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Jerry Blogs" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Jerry Blogs</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://jerrywang2013.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-QT" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/05/18/QT/" class="article-date">
  <time class="dt-published" datetime="2024-05-18T00:56:13.000Z" itemprop="datePublished">2024-05-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/05/18/QT/">QT</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h1><p><strong>Q： 在线安装频繁提示网络错误，用代理和不用代理一样</strong></p>
<p><strong>A：</strong>尝试使用离线安装包（qt-creator-opensource-windows-x86_64-13.0.1.exe），里头可选择安装项目。</p>
<p><strong>Q：QtCreator编译后如何部署</strong></p>
<p>A：编译后会生成可执行环境，进入到生成目录直接运行exe文件无法启动，提示依赖库不存在，不过可以在Creator中调试（会自动设置好依赖库路径）。发布的时候需要部署，qt自带了部署工具windeployqt.exe，具体的在开发包5.12.12\msvc2017_64\bin\（x64）或者5.12.12\msvc2017\bin\（x86）下面，此命令只需要一个exe文件名即可。例如：你可以将生成的output.exe文件拷贝到你要部署的目录，然后在部署目录下执行windeployqt.exe output.exe即可。</p>
<p>​		当然，我们也可以借助QtCreator工具来部署，在Kit中点击Run，打开运行配置，最上面就是部署配置，可以创建部署步骤(Customer Process Step)，例如我们先拷贝输出文件到部署目录然后部署，下面是示例&gt;2：</p>
<p><img src="/2024/05/18/QT/image-20240518091304577.png" alt="image-20240518091304577"></p>
<p><strong>注意：</strong>这里步骤一是想用copy命令拷贝，不要直接在command：里头输入copy，他会提示：invalid command。我们需要用cmd.exe &#x2F;c copy来执行拷贝，Command填入cmd.exe即可， &#x2F;c copy 填在arguments里头。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jerrywang2013.github.io/2024/05/18/QT/" data-id="clwbg5x4k0003z44q9fcu4qwg" data-title="QT" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-c-调试" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/05/14/c-%E8%B0%83%E8%AF%95/" class="article-date">
  <time class="dt-published" datetime="2024-05-13T22:52:45.000Z" itemprop="datePublished">2024-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/05/14/c-%E8%B0%83%E8%AF%95/">c++调试</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>好多年都没怎用c&#x2F;c++了，最近因为用到某个库写个小工具用到c++，这里简单记录下c++调试。</p>
<p>环境：VS2022</p>
<p>编译环境：x64 debug</p>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="简单的函数调用示例"><a href="#简单的函数调用示例" class="headerlink" title="简单的函数调用示例"></a>简单的函数调用示例</h2><ul>
<li><p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> s = <span class="built_in">sum</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sum:&quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码只有一个简单的函数调用，我们通过这个案例主要了解一下c++代码背后的机器码的样子，以及程序运行过程中栈和寄存器的变化。</p>
</li>
<li><p>反汇编</p>
<ul>
<li><p><strong>sum() 反汇编</strong>(被调用函数)</p>
<p><img src="/2024/05/14/c-%E8%B0%83%E8%AF%95/project\hexo\github-blog\source_posts\c-调试\image-20240514070514439.png" alt="image-20240514070514439"></p>
</li>
</ul>
<p><img src="/2024/05/14/c-%E8%B0%83%E8%AF%95/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240514070514439.png" alt="image-20240514070514439"></p>
<p>部分反汇编代码解释：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">push rbp; rbp值入栈，用于保存rbp寄存器，后面恢复用</span><br><span class="line">push rdi; rdi寄存器入栈，后面会用到rdi寄存器，这里值先保存</span><br><span class="line">sub rsp 0e8h; 将rsp减去0e8h，保留栈空间用于本函数(局部变量等）的使用</span><br><span class="line">mov eax, dword ptr[a]; 将a值赋值给eax寄存器</span><br><span class="line">mov ecx, dword ptr[b]; 将b值赋值给ecx寄存器</span><br><span class="line">lea eax, [rax+rcx+1]; 计算rax+rcx+1结果保存到eax</span><br><span class="line">lea rsp,[rbp+0c8h]; 恢复rsp，之前rsp用rbp+0e8h,然后rbp-=20h</span><br><span class="line">pop rdi; 恢复rdi寄存器</span><br><span class="line">pop rbp; 恢复rbp寄存器</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>main() 反汇编</strong>(调用函数)</li>
</ul>
<p><img src="/2024/05/14/c-%E8%B0%83%E8%AF%95/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240514070345762.png" alt="image-20240514070345762"></p>
<p>主要看main函数调用sum()前后部分反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov edx, dword ptr[b];   变量b的值赋值给edx寄存器</span><br><span class="line">mov ecx, dword ptr[a];  变量a的值赋值给ecx寄存器</span><br><span class="line">call sum(07FF71D5411E5h); 调用sum函数</span><br></pre></td></tr></table></figure>

<p><strong>x64架构调用约定：</strong></p>
<ul>
<li><p>在x64 window平台下，函数参数传递默认情况下前四个整形或者指针参数统计寄存器传递(rcx, rdx, r8, r9)，后面的参数通过压栈传参。可以看到，这里2个参数是用了ecx和edx传参。</p>
<p>测试5个参数的传参：</p>
<pre><code>00007FF758712370  push        rbp  
00007FF758712372  push        rdi  
00007FF758712373  sub         rsp,158h  
00007FF75871237A  lea         rbp,[rsp+30h]
int s = sum(a, b, 3, 4, 5);
00007FF758712399  mov         dword ptr [rsp+20h],5    
00007FF7587123A1  mov         r9d,4  
00007FF7587123A7  mov         r8d,3  
00007FF7587123AD  mov         edx,dword ptr [b]  
00007FF7587123B0  mov         ecx,dword ptr [a]  
00007FF7587123B3  call        sum (07FF758711465h) 
</code></pre>
<p>​		可以看到参数处理是从左往右，前面四个参数用rcx、rdx、r8、r9传递，后面的参数压入栈传递（自左往右）， 第五个参数压入到rsp+20h位置，如果有第六个参数，则第六个参数在第五个参数之后入栈，对应位置在rsp+28h;</p>
</li>
<li><p>前4个参数如果是浮点参数，通过SSE寄存器xmm0-xmm3传递</p>
</li>
<li><p>由调用者为寄存器中的参数传递保留栈上的空间（至少分配32字节的阴影空间），被调用者可以访问这个栈空间来讲寄存器中的内容写回栈空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lea rbp,[rsp+30h]; </span><br><span class="line">这个代码就是为参数保留栈空间，以便调用者调用到。一般来说总长度是(总的参数个数)*8</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>不要以为前面四个参数是通过寄存器传递给被调用函数可以不用为参数保留栈空间，哪怕调用者这边不用，也需要保留参数的栈空间，因为被调用者那边约定是将寄存器的内容写入到栈中。有个疑问，这样用寄存器传递参数不是多此一举，比直接用栈传递参数还少拷贝两次吗？</p>
</li>
<li><p>返回整数或者指针通过rax寄存器完成，浮点数返回值通过xmm0传递</p>
</li>
<li><p>堆栈保持16字节对齐（叶函数除外）</p>
</li>
<li><p>x64没有x86的stdcall&#x2F;cdecl&#x2F;fastcall&#x2F;thiscall等，只有一个x64调用约定</p>
</li>
</ul>
<p> 备注：</p>
<ol>
<li><p>call会将返回地址压入堆栈（esp&#x3D;esp-8)</p>
</li>
<li><p>栈是沿低地址延伸的，栈底地址是大于栈顶地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push rax  等价于 rsp--; *rsp = rax;</span><br><span class="line">pop rax 等价于rax = *rsp; rsp++;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>栈布局图</strong></p>
<img src="/2024/05/14/c-%E8%B0%83%E8%AF%95/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240515000343120.png" alt="image-20240515000343120" style="zoom: 33%;">

<p><img src="https://learn.microsoft.com/en-us/cpp/build/media/vcamd_conv_ex_5.png?view=msvc-170" alt="Diagram of the stack layout for the x64 conversion example."></p>
</li>
</ul>
<p><img src="/2024/05/14/c-%E8%B0%83%E8%AF%95/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240516120003269.png" alt="image-20240516120003269"></p>
<p><img src="/2024/05/14/c-%E8%B0%83%E8%AF%95/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240517133710237.png" alt="image-20240517133710237"></p>
<h2 id="volatile-non-volatile-register"><a href="#volatile-non-volatile-register" class="headerlink" title="volatile &amp; non-volatile register"></a>volatile &amp; non-volatile register</h2><p>​		volatile register通常又称之为可变寄存器。可变的意思是在函数调用过程中寄存器值可能发生变化。</p>
<ul>
<li><p>常见volatile register</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RAX, RCX, RDX, R8, R9, R10, R11</span><br><span class="line">// 这几个寄存器常用语参数传递</span><br></pre></td></tr></table></figure>
</li>
<li><p>常见的non-volatile register</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RBX，RDI,RSI,RBP,RSP,R12,R13,R14,R15</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="x64函数中的Prolog和Epilog"><a href="#x64函数中的Prolog和Epilog" class="headerlink" title="x64函数中的Prolog和Epilog"></a>x64函数中的Prolog和Epilog</h2><p>x64 push&#x2F;pop指令限定在prolog和epilog中使用，因为在prolog和epilog之间rsp是不会被修改的。</p>
<h3 id="prolog"><a href="#prolog" class="headerlink" title="prolog"></a>prolog</h3><ul>
<li><p>将寄存器参数保存到调用函数分配的参数所在的栈空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">   通常代码如下，上面的4个mov指令是将寄存器参数保存到栈里头，对被调用函数而言，这段代码寻址是固定的，因为rsp指向的是返回地址，它的上面才是参数，所以第一个参数地址永远是rsp+8；第二个参数地址是rsp+10h，以此类推。</span><br><span class="line">*/</span><br><span class="line"> mov     dword ptr [rsp+20h],r9d</span><br><span class="line"> mov     dword ptr [rsp+18h],r8d</span><br><span class="line"> mov     dword ptr [rsp+10h],edx</span><br><span class="line"> mov     dword ptr [rsp+8],ecx</span><br><span class="line"> sub     rsp,18h</span><br></pre></td></tr></table></figure>


</li>
<li><p>保存本函数可能修改的volatile寄存器的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 类似如下反汇编代码，保存non-volatile寄存器</span><br><span class="line">00007FF78B541CE2  push        rbp  </span><br><span class="line">00007FF78B541CE3  push        rdi</span><br></pre></td></tr></table></figure>


</li>
<li><p>为函数局部变量分配栈空间，如果此函数有调用其他函数，还要为调用函数的参数分配空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00007FF78B541CE4  sub         rsp,108h  </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Epilog"><a href="#Epilog" class="headerlink" title="Epilog"></a>Epilog</h3><ul>
<li>清理函数在prolog中为其变量分配的堆栈空间以及函数参数堆栈空间</li>
<li>恢复non-volatile寄存器</li>
<li>返回到调用者</li>
</ul>
<p>x86堆栈操作与x64主要差别</p>
<p>​	x86堆栈操作严重以来ebp；而x64不依赖。</p>
<h1 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h1><p>​	在c&#x2F;c++中，调用约定指的是编译器如果安排函数调用中参数传递顺序、调用栈空间的清理、函数返回值传递等规则。不同平台和编译器有不同的函数调用约定，主要有三个：</p>
<ul>
<li><p>__cdecl</p>
<p>​	默认调用约定。参数从右往左压入堆栈，调用方负责清理堆栈，返回值通过寄存器传递。</p>
</li>
<li><p>__stdcall</p>
<p>​	windows平台常用。参数从右往左压入堆栈，被调用函数清理堆栈，返回值通过寄存器传递。</p>
</li>
<li><p>__thiscall</p>
<p>​		常用语类成员函数，将this指针作为隐式参数传递给函数，其它参数从右往左压入堆栈，调用者负责清理堆栈。</p>
</li>
</ul>
<p>​		不用太纠结用那个调用约定，本身只是一个规则而已。一般来说，通过返回指令ret 和 ret X能判断出是否是stdcall或者cdecl。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64">x86-64 上的堆栈框架布局 - Eli Bendersky 的网站 (thegreenplace.net)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wingsummer/p/16076345.html">x64 番外篇——知识铺垫 - 寂静的羽夏 - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/cpp/build/x64-software-conventions?view=msvc-170&redirectedfrom=MSDN">x64 ABI 约定 |Microsoft学习</a></p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170">x64 calling convention | Microsoft Learn</a></p>
<p><a target="_blank" rel="noopener" href="https://medium.com/@sruthk/cracking-assembly-introduction-to-assembly-language-a4ad14e601a1">破解程序集 — 程序集语言简介 |由 Sruthi K |中等 (medium.com)</a></p>
<h1 id="常用windbg命令"><a href="#常用windbg命令" class="headerlink" title="常用windbg命令"></a>常用windbg命令</h1><p>​		这里仅仅记录调试常用的命令，不全。需要详细的命令可以查看dbghelp.chm文件(debug tools for windwos包)</p>
<ul>
<li>设置符号&#x2F;源文件路径</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.sympath + &lt;pdb文件路径&gt;</span><br><span class="line">.srcpath + &lt;.cpp文件路径&gt;</span><br></pre></td></tr></table></figure>

<p>​		也可以在界面’文件‘菜单中点击’Symbol File Path‘设置符号文件路径；点击”Source File Path”打开代码文件路径。</p>
<ul>
<li><p>d </p>
<p>查看内存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d addr</span><br><span class="line">// 默认以字节为单位显示，也可以用db | dw | dd | dq来显示指定显示格式</span><br><span class="line">// 查看堆栈附近内存</span><br><span class="line">d rsp</span><br></pre></td></tr></table></figure>
</li>
<li><p>uf </p>
<p>查看函数汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uf [Module!]Function</span><br><span class="line">uf [Module!]Address</span><br><span class="line">address是函数地址，可以用名称，例如 </span><br><span class="line">uf ConsoleApplicaiton!main</span><br><span class="line">uf main</span><br></pre></td></tr></table></figure>
</li>
<li><p>切换调试模型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l+t 设置调试模式为源码模式</span><br><span class="line">l-t 设置调试模式为反汇编模式</span><br><span class="line">l+s 命令行显示行号</span><br><span class="line">l-s 命令行不显示行号</span><br></pre></td></tr></table></figure>
</li>
<li><p>!analyze</p>
<p>分析dump文件用到。</p>
</li>
<li><p>lm</p>
<p>显示模块信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lmOptions [a Address] [m Pattern | M Pattern]</span><br><span class="line">eg:</span><br><span class="line">lmDvm *Console*!*</span><br></pre></td></tr></table></figure>
</li>
<li><p>x</p>
<p>查看符号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x [opts] Module!Symbol</span><br><span class="line">x * // ！！！注意，这个是显示局部变量！！！</span><br><span class="line">eg:</span><br><span class="line">x sample!*main*</span><br><span class="line">支持*通配符，列出sample模块的所有含有字符串main的函数</span><br></pre></td></tr></table></figure>
</li>
<li><p>b</p>
<p>设置断点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bm sample!*main*   // bm设置函数断点</span><br><span class="line">bp address  // 设置地址断点</span><br></pre></td></tr></table></figure>
</li>
<li><p>r</p>
<p>显示寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; r</span><br><span class="line">rax=0000000000000006 rbx=0000000000000000 rcx=0000000000000006</span><br><span class="line">rdx=0000000000000001 rsi=0000000000000000 rdi=0000000000000000</span><br><span class="line">rip=00007ff696776656 rsp=00000051766ff640 rbp=00000051766ff670</span><br><span class="line"> r8=0000000000000002  r9=00000051766ff728 r10=0000000000000012</span><br><span class="line">r11=00000051766ff7d0 r12=0000000000000000 r13=0000000000000000</span><br><span class="line">r14=0000000000000000 r15=0000000000000000</span><br></pre></td></tr></table></figure>
</li>
<li><p>k</p>
<p>查看堆栈，如果要显示所有线程的堆栈：~*k</p>
</li>
<li><p>.formats</p>
<p>显示表达式和符号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.formats expression</span><br></pre></td></tr></table></figure>
</li>
<li><p>常见操作片段</p>
<p>假设调试ConsoleApplication1.exe</p>
<p>查看模块	 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//所有模块，然后点击某个模块可以列出函数</span><br><span class="line">lm</span><br><span class="line">// 查看某个模块</span><br><span class="line">lmv m Console*</span><br></pre></td></tr></table></figure>

<p>查看ConsoleApplicaiton1中的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 列出ConsoleApplication1中所有函数</span><br><span class="line">x ConsoleA*!*</span><br><span class="line">// 如果函数太多，可以用DML格式来显示。注意/D 后面接的是modulename（可统配），不要带方法</span><br><span class="line">x /D Console*!a*</span><br><span class="line">// 查看某个方法地址，从上面的DML显示中直接点击或者用通配符 找到函数符号和地址</span><br><span class="line">x /D ConsoleApplicati*!s*</span><br><span class="line">// 用bm或者bp设置断点。注意bp不会检测断点地址；bm会检测符号是否存在</span><br><span class="line">bm ConsoleApplication1!sum</span><br><span class="line">bp 00007ff7`8b541cc0</span><br><span class="line">// 恢复程序运行</span><br><span class="line">g</span><br><span class="line">// ....</span><br><span class="line">// 运行到断点处触发断点，程序中断</span><br><span class="line">// 显示局部变量</span><br><span class="line">dv</span><br><span class="line">dv /v 显示变量和变量的地址</span><br><span class="line">// 显示堆栈</span><br><span class="line">k</span><br><span class="line">// 显示内存</span><br><span class="line">db Address</span><br><span class="line">// 看寄存器</span><br><span class="line">r</span><br><span class="line">// 查看汇编</span><br><span class="line">u Address</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>​</p>
</li>
</ul>
<p>	</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jerrywang2013.github.io/2024/05/14/c-%E8%B0%83%E8%AF%95/" data-id="clwbg5x4l0005z44qcmrhab55" data-title="c++调试" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-用libharu完成一个小作业" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/05/11/%E7%94%A8libharu%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AA%E5%B0%8F%E4%BD%9C%E4%B8%9A/" class="article-date">
  <time class="dt-published" datetime="2024-05-10T23:35:56.000Z" itemprop="datePublished">2024-05-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/05/11/%E7%94%A8libharu%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AA%E5%B0%8F%E4%BD%9C%E4%B8%9A/">用libharu完成一个小作业</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>libharu是一个开源的pdf文件操作的C语言库。</p>
<p>因一个小作业需要用libharu而初步接触haru，这里简单记录一下自己的理解。	</p>
<h1 id="下载-安装"><a href="#下载-安装" class="headerlink" title="下载 &amp; 安装"></a>下载 &amp; 安装</h1><ul>
<li><p><strong>下载</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/libharu/libharu.git</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>安装</strong></p>
<p>​		参考readme和install说明。在windows下利用CMake进行安装。		</p>
<pre><code>    mkdir libharu_build
    cd libharu_build
    cmake ..\libharu
</code></pre>
<p>​		本机安装了vs2022, CMake会自动生成VS2022的工程文件。</p>
</li>
<li><p><strong>编译</strong></p>
<p>​		打开VS2022，打开libharu_build\libharu.sln文件，可正常编译通过，生成库文件在libharu_build\src\debug\，配置文件在libharu_build\include。可自行修改项目配置设置编译后生成的库文件目录，或者直接在postbuild里头加个脚本做生成后的发布（拷贝）。</p>
<p>​</p>
</li>
</ul>
<p>		</p>
<h1 id="libharu-功能"><a href="#libharu-功能" class="headerlink" title="libharu 功能"></a>libharu 功能</h1><p>​		简单看了下 <code>https://github.com/libharu/libharu/wiki</code>，了解一下haru的基本概念和一些设计思想。</p>
<h3 id="图形"><a href="#图形" class="headerlink" title="图形"></a>图形</h3><ul>
<li><h5 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h5><p>​		默认坐标轴原点(0,0)是页面左下角，右上角坐标是(页面宽，页面高)，xy轴方向分别是往右和往上；默认分辨率是72dpi。</p>
<p>​		可以用HPDF_Page_Concat()修改默认坐标系。	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HPDF_STATUS HPDF_Page_Concat  (HPDF_Page    page,</span><br><span class="line">                               HPDF_REAL    a,</span><br><span class="line">                               HPDF_REAL    b,</span><br><span class="line">                               HPDF_REAL    c,</span><br><span class="line">                               HPDF_REAL    d,</span><br><span class="line">                               HPDF_REAL    x,</span><br><span class="line">                               HPDF_REAL    y);</span><br></pre></td></tr></table></figure>

<p>​		wiki中没有讲参数含义，大概猜测这里的abcd是旋转矩阵的四个变量，xy应该是偏移量。</p>
<p><strong>例如：</strong></p>
<p>将坐标系沿着XY正方向偏移（100， 100）像素，新的原点是原来坐标系(100, 100)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HPDF_Page_Concat(page, 1, 0, 0, 1, 100, 100);</span><br></pre></td></tr></table></figure>

<p>​		</p>
</li>
<li><p><strong>图形模式</strong></p>
<p>​		libharu为每个pdf文档的每一页维护一个图形模式标志，用于控制绘图操作。图形模式不需要显示的去设置，而是通过相关的绘图函数来控制的，同样的，不同的图像模式下可以调用的函数也是不同的，必须保证函数能在合适的图像模式下调用，常见的调用错误是：</p>
<table>
<thead>
<tr>
<th align="left">HPDF_PAGE_INVALID_GMODE</th>
<th>0x1051</th>
<th>See Graphics mode.</th>
</tr>
</thead>
<tbody><tr>
<td align="left"></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>常见的三种GMode</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define  HPDF_GMODE_PAGE_DESCRIPTION    0x0001</span><br><span class="line">  </span><br><span class="line">#define  HPDF_GMODE_PATH_OBJECT       0x0002</span><br><span class="line">  </span><br><span class="line">#define  HPDF_GMODE_TEXT_OBJECT       0x0004</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>HPDF_GMODE_PAGE_DESCRIPTION</strong></p>
<p>可用操作：</p>
<ul>
<li><p>General graphics state</p>
</li>
<li><p>Special graphics state</p>
</li>
<li><p>Color</p>
</li>
<li><p>Text state</p>
</li>
</ul>
</li>
<li><p><strong>HPDF_GMODE_PATH_OBJECT</strong></p>
<p>可用操作：</p>
<ul>
<li>Path Construction</li>
</ul>
<p>	</p>
<p><strong>状态机：</strong></p>
<ul>
<li><p>调用绘图函数(Path Construction)进入</p>
</li>
<li><p>调用Path Painting Operators退出到<strong>HPDF_GMODE_PAGE_DESCRIPTION</strong></p>
</li>
</ul>
</li>
<li><p><strong>HPDF_GMODE_TEXT_OBJECT</strong></p>
<p><strong>可用操作：</strong></p>
<ul>
<li>Graphics state</li>
<li>Color</li>
<li>Text state</li>
<li>Text-showing</li>
<li>Text-positioning</li>
</ul>
<p><strong>状态机：</strong></p>
<ul>
<li><p>调用HPDF_Page_BeginText()进入</p>
</li>
<li><p>调用HPDF_Page_EndText()退出到<strong>HPDF_GMODE_PAGE_DESCRIPTION</strong></p>
</li>
</ul>
</li>
</ul>
<p><strong>Graphpics State</strong> 操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HPDF_Page_Concat()</span><br><span class="line">HPDF_Page_SetDash()</span><br><span class="line">HPDF_Page_SetFlat()</span><br><span class="line">HPDF_Page_SetLineCap()</span><br><span class="line">HPDF_Page_SetLineJoin()</span><br><span class="line">HPDF_Page_SetLineWidth()</span><br><span class="line">HPDF_Page_SetMiterLimit()</span><br></pre></td></tr></table></figure>

<p><strong>Color</strong>操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HPDF_Page_SetCMYKFill()</span><br><span class="line">HPDF_Page_SetCMYKStroke()</span><br><span class="line">HPDF_Page_SetGrayFill()</span><br><span class="line">HPDF_Page_SetGrayStroke()</span><br><span class="line">HPDF_Page_SetRGBFill()</span><br><span class="line">HPDF_Page_SetRGBStroke()</span><br></pre></td></tr></table></figure>

<p><strong>Path Construction</strong>操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HPDF_Page_Arc()</span><br><span class="line">HPDF_Page_Circle()</span><br><span class="line">HPDF_Page_CurveTo()</span><br><span class="line">HPDF_Page_CurveTo2()</span><br><span class="line">HPDF_Page_CurveTo3()</span><br><span class="line">HPDF_Page_LineTo()</span><br><span class="line">HPDF_Page_MoveTo()</span><br><span class="line">HPDF_Page_Rectangle()</span><br></pre></td></tr></table></figure>

<p><strong>Path Painting</strong>操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HPDF_Page_ClosePathFillStroke()</span><br><span class="line">HPDF_Page_ClosePathEofillStroke()</span><br><span class="line">HPDF_Page_ClosePathStroke()</span><br><span class="line">HPDF_Page_Eofill()</span><br><span class="line">HPDF_Page_EofillStroke()</span><br><span class="line">HPDF_Page_EndPath()</span><br><span class="line">HPDF_Page_Fill()</span><br><span class="line">HPDF_Page_FillStroke()</span><br><span class="line">HPDF_Page_Stroke()</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<p>​	简单说就是在description状态下调用绘图函数(Path Construction)进入绘图状态，调用绘图结束函数Path Painting)结束绘图；调用HPDF_Page_BeginText()进入文字绘制状态，调用HPDF_Page_EndText()退出文字绘制状态。</p>
<p>​	特别注意绘制状态，刚接触很容易碰到绘制状态不对导致的绘制函数调用错误（错误码0x1051）</p>
</li>
<li><p><strong>图形绘制</strong></p>
<p>​		大部分功能和windows的gdi绘制差不多，有stoke和fill相关的设置；有绘制line&#x2F;rectangle&#x2F;triangle&#x2F;cricle等等，方法也都类似。</p>
<ul>
<li><p><strong>HPDF_Page_Stroke</strong>  绘制路径</p>
</li>
<li><p>**HPDF_Page_FillStroke  **填充路径</p>
</li>
<li><p><strong>HPDF_Page_ClosePathFillStroke</strong> 封闭路径并且填充</p>
</li>
<li><p><strong>HPDF_Page_ClosePathStroke</strong> 封闭路径然后绘制路径</p>
</li>
<li><p><strong>HPDF_Page_EndPath</strong> 指示路径结束</p>
</li>
<li><p><strong>HPDF_Page_SetRGBFill</strong> 设置填充颜色</p>
</li>
<li><p><strong>HPDF_Page_SetRGBStroke</strong> 设置描边颜色</p>
</li>
<li><p><strong>HPDF_Page_SetRGBFill</strong> 设置填充灰度颜色</p>
</li>
<li><p><strong>HPDF_Page_SetGrayStroke</strong> 设置描边灰度颜色</p>
</li>
</ul>
</li>
<li><p><strong>高级绘制功能</strong></p>
<p>libharu提供了extgstate相关的函数，可以控制透明度、混合模式，具体实现在hpdf_ext_gstate.c，示例代码：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HPDF_Page_GSave (page);</span><br><span class="line">gstate = HPDF_CreateExtGState (pdf);</span><br><span class="line">HPDF_ExtGState_SetAlphaFill (gstate, 0.8);</span><br><span class="line">HPDF_ExtGState_SetAlphaStroke (gstate, 0.8);</span><br><span class="line">HPDF_Page_SetExtGState (page, gstate);</span><br><span class="line">draw_circles (page, &quot;alpha fill = 0.8&quot;, 230.0f, PAGE_HEIGHT - 170);</span><br><span class="line">HPDF_Page_GRestore (page);</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>文字绘制</strong></p>
<p>​	绘制文字接口有HPDF_Page_ShowText()、TextOut()、TextRect()、ShowTextNextLine()等接口。关于文字绘制，需要注意的地方：</p>
<ul>
<li><p>位置属性的更新。比如我们要在指定位置绘制文字，可以用TextOut()方法指定posx&#x2F;posy绘制，也可以用ShowText()方法。使用ShowText()方法要注意，需要先定位好位置，也就是调用HPDF_Page_MoveTextPos()方法，此方法的参数x&#x2F;y是相对当前未知的偏移，这个特别要注意。另外，当你在同一行用MoveTextPos()在x轴偏移了，然后当你想换行在最左开始绘制新的文字，这时候要注意了，需要将位置重定位到x&#x3D;0的位置，而MoveTextPos()方法是偏移相对位置。</p>
</li>
<li><p>中英文汉字绘制问题。需要设置字体和编码，字体用GB-EUC-H编码，文字用GBK可以。</p>
<ul>
<li><strong>GB编码支持</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HPDF_Font font = HPDF_GetFont(pdf, fontName, &quot;GB-EUC-H&quot;);</span><br><span class="line">HPDF_REAL size = 32;</span><br><span class="line">HPDF_Page_SetFontAndSize(page, font, size);</span><br></pre></td></tr></table></figure>

<p>注意，需要在之前调用HPDF_UseCNSEncodings(pdf);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HPDF_UseCNSFonts(pdf);</span><br><span class="line">HPDF_UseCNSEncodings(pdf);</span><br></pre></td></tr></table></figure>

<p>​		GB-EUC-H支持GB2312简体中文编码，实现文件在hpdf_encoder_cns.c，可以看看文件中的GB_EUC_IsLeadByte函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static HPDF_BOOL</span><br><span class="line">GB_EUC_IsLeadByte (HPDF_Encoder encoder, HPDF_BYTE b)</span><br><span class="line">&#123;</span><br><span class="line">  HPDF_UNUSED (encoder);</span><br><span class="line">  return (b &gt;= 0xa1 &amp;&amp; b &lt;= 0xfe);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		可以看出这个是简单的判断是否是GB2312 汉字的首字节编码范围。</p>
<ul>
<li><strong>UTF8支持</strong></li>
</ul>
<p>	</p>
<p>GB-EUC-H不支持多国语言，想要更通用的多国语言支持，建议使用UTF8编码。调用HPDF_UseUTFEncodings来开启UTF8编码的支持，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HPDF_EXPORT(HPDF_STATUS) HPDF_UseUTFEncodings(HPDF_Doc pdf)</span><br></pre></td></tr></table></figure>

<p>​		libharu对于utf8的支持在hpdf_encoder_utf.c文件实现，主要有下面几个函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static HPDF_ByteType UTF8_Encoder_ByteType_Func (HPDF_Encoder encoder, HPDF_ParseText_Rec  *state);</span><br><span class="line"></span><br><span class="line">static HPDF_UNICODE UTF8_Encoder_ToUnicode_Func(HPDF_Encoder  encoder,         HPDF_UINT16 code);</span><br></pre></td></tr></table></figure>

<p>​		这里主要是完成utf8-&gt;unicode的编码转换，其中UTF8_Encoder_ByteType_Func用于获取utf8字符串的字符个数（不是字节）；UTF8_Encoder_ToUnicode_Func用于将utf8编码的字符串转为unicode字符串。这里没有用第三方库进行编码转换，直接跟进UTF8编码规则，完成UTF和Unicode的编码拆组。</p>
</li>
<li><p><strong>文字高级渲染</strong></p>
<ul>
<li><p>HPDF_Page_SetTextMatrix</p>
<p>控制文字变换矩阵。</p>
<p>例如： </p>
<p><strong>旋转矩阵</strong>：		</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a  b  0 </span><br><span class="line">c  d  0 </span><br><span class="line">0  0  1</span><br><span class="line"></span><br><span class="line">a = cos(θ)</span><br><span class="line">b = -sin(θ)</span><br><span class="line">c = sin(θ)</span><br><span class="line">d = cos(θ)</span><br></pre></td></tr></table></figure>

<p><strong>斜切矩阵：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1           tan(α)  0 </span><br><span class="line">tan(β)      1       0 </span><br><span class="line">0           0       1</span><br></pre></td></tr></table></figure>

<p><strong>缩放：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2  0  0</span><br><span class="line">0  2  0</span><br><span class="line">0  0  1</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>HPDF_Page_SetCharSpace</strong></p>
<p>设置字符间距</p>
</li>
<li><p><strong>HPDF_Page_SetWordSpace</strong></p>
<p>设置单词间距</p>
</li>
<li><p><strong>HPDF_Page_TextRect</strong></p>
<p>支持文字绘制的对齐模式设置</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>大纲绘制</strong>		</p>
<p>​		利用HPDF_CreateOutline函数可以创建树形大纲列表，HPDF_Outline_SetOpened函数可以设置大纲项打开状态，HPDF_Outline_SetDestination可以用于目标位置的关联。</p>
<ul>
<li><pre><code>HPDF_Outline HPDF_CreateOutline(HPDF_Doc pdf, 
            HPDF_Outline parent, 
            const char *title, 
            HPDF_Encoder encoder);
HPDF_STATUS HPDF_Outline_SetOpened  (HPDF_Outline outline, HPDF_BOOL opened)
HPDF_STATUS HPDF_Outline_SetDestination (HPDF_Outline outline, HPDF_Destination dst)
</code></pre>
</li>
</ul>
</li>
</ul>
<p>​		</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jerrywang2013.github.io/2024/05/11/%E7%94%A8libharu%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AA%E5%B0%8F%E4%BD%9C%E4%B8%9A/" data-id="clwbg5x4n000az44qe72ffg9u" data-title="用libharu完成一个小作业" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-宝塔面板ApacheServer配置" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/05/09/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BFApacheServer%E9%85%8D%E7%BD%AE/" class="article-date">
  <time class="dt-published" datetime="2024-05-09T06:31:22.000Z" itemprop="datePublished">2024-05-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/05/09/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BFApacheServer%E9%85%8D%E7%BD%AE/">宝塔面板ApacheServer配置</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>​	Windows + Apache2.4 + PHP7.4 + Mysql5.6</p>
<p>​	直接安装宝塔面板，然后通过宝塔面板安装Apache、PHP、Mysql即可。</p>
<h1 id="WebServer配置"><a href="#WebServer配置" class="headerlink" title="WebServer配置"></a>WebServer配置</h1><p>​	启动宝塔面板，进入宝塔控制后台，点击左侧菜单“网站”，点击“新建站点”，创建一个Web服务器，设置好域名、默认文档、伪静态、网站目录等，下面记录常见可能出问题的点。</p>
<ul>
<li><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>​	在网站设置里头，可以点击左侧“域名管理”来配置域名，域名形如：<a href="http://www.domain.com:port，可以指定端口，不显示指定端口默认就是80。">www.domain.com:port，可以指定端口，不显示指定端口默认就是80。</a></p>
<p>​	这里假设设置的域名是<a href="http://www.crm.com，端口80，这里对应的配置有两个地方：">www.crm.com，端口80，这里对应的配置有两个地方：</a></p>
<ul>
<li><p><strong>告诉apache监听端口</strong></p>
</li>
<li><p><strong>设置站点的VirtualHost配置</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​	需要注意的是，如果我们修改站点的域名映射，比如新加一个域名<a href="http://www.crm-mini.com:8090，宝塔面板会修改apache/conf/httpd.conf文件，在顶部增加Listen">www.crm-mini.com:8090，宝塔面板会修改apache/conf/httpd.conf文件，在顶部增加Listen</a> 8090。问题是这个操作不是可靠的，反复修改站点域名映射有时候就能发现Listen的端口混乱，所以如果发现修改配置后没效果，可以检查下httpd.conf文件配置，手动修改；</p>
<p>​	另外，同一个站点配置多个域名，不要用不同的端口，否则宝塔也会弄混淆，搞错监听端口。不同域名是通过在VirtualHost里头的ServerAlias来配置，例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerAlias www.crm-mini.com 127.0.0.1</span><br></pre></td></tr></table></figure>


</li>
<li><h3 id="伪静态"><a href="#伪静态" class="headerlink" title="伪静态"></a>伪静态</h3><p>​	伪静态是利用url重写技术，实现类似静态url的效果，本质是url rewrite。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mod_rewrite.c&gt;</span><br><span class="line"> RewriteEngine on</span><br><span class="line"> RewriteBase /</span><br><span class="line"> RewriteCond %&#123;REQUEST_FILENAME&#125; !-d</span><br><span class="line"> RewriteCond %&#123;REQUEST_FILENAME&#125; !-f</span><br><span class="line"> RewriteRule ^(.*)$ index.php?s=/$1 [QSA,PT,L]</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure>

<p>​	在web服务器的根目录的.htaccess文件中加入上述伪静态指令，当请求<a target="_blank" rel="noopener" href="http://doamin.com/aaa%E4%BC%9A%E5%B0%86%E8%AE%BF%E9%97%AE%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0index.php/s=aaa%EF%BC%88%E5%BD%93aaa%E4%B8%8D%E6%98%AF%E6%96%87%E4%BB%B6%E6%88%96%E8%80%85%E7%9B%AE%E5%BD%95%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%89">http://doamin.com/aaa会将访问重定向到index.php/s=aaa（当aaa不是文件或者目录的情况下）</a></p>
<p>​	利用mod_rewrite功能，我们可以定义一些规则做请求的重定向。</p>
</li>
<li><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><ul>
<li><p><strong>Rewrite url</strong></p>
<p>​		宝塔面板的重定向也是配置RewriteRule，尝试将&#x2F;crm的请求映射到另外一个web站点失败。</p>
<p>例如：有两个站点 <a target="_blank" rel="noopener" href="http://www.crm-mini.com/">http://www.crm-mini.com</a> 和  <a target="_blank" rel="noopener" href="http://www.crm-normal.com对应本地的两个web目录,现在想只通过http//www.crm-mini.com%E4%B8%80%E4%B8%AA%E5%85%A5%E5%8F%A3%E8%AE%BF%E9%97%AE%E4%B8%A4%E4%B8%AAweb%E7%9B%AE%E5%BD%95%EF%BC%8C%E6%AF%94%E5%A6%82http://www.crm-mini.com/normal/%E8%87%AA%E5%8A%A8%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0crm-normal%E7%9B%AE%E5%BD%95">http://www.crm-normal.com对应本地的两个web目录，现在想只通过http://www.crm-mini.com一个入口访问两个web目录，比如http://www.crm-mini.com/normal/自动重定向到crm-normal目录</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mod_rewrite.c&gt;</span><br><span class="line"> RewriteEngine on</span><br><span class="line"> RewriteRule ^crm(.*)$ http://www.crm-normal.com/$1 [L,R=301]</span><br><span class="line"></span><br><span class="line"> RewriteBase /</span><br><span class="line"> RewriteCond %&#123;REQUEST_FILENAME&#125; !-d</span><br><span class="line"> RewriteCond %&#123;REQUEST_FILENAME&#125; !-f</span><br><span class="line"> RewriteRule ^(.*)$ index.php?s=/$1 [QSA,PT,L]</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure>

<p>​		注意上述第三行，碰到dowmain&#x2F;后面接着是crm就跳转到<a href="http://www.crm-normal.com。`[L,R=301]`">http://www.crm-normal.com。`[L,R=301]`</a> 则指示 Apache 使用 301 永久重定向，L表示停止进一步的重写规则匹配。</p>
</li>
<li><p><strong>Alias</strong></p>
<p>​	用到的一种另外实现方法是在VirtualHost中配置Alias</p>
<pre><code>&lt;VirtualHost *:80&gt;
    ServerAdmin webmaster@yourdomain.com
    DocumentRoot &quot;/var/www/html&quot;
    ServerName www.yourdomain.com
    # 配置针对 crm-normal 的请求
    Alias &quot;/crm-normal&quot; &quot;/var/www/html/crm-normal&quot;
    &lt;Directory &quot;/var/www/html/crm-normal&quot;&gt;
        Options Indexes FollowSymLinks
        AllowOverride All
        Require all granted
    &lt;/Directory&gt;

    # 配置针对 crm-mini 的请求
    Alias &quot;/crm-mini&quot; &quot;/var/www/html/crm-mini&quot;
    &lt;Directory &quot;/var/www/html/crm-mini&quot;&gt;
        Options Indexes FollowSymLinks
        AllowOverride All
        Require all granted
    &lt;/Directory&gt;

    ErrorLog &quot;/var/log/apache2/yourdomain-error.log&quot;
    CustomLog &quot;/var/log/apache2/yourdomain-access.log&quot; combined
&lt;/VirtualHost&gt;
</code></pre>
<p>​		这样配置后，当访问 <code>http://www.yourdomain.com/crm-normal</code> 时，会展示 <code>crm-normal</code> 站点的内容，而访问 <code>http://www.yourdomain.com/crm-mini</code> 则会展示 <code>crm-mini</code> 站点的内容。</p>
<p>​	</p>
<p>重定向能解决只用一个域名一个端口绑定多个web站点，无需每个域名对应一个站点。</p>
</li>
</ul>
</li>
<li></li>
</ul>
<p>​	</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jerrywang2013.github.io/2024/05/09/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BFApacheServer%E9%85%8D%E7%BD%AE/" data-id="clwbg5x4n0009z44q663wfnwo" data-title="宝塔面板ApacheServer配置" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-vscode调试php" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/05/07/vscode%E8%B0%83%E8%AF%95php/" class="article-date">
  <time class="dt-published" datetime="2024-05-07T07:04:35.000Z" itemprop="datePublished">2024-05-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/05/07/vscode%E8%B0%83%E8%AF%95php/">vscode调试php</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><ul>
<li><p>已经安装apache、php（本地测试是用的宝塔面板批量安装的apache2.4以及php7.4)</p>
</li>
<li><p>已经安装vscode（测试安装的是vscode v1.87.0)</p>
</li>
<li><p>安装xdebug。vscode调试借助于xdebug，确保你的php已经安装了此插件，如果没有安装，可以去下载php_xdebug.dll，将其放入到php的ext目录。</p>
</li>
<li><p>vscode安装php debug插件（xdebug.org出品）</p>
</li>
</ul>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ul>
<li><p>在php中配置xdebug</p>
<p>​		打开php.ini文件，假如如下配置，注意端口配置项要和后面项目调试配置json文件中的端口保持一致；最后一行xdebug.remote_autostart&#x3D;1要加上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[XDebug]</span><br><span class="line"></span><br><span class="line">xdebug.profiler_append = 0</span><br><span class="line"></span><br><span class="line">xdebug.profiler_enable = 1</span><br><span class="line"></span><br><span class="line">xdebug.profiler_enable_trigger = 0</span><br><span class="line"></span><br><span class="line">xdebug.profiler_output_dir =&quot;D:\BtSoft\temp\xdebug&quot;</span><br><span class="line"></span><br><span class="line">xdebug.trace_output_dir =&quot;D:\BtSoft\temp\xdebug&quot;</span><br><span class="line"></span><br><span class="line">xdebug.profiler_output_name = &quot;cache.out.%t-%s&quot;</span><br><span class="line"></span><br><span class="line">xdebug.remote_enable = 1</span><br><span class="line"></span><br><span class="line">xdebug.remote_handler = &quot;dbgp&quot;</span><br><span class="line"></span><br><span class="line">xdebug.remote_host = &quot;127.0.0.1&quot;</span><br><span class="line"></span><br><span class="line">xdebug.remote_port = 9999</span><br><span class="line"></span><br><span class="line">zend_extension=php_xdebug.dll</span><br><span class="line"></span><br><span class="line">xdebug.remote_autostart = 1</span><br></pre></td></tr></table></figure>


</li>
<li><p>配置php项目</p>
<p>​	打开php项目，点击调试php，生成项目配置文件.vscode&#x2F;launch.json</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&quot;configurations&quot;: [</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      &quot;name&quot;: &quot;Listen for Xdebug&quot;,</span><br><span class="line"></span><br><span class="line">​      &quot;type&quot;: &quot;php&quot;,</span><br><span class="line"></span><br><span class="line">​      &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line"></span><br><span class="line">​      &quot;port&quot;: 9999,</span><br><span class="line"></span><br><span class="line">​      &quot;xdebugSettings&quot;: &#123;</span><br><span class="line"></span><br><span class="line">​        &quot;max_data&quot;: 10240</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​    &#125;,</span><br></pre></td></tr></table></figure>

<p>​		这里这里的port要和php.ini中配置xdebug的debug监听端口保持一致</p>
<p>​	</p>
<p>​	到此就可以愉快的断点、单步了！</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jerrywang2013.github.io/2024/05/07/vscode%E8%B0%83%E8%AF%95php/" data-id="clwbg5x4m0007z44q41aabiul" data-title="vscode调试php" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-libevent" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/05/05/libevent/" class="article-date">
  <time class="dt-published" datetime="2024-05-05T14:54:09.000Z" itemprop="datePublished">2024-05-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/05/05/libevent/">libevent</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>libevent是一个跨平台高效的异步网络库，支持各平台最高效的异步模型，例如epoll和iocp。</p>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><ul>
<li><p><strong>设置debug级别日志记录策略</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void event_enable_debug_logging(ev_uint32_t which)</span><br></pre></td></tr></table></figure>

<p>描述：</p>
<p>说明： which可为 EVENT_DBG_NONE 和 EVENT_DBG_ALL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define EVENT_DBG_NONE 0</span><br><span class="line"></span><br><span class="line">#define EVENT_DBG_ALL 0xffffffffu</span><br></pre></td></tr></table></figure>

<p>注意：设置为EVENT_DBG_NONE仍可用event_warn(“&#x3D;”);输出日志，因为此函数只控制debug级别的日志策略。</p>
</li>
<li><p><strong>设置自定义日志handler</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef void (*event_log_cb)(int severity, const char *msg);</span><br><span class="line">void event_set_log_callback(event_log_cb cb)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>设置自定义fatal日志handler</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef void (*event_fatal_cb)(int err);</span><br><span class="line">void event_set_fatal_callback(event_fatal_cb cb)</span><br></pre></td></tr></table></figure>

<p>说明：默认libevent检测到不可恢复的内部错误默认行为是调用abort()或者exit()结束当前的进场，你也可以自定义处理致命错误。</p>
</li>
</ul>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>自定义内存分配&#x2F;释放函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void event_set_mem_functions(void *(*malloc_fn)(size_t sz),</span><br><span class="line">                             void *(*realloc_fn)(void *ptr, size_t sz),</span><br><span class="line">                             void (*free_fn)(void *ptr));</span><br></pre></td></tr></table></figure>

<p>说明：比如可以自定义malloc等来实现更加安全的内存管理函数</p>
<h1 id="锁和线程"><a href="#锁和线程" class="headerlink" title="锁和线程"></a>锁和线程</h1><p>Libevent 结构通常可以通过三种方式处理多线程。</p>
<ul>
<li>有些结构本质上是单线程的：同时从多个线程使用它们永远是不安全的。</li>
<li>有些结构可以选择锁定：您可以告诉 Libevent 对于每个对象是否需要同时从多个线程使用它。</li>
<li>有些结构始终是锁定的：如果 Libevent 在锁定支持下运行，那么它们始终可以安全地同时从多个线程使用。</li>
</ul>
<p>​	可以使用windows thread和posix thread，在windows平台，也是可以选择默认的os thread或者pthread。另外还可以使用自定义的线程库，写好自己的内存管理以及同步函数后，需要注册之：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int evthread_set_lock_callbacks(const struct evthread_lock_callbacks *);</span><br><span class="line">void evthread_set_id_callback(unsigned long (*id_fn)(void));</span><br><span class="line">int evthread_set_condition_callbacks(const struct evthread_condition_callbacks *);</span><br></pre></td></tr></table></figure>

<p>​		上述的自定义线程库注册这种c的代码风格你可以理解为面向对象的的接口重写，比如IThread接口定义了create() &#x2F; destroy() &#x2F; lock() &#x2F; unlock()，自定义Thread库需要实现IThread的功能接口。</p>
<h1 id="Event使用"><a href="#Event使用" class="headerlink" title="Event使用"></a>Event使用</h1><h3 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h3><p>​	libevent的event代表一组条件，包括：</p>
<h3 id="事件标志"><a href="#事件标志" class="headerlink" title="事件标志"></a>事件标志</h3><ul>
<li><p>EV_TIMEOUT</p>
<p>​	构造事件的时候EV_TIMEOUT会被忽略，需要在event_add()中设置操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ev1 = event_new(base, 0, EV_TIMEOUT|EV_PERSIST, cb_func,(char*)&quot;Reading event&quot;);</span><br><span class="line">struct timeval tv;</span><br><span class="line">tv.tv_sec = 5;</span><br><span class="line">tv.tv_usec = 0;</span><br><span class="line">event_add(timeout_event, &amp;tv); </span><br></pre></td></tr></table></figure>

<p>相关函数或者宏：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">evtimer_assign(ev, b, cb, arg)</span><br><span class="line">evtimer_new(b, cb, arg)	</span><br><span class="line">evtimer_add(ev, tv)</span><br><span class="line">evtimer_del(ev)</span><br><span class="line">evtimer_pending(ev, tv)</span><br><span class="line">evtimer_initialized(ev)</span><br></pre></td></tr></table></figure>


</li>
<li><p>EV_READ</p>
</li>
<li><p>EV_WRITE</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE); </span><br><span class="line">bufferevent_setcb(bev, conn_readcb, conn_writecb, conn_eventcb, NULL);</span><br><span class="line">bufferevent_enable(bev, EV_READ | EV_WRITE);</span><br></pre></td></tr></table></figure>
</li>
<li><p>EV_SIGNAL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">signal_event = evsignal_new(base, SIGINT, signal_cb, (void *)base);</span><br><span class="line">event_add(signal_event, NULL)</span><br></pre></td></tr></table></figure>

<p>相关函数或者宏：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">evsignal_add(ev, tv)</span><br><span class="line">evsignal_assign(ev, b, x, cb, arg)</span><br><span class="line">evsignal_new(b, x, cb, arg)</span><br><span class="line">evsignal_del(ev)</span><br><span class="line">evsignal_pending(ev, tv)</span><br><span class="line">evsignal_initialized(ev)</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>​		对于大多数后端来说，每个进程只有一个event_base可以监听信号，如果同时向多个event_base添加信号事件，即便信号不同，也只有一个event_base会收到新招。kqueeue后端没有此限制。</p>
</li>
<li><p>用户触发事件</p>
<p>所谓的用户事件就是不与预定义那些事件关联，一般我们把event_new()参数的event参数设置为0即可。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct event_base *base = event_base_new(); </span><br><span class="line">struct event *user_event = event_new(base, -1, 0, user_event_cb, NULL); </span><br><span class="line">event_add(user_event, NULL); </span><br><span class="line">event_active(user_event, EV_WRITE, 0);  // 触发用户事件 </span><br><span class="line">event_base_dispatch(base);</span><br><span class="line">event_free(user_event);</span><br><span class="line">event_base_free(base); </span><br></pre></td></tr></table></figure>

<p>相关函数或者宏：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">evuser_new(b, cb, arg)</span><br><span class="line">evuser_del(ev)</span><br><span class="line">evuser_pending(ev, tv)</span><br><span class="line">evuser_initialized(ev)</span><br><span class="line">evuser_trigger(ev)	</span><br></pre></td></tr></table></figure>


</li>
<li><p>EV_PERSIST</p>
<p>​		通常情况下，当事件被激活后，它会被移除并在回调函数中处理。但是，如果事件被设置了 <code>EV_PERSIST</code> 标志，那么即使在回调函数中处理后，它仍然会留在事件循环中，并等待下一次相同类型的事件发生。使用 <code>EV_PERSIST</code> 标志的事件通常用于需要持续监听某种类型事件的场景，例如长期监听套接字的可读、可写事件等。</p>
</li>
</ul>
<h3 id="event-self-cbarg"><a href="#event-self-cbarg" class="headerlink" title="event_self_cbarg()"></a>event_self_cbarg()</h3><p>​		这个函数是libevent预定义的一个函数，用于返回一个magic指针，告诉event_new创建一个接受自己作为回调函数参数的event。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ev = event_new(base, -1, EV_PERSIST, cb_func, event_self_cbarg());</span><br></pre></td></tr></table></figure>

<p>此函数创建一个event，并且让事件触发的时候执行cb_func()时，将ev参数传给cb_func()。因为调用者调用event_new()时对象还不存在，这里用event_self_cbarg()原理也很简单，相当于给传一个flag告知event_new()。</p>
<h3 id="事件待处理-非待处理"><a href="#事件待处理-非待处理" class="headerlink" title="事件待处理&#x2F;非待处理"></a>事件待处理&#x2F;非待处理</h3><p>​		事件被创建后，不会执行任何操作，直到你通过event_add()将其处于挂起状态。</p>
<ul>
<li><p>event_add</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int event_add(struct event *ev, const struct timeval *tv);</span><br></pre></td></tr></table></figure>

<p>​		对于已挂起的事件调用event_add()，会将其保持挂起状态，并使用提供的超时重新设置。如果事件已经挂起，然后使用超时NULL重新设置它，则event_add()不起作用。</p>
</li>
<li><p>event_del</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int event_del(struct event *ev);</span><br></pre></td></tr></table></figure>

<p>​		event_del会使得事件变为非挂起 、非活动状态。如果event本来是非挂起非激活状态，调用event_del没有效果。</p>
</li>
<li><p>event_remove_timer</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int event_remove_timer(struct event *ev);</span><br></pre></td></tr></table></figure>

<p>​		删除挂起事件的超时，而无需删除事件的IO或者信号组件。如果event没有超时挂起，则event_remove_timer()无效。如果event只有超时但没有IO或者信号组件，则event_remove_timer()和event_del()效果一样。</p>
</li>
</ul>
<h3 id="event优先级"><a href="#event优先级" class="headerlink" title="event优先级"></a>event优先级</h3><ul>
<li><p>event_priority_set</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int event_priority_set(struct event *event, int priority);</span><br></pre></td></tr></table></figure>

<p>​		priority是0-1的数字。当多个事件变为活动状态时，低优先级的不会运行。libevent会运行高优先级事件，然后再次检测事件，只有没有高优先级事件处于活动状态时，低优先级事件才会运行。</p>
</li>
</ul>
<h3 id="检测事件状态"><a href="#检测事件状态" class="headerlink" title="检测事件状态"></a>检测事件状态</h3><ul>
<li><p>常用接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int event_pending(const struct event *ev, short what, struct timeval *tv_out);</span><br><span class="line"></span><br><span class="line">#define event_get_signal(ev) /* ... */</span><br><span class="line">evutil_socket_t event_get_fd(const struct event *ev);</span><br><span class="line">struct event_base *event_get_base(const struct event *ev);</span><br><span class="line">short event_get_events(const struct event *ev);</span><br><span class="line">event_callback_fn event_get_callback(const struct event *ev);</span><br><span class="line">void *event_get_callback_arg(const struct event *ev);</span><br><span class="line">int event_get_priority(const struct event *ev);</span><br><span class="line"></span><br><span class="line">void event_get_assignment(const struct event *event,</span><br><span class="line">        struct event_base **base_out,</span><br><span class="line">        evutil_socket_t *fd_out,</span><br><span class="line">        short *events_out,</span><br><span class="line">        event_callback_fn *callback_out,</span><br><span class="line">        void **arg_out);</span><br><span class="line">struct event *event_base_get_running_event(struct event_base *base);</span><br></pre></td></tr></table></figure>

<p>event_pending()： 判断event是待处理还是活动的。</p>
<p>event_get_fd()&#x2F;event_get_signal()： 返回event的描述符或者信号</p>
<p>event_get_base(): 返回event的event_base</p>
<p>event_get_events(): 返回event的时间标记(EV_READ&#x2F;EV_WRITE等)</p>
<p>event_get_callback(): 返回callback函数</p>
<p>event_get_callback_arg(): 返回回调函数参数指针</p>
<p>event_get_priority(): 返回event优先级</p>
<p>event_base_get_running_event(): 获得指向当前正在运行的event指针</p>
</li>
</ul>
<h3 id="配置一次性事件"><a href="#配置一次性事件" class="headerlink" title="配置一次性事件"></a>配置一次性事件</h3><ul>
<li><p>event_base_once()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int event_base_once(struct event_base *, evutil_socket_t, short,</span><br><span class="line">  void (*)(evutil_socket_t, short, void *), void *, const struct timeval *);</span><br></pre></td></tr></table></figure>

<p>​		参数和event_new()类似，只不过它不支持EV_SIGNAL和EV_PERSIST。在回调完成后，libevent会释放event结构。event_base_once()插入的事件无法删除或者手动激活；如果想取消event，只能使用常规的event_new()或者event_assign()创建。</p>
</li>
</ul>
<h3 id="手动激活"><a href="#手动激活" class="headerlink" title="手动激活"></a>手动激活</h3><ul>
<li><p>event_active</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void event_active(struct event *ev, int what, short ncalls);</span><br></pre></td></tr></table></figure>

<p>​		手动激活的事件不需要先处于挂起状态，并且激活它也不会使其处于挂起状态。</p>
</li>
</ul>
<h3 id="定时器事件优化"><a href="#定时器事件优化" class="headerlink" title="定时器事件优化"></a>定时器事件优化</h3><p><strong>公共超时</strong></p>
<p>​		Libevent 使用二进制堆算法来跟踪待处理事件的超时。二叉堆为添加和删除每个事件超时提供了 O(lg n) 阶的性能。如果您要添加具有随机分布的超时值集的事件，则这是最佳选择，但如果您有大量具有相同超时值的事件，则这不是最佳选择。</p>
<p>例如，假设您有一万个事件，每个事件都应在添加后五秒触发超时。在这种情况下，通过使用双链接队列实现，您可以在每次超时时获得 O(1) 性能。</p>
<p>当然，您不会希望对所有超时值使用队列，因为队列仅对于恒定超时值更快。如果某些超时或多或少是随机分布的，那么将其中一个超时添加到队列将花费 O(n) 时间，这比二进制堆要糟糕得多。</p>
<p>Libevent 可以让您通过将一些超时放入队列中，将其他超时放入二进制堆中来解决此问题。为此，您需要向 Libevent 请求一个特殊的“公共超时”时间值，然后使用该时间值添加具有该时间值的事件。如果您有大量具有单个公共超时的事件，则使用此优化应该可以提高超时性能。</p>
<ul>
<li><strong>TODO 这块得研究一下</strong></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jerrywang2013.github.io/2024/05/05/libevent/" data-id="clwbg5x4m0006z44qf23gch0w" data-title="libevent" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-windows网络编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/05/01/windows%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2024-05-01T09:42:08.000Z" itemprop="datePublished">2024-05-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/05/01/windows%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">windows网络编程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="网络常见知识"><a href="#网络常见知识" class="headerlink" title="网络常见知识"></a>网络常见知识</h1><ul>
<li><h2 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h2><p>​	一般用于指示多字节数据存储方式。</p>
<ul>
<li><p>​	<strong>大端（Little Endian)：</strong> 高位字节（MSB）存储在起始地址，低位字节（LSB）存储在结束地址。换句话说：数据的高位存储在内存的低地址处，低位字节存储在高地址处。</p>
</li>
<li><p>​	<strong>小端（Little Endian)：</strong> 和大端相反。</p>
<p>举例：假设一个32位整数<code>num</code>，其十六进制表示为 **<code>0x12345678</code>**，在内存中存储如下：</p>
<p><strong>大端字节序</strong>：存储方式为<code>**12 34 56 78**</code></p>
<p><strong>小端字节序：</strong>存储方式为<code>**78 56 34 12**</code></p>
</li>
</ul>
</li>
</ul>
<h1 id="重要函数"><a href="#重要函数" class="headerlink" title="重要函数"></a>重要函数</h1><ul>
<li><p><strong>WSAGetLastError</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">WSAGetLastError</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p><strong>描述：</strong>获取WinSocket函数调用的错误码</p>
<p><strong>说明：</strong>WinSocket错误码定义在winsocket2.h文件中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define WSABASEERR              10000</span><br></pre></td></tr></table></figure>

<p>​		错误码基础偏移是WSABASEERR，通过WSAGetLastError()获取到的错误码可以直接通过VS自带的错误查找工具查找对应错误码的信息。</p>
</li>
<li><p><strong>WSAStartup</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">WSAStartup</span><span class="params">(wVersion,  &amp;wsadata)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>描述：</strong>初始化WinSocket库</p>
<p><strong>说明：</strong></p>
<p>​		应作为Socket库首个函数被调用。wVersion指定winsocket库版本。此函数直接返回错误码（0表示正常），无需额外调用WSAGetLastError()获取错误码。</p>
</li>
<li><p><strong>WSACleanup</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">WSACleanup</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p><strong>描述：</strong>终于使用Winsock2 DLL(ws2_32.dll)</p>
<p><strong>返回值：</strong>成功返回0，否则返回SOCKET_ERROR</p>
<p><strong>说明：</strong></p>
<p>​		失败时可以调用WSAGetLastError获取错误码。在多线程环境下，WSACleanup调用会终止所有线程的Windows套接字操作。</p>
</li>
<li><p><strong>socket</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SOCKET <span class="title">socket</span><span class="params">(<span class="type">int</span> af, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>描述：</strong>创建套接字**</p>
<p><strong>返回值：</strong></p>
<p>​		如果没有错误会返回新创建的套接字描述符（整数），否则返回INVALID_SOCKET，并且可以调用WSAGetLastError()获取错误。</p>
<p><strong>说明：</strong></p>
<p>​	af： 地址家族，常见的有<strong>AF_INET</strong>（IPV4）、 <strong>AF_INET6</strong>（IPV6）</p>
<p>​	type: 套接字类型，常见有<strong>SOCK_STREAM</strong>、<strong>SOCK_DGRAM</strong>、<strong>SOCK_RAW</strong>(原始套接字)</p>
<p>​	protocol：协议，常见有<strong>IPPROTO_TCP</strong>、**IPPROTO_UDP</p>
</li>
<li><p><strong>bind</strong> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(SOCKET s, <span class="type">const</span> sockaddr *addr, <span class="type">int</span> namelen)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>描述：</strong>socket绑定地址</p>
<p><strong>返回值：</strong>如果没有错误，返回0；否则返回SOCKET_ERROR；</p>
<p><strong>说明：</strong></p>
<ul>
<li><p>如果不指定IP，可以使用INADDR_ANY（IPV4）或者in6addr_any（IPV6）</p>
</li>
<li><p>如果指定端口为0，则自动选择一个可用的动态端口（vista之后系统动态端口区间49152 - 65535）。</p>
</li>
<li><p>注意sockaddr结构会根据所选协议不同而不同的。比如IPV4，我们使用的是sockaddr_in； IPV6我们使用的是sockaddr_in6</p>
</li>
<li><p>bind之后可以用getsockname来获取分配给套接字的地址和端口。如果指定绑定IP是INADDR_ANY，则在连接建立之前getsockname不一定提供地址，因为如果主机是多宿主，可能有多个地址。客户端程序一般指定port为0避免端口冲突。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// bind  and listen</span><br><span class="line">SOCKADDR_IN serverAddr;</span><br><span class="line">serverAddr.sin_family = AF_INET;</span><br><span class="line">serverAddr.sin_addr.S_un.S_addr = htonl(INADDR_ANY);</span><br><span class="line">serverAddr.sin_port = htons(8889);</span><br><span class="line">ret = bind(listen_socket, (const sockaddr*)&amp;serverAddr, sizeof(serverAddr));</span><br><span class="line">if (SOCKET_ERROR == ret) &#123;</span><br><span class="line">	Helper::log(&quot;bind listen socket failed with error:%d\n&quot;, WSAGetLastError());</span><br><span class="line">	closesocket(listen_socket);</span><br><span class="line">	WSACleanup();</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">SOCKADDR_IN bind_addr;</span><br><span class="line">int bind_addr_len = sizeof(bind_addr);</span><br><span class="line">ret = getsockname(listen_socket, (sockaddr*)&amp;bind_addr, &amp;bind_addr_len);</span><br><span class="line">if (SOCKET_ERROR == ret) &#123;</span><br><span class="line">	Helper::log(&quot;get listen socket bind addr failed with error:%d\n&quot;, WSAGetLastError());</span><br><span class="line">	closesocket(listen_socket);</span><br><span class="line">	WSACleanup();</span><br><span class="line">	return false;</span><br><span class="line"></span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>listen</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int listen(SOCKET s, int backlog)</span><br></pre></td></tr></table></figure>

<p><strong>描述：</strong>将套接字设置为监听模式。</p>
<p><strong>返回值：</strong>成功返回0，失败返回SOCKET_ERROR。</p>
<p><strong>说明：</strong></p>
<p>​		backlog是后台等待连接队列。将套接字设置为监听模式后，os会维护等待连接队列，这个参数指定了此队列长度。当有客户尝试连接时，如果等待连接队列已满，则客户端可能收到连接被拒绝的错误。</p>
<p>​		距离说明如果设置了backlog为2，有两个客户端连接服务器，服务器暂时还没有处理客户端的连接（就是没有accept），如果这时候再来第三个客户端连接就会出现连接被拒绝。</p>
<p>​		</p>
</li>
<li><p><strong>accept</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SOCKET accept(SOCKET s, sockaddr *addr, int *addrlen)</span><br></pre></td></tr></table></figure>

<p><strong>描述：</strong>在套接字上进行连接操作</p>
<p><strong>返回值</strong>：如果没有错误，返回新建连接的SOCKET；否则返回INVALID_SOCKET。</p>
<p><strong>说明：</strong></p>
<ul>
<li><p>accept会一直阻塞直到有客户连接的到来；</p>
</li>
<li><p>addr返回的是新建连接的客户地址信息，可以用inet_ntop将IPV4&#x2F;6的网络地址(sockaddr.sin_addr)转为internet标准格式字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char ipstr[INET_ADDRSTRLEN] = &#123; 0 &#125;;</span><br><span class="line">inet_ntop(AF_INET, &amp;(clientAddr.sin_addr), ipstr, sizeof(ipstr));</span><br><span class="line">WORD port = ntohs(clientAddr.sin_port);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>send</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int send(SOCKET s, const char *buf, int len, int flags)</span><br></pre></td></tr></table></figure>

<p><strong>描述：</strong>在建立连接的套接字上发送数据</p>
<p><strong>返回值：</strong>如果没有错误，返回发送的总字节数，字节数可能小于请求发送的长度(len)；否则返回SOCKET_ERROR。</p>
<p><strong>说明：</strong></p>
<ul>
<li>发送函数成功完成并不表示数据传递并接收给，只是指示待发送数据已经成功写入套接字的发送缓冲区。</li>
<li>如果发送缓冲区没有空间，此函数会block；如果是非阻塞套接字，那么send会立刻返回，写入字节数取决于缓冲区可用性。</li>
<li>数据成功写入缓冲区后，操作系统会负责将数据通过网络发送给目标主机。</li>
</ul>
</li>
<li><p><strong>recv</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int recv(SOCKET s, char *buf, int len, int flags)</span><br></pre></td></tr></table></figure>

<p><strong>描述：</strong>从套接字上接收数据</p>
<p><strong>返回值：</strong>成功返回接收的字节数；失败返回SOCKET_ERROR。</p>
<p><strong>说明：</strong></p>
<ul>
<li><p>当套接字接收缓冲区没有数据的时候，recv调用会阻塞</p>
</li>
<li><p>当套接字接收缓冲区有数据的时候，recv会尝试将套接字缓冲区的内容拷贝到recv定义的用户缓冲区中，实际接收的数据和用户缓冲区buf大小以及套接字接收缓冲区数据的长度有关。</p>
</li>
<li><p>阻塞模式下，recv返回0意味着对方调用了closesocket或者shutdown关闭了连接。</p>
</li>
</ul>
</li>
<li><p><strong>shutdown</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int shutdown(SOCKET s, int how)</span><br></pre></td></tr></table></figure>

<p><strong>描述：</strong>关闭套接字的发送和接收</p>
<p><strong>返回值：</strong>成功返回0，失败返回SOCKET_ERROR</p>
<p><strong>说明：</strong></p>
<ul>
<li>how可选 SD_SEND | SD_RECEIVE | SD_BOTH</li>
<li>shutdown是关闭套接字功能；closesocket是关闭套接字功能，清理套接字资源</li>
</ul>
</li>
<li><p><strong>closesocket</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int closesocket(SOCKET s)</span><br></pre></td></tr></table></figure>

<p><strong>描述：</strong>关闭套接字</p>
<p><strong>返回值：</strong>成功返回0，失败返回SOCKET_ERROR</p>
<p><strong>说明：</strong></p>
<ul>
<li>可以结合linger选项来控制closesocket后的套接字接收发送行为</li>
</ul>
</li>
<li><p><strong>select</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const timeval *timeout)</span><br></pre></td></tr></table></figure>

<p><strong>描述：</strong>确定套接字状态，并在必要时等待执行同步IO</p>
<p>返回值：成功返回fd_set中已就绪的套接字数量；如果超时时间到，返回0；如果有错误，返回SOCKET_ERROR。</p>
<p><strong>说明：</strong></p>
<ul>
<li><p>nfds 参数已忽略。</p>
</li>
<li><p>如果用select查询套接字状态，需要将套接字设置为非阻塞。利用ioctlsocket设置套接字的IO模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unsigned long nonBlocking = 1;</span><br><span class="line"></span><br><span class="line">ioctlsocket(pSockInfo-&gt;sock, FIONBIO, &amp;nonBlocking)</span><br></pre></td></tr></table></figure>

<p>注意，WSAEventSelect和WSAAsyncSelect函数会自动将socket设置为NonBlock模式，无需手动设置。</p>
</li>
<li><p>放大</p>
</li>
</ul>
</li>
<li></li>
</ul>
<h1 id="套接字模式"><a href="#套接字模式" class="headerlink" title="套接字模式"></a>套接字模式</h1><ul>
<li><p>同步模式</p>
<p>​	默认行为，套接字的读写(包括accept)都是阻塞式的。</p>
</li>
<li><p>异步模式</p>
<p>​	套接字读写都是非阻塞的，可以通过ioctlsocket设置套接字为非阻塞。</p>
</li>
</ul>
<h1 id="常见IO模型"><a href="#常见IO模型" class="headerlink" title="常见IO模型"></a>常见IO模型</h1><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>​		类似unix的select模型，注意，windows下select最多支持64个套接字。可以使用WSAPoll。</p>
<h3 id="WSAAsyncSelect"><a href="#WSAAsyncSelect" class="headerlink" title="WSAAsyncSelect"></a>WSAAsyncSelect</h3><p>​		和select不同，他不是同步等待，是基于windows消息来通知socket的变化，换句话说，需要windows窗口和消息循环。另外，使用了WSAAsyncSelect会自动将套接字设置为非阻塞。</p>
<h3 id="WSAEventSelect"><a href="#WSAEventSelect" class="headerlink" title="WSAEventSelect"></a>WSAEventSelect</h3><p>​		和WSAAsyncSelect类似，不过是基于事件来异步通知套接字状态的变化，使用了WSAAsyncSelect会自动将套接字设置为非阻塞。他是基于windows事件，不需要windows窗口。</p>
<h3 id="WSAPoll"><a href="#WSAPoll" class="headerlink" title="WSAPoll"></a>WSAPoll</h3><p>​		类似select的轮询方式，没有套接字数量限制。</p>
<h3 id="重叠模型"><a href="#重叠模型" class="headerlink" title="重叠模型"></a>重叠模型</h3><h3 id="IOCP"><a href="#IOCP" class="headerlink" title="IOCP"></a>IOCP</h3><p>​		windows下高性能高并发量常用的模型，通过将套接字与完成端口关联来完成高性能异步操作。IOCP提供了一种高性能方式处理大并发量的异步操作，它是一种基于事件驱动的模型，基于事件通知机制来实现异步操作结束的通知。通过IOCP，避免了传统的同步和select的轮询，提高性能。</p>
<ul>
<li><p>使用流程</p>
<ul>
<li><strong>创建端口</strong>：首先，需要创建一个 I&#x2F;O 完成端口对象（IOCP 对象），通过调用 <code>CreateIoCompletionPort()</code> 函数来完成。</li>
<li><strong>关联套接字</strong>：然后，将需要进行异步 I&#x2F;O 操作的套接字句柄与创建的 IOCP 对象关联起来，可以关联一个或多个套接字。这通常通过调用 <code>CreateIoCompletionPort()</code> 函数来实现。</li>
<li><strong>发起异步操作</strong>：一旦套接字与 IOCP 关联成功，就可以通过调用异步 I&#x2F;O 函数（如 <code>WSASend()</code>、<code>WSARecv()</code>）来发起异步 I&#x2F;O 操作。在调用这些函数时，需要传递一个与操作相关的 <code>OVERLAPPED</code> 结构体，用于接收完成通知。</li>
<li><strong>处理完成通知</strong>：当异步 I&#x2F;O 操作完成时，系统会将完成结果通知到关联的 IOCP 对象上。应用程序可以通过调用 <code>GetQueuedCompletionStatus()</code> 函数来获取完成的 I&#x2F;O 操作，并进行相应的处理。</li>
</ul>
</li>
<li><p>简单流程分析</p>
<ul>
<li>通过CreateIoCompletionPort()创建IOCP对象，这个IOCP对象就充当了事件队列的管理者，负责管理所有与该IOCP相关的IO操作；</li>
<li>对某个IO（这里我们值得是套接字）对象上进行异步IO操作之前，我们需要将此IO对象与前面创建的IOCP关联起来，关联之后，此对象的完成事件就会被通知到该IOCO对象；</li>
<li>在IO对象上执行异步操作（WSASend &#x2F; WSAReceive，包括ReadFileEx &#x2F; WriteFileEx等），这些操作都会立即返回，不会阻塞当前线程；</li>
<li>当一个异步IO操作在后台完成时，系统会将对应的完成事件放入到IOCP对象的事件队列中，这个完成事件包含了操作相关的信息，包括操作类型和结果等；</li>
<li>应用程序的一个或多个线程调用GetQueuedCompletionStatus函数等待并处理事件队列中的完成事件，这些线程我们通常称之为完成端口线程。一旦某个完成事件进入队列，一个完成端口线程就会被唤醒；</li>
<li>当完成端口被唤醒，我们可以根据完成事件的信息来处理，比如某个异步Read操作完成，我们可以获取读取的内容往上派发给上层进行处理，同时，我们可以通过投递一个新的异步Read操作用于继续读取内容（等待新数据的到来）；</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jerrywang2013.github.io/2024/05/01/windows%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" data-id="clwbg5x4m0008z44qb6jc0x1a" data-title="windows网络编程" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Hexo-简介" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/30/Hexo-%E7%AE%80%E4%BB%8B/" class="article-date">
  <time class="dt-published" datetime="2024-04-30T12:37:16.000Z" itemprop="datePublished">2024-04-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/30/Hexo-%E7%AE%80%E4%BB%8B/">在Github上部署Hexo</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>简述</strong>：用Hexo本地创建Blog，然后将博客部署到Github上</p>
<ul>
<li><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h2><h3 id="安装git和npm"><a href="#安装git和npm" class="headerlink" title="安装git和npm"></a>安装git和npm</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">此部分省略</span><br></pre></td></tr></table></figure>



<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>



<h3 id="进阶安装和使用"><a href="#进阶安装和使用" class="headerlink" title="进阶安装和使用"></a>进阶安装和使用</h3><p>​	局部安装hexo包 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo</span><br></pre></td></tr></table></figure>

<p>​	然后可以使用hexo 命令</p>
</li>
<li><h3 id="创建Hexo项目"><a href="#创建Hexo项目" class="headerlink" title="创建Hexo项目"></a><strong>创建Hexo项目</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line"></span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line"></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="创建SSH-Key"><a href="#创建SSH-Key" class="headerlink" title="创建SSH Key"></a>创建SSH Key</h1><ul>
<li><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t ras -C &quot;yourmail@xxx.com&quot;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>邮箱地址是你github账号关联的邮箱，配置的目的是将github仓库和本地机器连起来，这样可以将文件提交到仓库，不需要账号密码。进入github的对应仓库，点击‘setting’进入设置，点击“SSH and GPG key”，点击”New SSH Key”, 将前面生成的c:&#x2F;users&#x2F;用户名&#x2F;.ssh&#x2F;目录下的id_ras.pub内容	复制过去，title 随便取，点击保存，至此本地与github之间连接就配置好了。</p>
<p><strong>测试：</strong>   	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行命令：ssh -T git@github.com</span><br></pre></td></tr></table></figure>


</li>
<li><h1 id="配置git账号邮箱"><a href="#配置git账号邮箱" class="headerlink" title="配置git账号邮箱"></a>配置git账号邮箱</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;github账号&quot;</span><br><span class="line"></span><br><span class="line">git config --global user.email &quot;github账号关联的邮箱&quot;</span><br></pre></td></tr></table></figure>


</li>
<li><h1 id="创建github仓库目录"><a href="#创建github仓库目录" class="headerlink" title="创建github仓库目录"></a>创建github仓库目录</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># mkdir myblob</span><br><span class="line"></span><br><span class="line"># 	git clone xxxxx.git</span><br></pre></td></tr></table></figure>


</li>
<li><h2 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd myblob</span><br><span class="line"></span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure>


</li>
<li><h2 id="查看初始文件"><a href="#查看初始文件" class="headerlink" title="查看初始文件"></a>查看初始文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>


</li>
<li><h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>  服务会监听本地4000端口，可以访问<a target="_blank" rel="noopener" href="http://localhost:4000/">http://localhost:4000</a></p>
</li>
</ul>
<h1 id="上传blog到github"><a href="#上传blog到github" class="headerlink" title="上传blog到github"></a>上传blog到github</h1><ul>
<li><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><h2 id="修改根目录下的-config-yml中的deploy部分："><a href="#修改根目录下的-config-yml中的deploy部分：" class="headerlink" title="修改根目录下的_config.yml中的deploy部分："></a>修改根目录下的_config.yml中的deploy部分：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line"></span><br><span class="line"> type: git</span><br><span class="line"></span><br><span class="line"> repository: https://github.com/Jerrywang2013/Jerrywang2013.github.io.git</span><br><span class="line"></span><br><span class="line"> branch: main</span><br></pre></td></tr></table></figure>


</li>
<li><h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>


</li>
<li><h2 id="部署-提交"><a href="#部署-提交" class="headerlink" title="部署(提交)"></a>部署(提交)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo deplot</span><br></pre></td></tr></table></figure>

<p><strong>备注</strong>：如果出现 ERROR Deployer not found: git w，请安装hexo部署插件： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-gi</span><br></pre></td></tr></table></figure>


</li>
<li><h2 id="访问博客"><a href="#访问博客" class="headerlink" title="访问博客"></a>访问博客</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">浏览： &lt;Github用户名&gt;.github.io</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="hexo使用"><a href="#hexo使用" class="headerlink" title="hexo使用"></a>hexo使用</h1><ul>
<li><h2 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-theme-volantis</span><br></pre></td></tr></table></figure>


</li>
<li><h2 id="添加文章"><a href="#添加文章" class="headerlink" title="添加文章"></a>添加文章</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new 英语测试</span><br></pre></td></tr></table></figure>



<h2 id="编辑文章"><a href="#编辑文章" class="headerlink" title="编辑文章"></a>编辑文章</h2><p>进入source__posts\英语测试.md 下编写具体内容即可</p>
</li>
<li><h2 id="生成文件"><a href="#生成文件" class="headerlink" title="生成文件"></a>生成文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate | hexo g</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><h2 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server | hexo s</span><br></pre></td></tr></table></figure>

<p>可选参数</p>
<p>​        -p –port 监听端口</p>
<p>​        -s –static 只使用静态文件</p>
<p>​        -l –log 启动日记记录，使用覆盖记录格式</p>
</li>
<li><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy | hexo d</span><br></pre></td></tr></table></figure>

<p>​	-g –generate 部署之前预先生成静态文件</p>
</li>
<li><h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo render &lt;file1&gt; &lt;file2&gt;...</span><br></pre></td></tr></table></figure>

<p>​	 -o –output 设置输出路径</p>
</li>
<li><h2 id="清除缓存"><a href="#清除缓存" class="headerlink" title="清除缓存"></a>清除缓存</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>

<p>​	清除缓存文件(db.json)和已生成的静态文件(public)</p>
<p>​	在某些情况下（更换主题后）如果发现对站点的更改无论如何也不生效，可以尝试此命令。</p>
</li>
<li><h2 id="列出网站数据"><a href="#列出网站数据" class="headerlink" title="列出网站数据"></a>列出网站数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo list &lt;type&gt;</span><br></pre></td></tr></table></figure>


</li>
<li><h2 id="显示版本"><a href="#显示版本" class="headerlink" title="显示版本"></a>显示版本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo version</span><br></pre></td></tr></table></figure>


</li>
<li><h2 id="列出网站配置"><a href="#列出网站配置" class="headerlink" title="列出网站配置"></a>列出网站配置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo config [key] [value]</span><br></pre></td></tr></table></figure>

<p>​	列出网站的配置(_config.yml)，如果指定了key，则只展示对应key的值，如果同时指定key和value，则将此key值修改为value。</p>
</li>
<li><h2 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo --debug</span><br></pre></td></tr></table></figure>


</li>
<li><h2 id="简洁模式"><a href="#简洁模式" class="headerlink" title="简洁模式"></a>简洁模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo --silent</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><strong>markdown基本语法</strong><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/nickchen121/p/10821946.html">https://www.cnblogs.com/nickchen121/p/10821946.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jerrywang2013.github.io/2024/04/30/Hexo-%E7%AE%80%E4%BB%8B/" data-id="clwbg5x4f0000z44qdvc2c6i5" data-title="在Github上部署Hexo" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-ThinkPHP之DB-Query" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/27/ThinkPHP%E4%B9%8BDB-Query/" class="article-date">
  <time class="dt-published" datetime="2024-04-27T09:16:13.000Z" itemprop="datePublished">2024-04-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/27/ThinkPHP%E4%B9%8BDB-Query/">ThinkPHP之DB::Query</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Query是ThinkPHP数据库操作的一个非常重要的类，大部分查询相关的操作功能都是通过此类来实现的，本文主要记录ThinkPHP5.0 Query类的部分重要函数。</p>
<h1 id="Query文件路径"><a href="#Query文件路径" class="headerlink" title="Query文件路径"></a>Query文件路径</h1><p><code>thinkphp\library\think\db\Query.php</code></p>
<h1 id="重要函数"><a href="#重要函数" class="headerlink" title="重要函数"></a>重要函数</h1><ul>
<li><strong>Query::table</strong><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定当前操作的数据表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@access</span> public</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mixed $table 表名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> $this</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">table</span>(<span class="params"><span class="variable">$table</span></span>)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>描述：</strong>设置当前操作的表，内部主要设置options的table属性：$this-&gt;options[‘table’] &#x3D; $table;</p>
<p><strong>范例：</strong>Db::table(‘fa_admin’)-&gt;where(“id”, 1)-&gt;find();</p>
<ul>
<li><strong>Query::name</strong><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定默认的数据表名（不含前缀）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@access</span> public</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> $this</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params"><span class="variable">$name</span></span>)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>描述</strong>：设置当前操作的表，和Query::table函数不同的是$name是不带前缀(前缀配置dbconfig[‘prefix’])的表名。</p>
<p><strong>范例</strong>：**Db::name(‘admin’)-&gt;where(“id”, 1)-&gt;find();</p>
<p><strong>备注:</strong> 也可以用helper函数db(“admin”)来获取dbconnection对象，例如：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">db</span>(<span class="string">&quot;admin&quot;</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>)-&gt;<span class="title function_ invoke__">find</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Query::value</strong><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 得到某个字段的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@access</span> public</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $field   字段名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mixed  $default 默认值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bool   $force   强制转为数字类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> mixed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">value</span>(<span class="params"><span class="variable">$field</span>, <span class="variable">$default</span> = <span class="literal">null</span>, <span class="variable">$force</span> = <span class="literal">false</span></span>)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>描述：</strong>查询符合条件的某个记录的某个字段的值，注意只查询一条记录(limit(1))</p>
<p><strong>范例：</strong> Db::table(‘fa_admin’)-&gt;where(“id”, 1)-&gt;value(“uername”);</p>
<ul>
<li><p><strong>Query::column</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 得到某个列的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@access</span> public</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $field 字段名 多个字段用逗号分隔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $key   索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">column</span>(<span class="params"><span class="variable">$field</span>, <span class="variable">$key</span> = <span class="string">&#x27;&#x27;</span></span>)</span></span><br></pre></td></tr></table></figure>
<p><strong>描述：</strong>指定符合条件记录的指定字段<br><strong>范例：</strong> Db::table(‘fa_admin’)-&gt;column(“nickname, id, nickname, username”);<br><strong>备注：</strong> $field是以逗号分隔的字段名字符串，形如”field1, field2…”。<br>column()函数会将$field去重；其次如果指定了$key，则以$key为返回记录的key；否则以$field字符串中第一个字段作为key</p>
</li>
<li><p><strong>Query::find</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找单条记录</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@access</span> public</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array|string|Query|\Closure $data</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> array|false|\PDOStatement|string|Model</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> DbException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ModelNotFoundException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> DataNotFoundException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params"><span class="variable">$data</span> = <span class="literal">null</span></span>)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>描述：</strong>查找单挑记录，返回的是</p>
<p><strong>范例：</strong> Db::name(‘admin’)-&gt;where(“id”, 1)-&gt;find();</p>
<ul>
<li><strong>Query::chunk</strong><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分批数据返回处理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@access</span> public</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> integer  $count    每次处理的数据数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> callable $callback 处理回调方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string   $column   分批处理的字段名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string   $order    排序规则</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> \LogicException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">chunk</span>(<span class="params"><span class="variable">$count</span>, <span class="variable">$callback</span>, <span class="variable">$column</span> = <span class="literal">null</span>, <span class="variable">$order</span> = <span class="string">&#x27;asc&#x27;</span></span>)</span></span><br></pre></td></tr></table></figure>
<strong>描述：</strong>分批处理数据<br><strong>范例：</strong></li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;think_user&#x27;</span>)-&gt;<span class="title function_ invoke__">chunk</span>(<span class="number">100</span>, function(<span class="variable">$users</span>) <span class="keyword">use</span>(&amp;$<span class="title">outer</span>) &#123;</span><br><span class="line">    <span class="title">foreach</span> ($<span class="title">users</span> <span class="keyword">as</span> $<span class="title">user</span>) &#123;</span><br><span class="line">        // 处理结果集...</span><br><span class="line">        <span class="title">if</span>($<span class="title">user</span>-&gt;<span class="title">status</span>==0)&#123;</span><br><span class="line">            <span class="title">return</span> <span class="title">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong> </p>
<ol>
<li>可以通过callback函数return false终止后续数据集的处理。这里，这里我们使用use将外部变量$outer传递给<br>   匿名函数，php中变量按照值传递，而不是引用，所以匿名函数内部的修改不会影响到外部$outer变量。这里我们如果想在<br>   匿名函数内部修改$outer，需要用**&amp;$outer**。</li>
<li>一般用于命令行处理db数据，不适合web访问处理大量数据，容易造成超时。</li>
</ol>
<ul>
<li><strong>Query::where</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 指定AND查询条件</span><br><span class="line"> * @access public</span><br><span class="line"> * @param mixed $field     查询字段</span><br><span class="line"> * @param mixed $op        查询表达式</span><br><span class="line"> * @param mixed $condition 查询条件</span><br><span class="line"> * @return $this</span><br><span class="line"> */</span><br><span class="line">public function where($field, $op = null, $condition = null)</span><br><span class="line">&#123;</span><br><span class="line">    $param = func_get_args();</span><br><span class="line">    array_shift($param);</span><br><span class="line">    $this-&gt;parseWhereExp(&#x27;AND&#x27;, $field, $op, $condition, $param);</span><br><span class="line">    return $this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>描述：</strong>设置AND查询条件，使用形式：where(‘字段名’, ‘表达式’, ‘查询条件’)<br><strong>表达式：</strong><br>  <strong>数值关系比较：</strong> &#x3D; | &lt;&gt; | &gt; | &gt;&#x3D; | &lt; | &lt;&#x3D;</li>
</ul>
<p>​	<strong>时间：</strong> &gt; TIME | &lt; TIME | &gt;&#x3D; TIME | &lt;&#x3D; TIME </p>
<p>​        <strong>其它：</strong> [NOT] LIKE | [NOT] BETWEEN | [NOT] IN | [NOT] NULL | [NOT] EXISTS | [NOT] REGEXP | [NOT] BETWEEN TIME </p>
<p>​	<strong>EXP：</strong> exp表达式</p>
<p><strong>范例：</strong></p>
<ul>
<li><p><strong>[NOT] LIKE</strong> 字符串模糊查询，<strong>支持数组</strong></p>
<p><strong>示例：</strong>where(‘name’, ‘like’, ‘%ab%’) | where(‘name’, ‘like’, [‘%ab’, ‘php%’]) </p>
</li>
<li><p><strong>[NOT] BETWEEN</strong></p>
<p><strong>示例：</strong>where(‘id’, ‘between’, ‘1,8’) | where(‘id’, ‘between’, [1,8])</p>
</li>
<li><p><strong>[NOT] In</strong></p>
<p><strong>示例：</strong>where(‘id’, ‘in’, ‘1,2,3’) | where(‘id’, ‘in’, [1,2,3]) | where(‘id’, ‘not in’, [1,2,3])</p>
</li>
<li><p><strong>[NOT]NULL</strong>         </p>
<p><strong>示例：</strong>where(‘name’, ‘null’) | where(‘name’, ‘not null’)</p>
</li>
<li><p><strong>时间查询</strong></p>
<p>where(‘createtime’, ‘&gt; time’, ‘2006-1-1’);</p>
<p>where(‘createtime’, ‘&lt; time’, ‘2006-1-1’); </p>
<p>where(‘createtime’, ‘between time’, [‘2006-1-1’,’2006-2-1’]);</p>
</li>
</ul>
<p>​	<strong>&gt;time | &lt;time**<br>​	和’&gt;|&lt;’类似，不同的是用&gt;time | &lt;time之类的操作符，后面的条件可以用形如</strong>today** | <strong>last week</strong> | <strong>-2 hour</strong>之类的时间区间，</p>
<p>​	例如：where(‘createtime’, ‘-2 hour’)</p>
<p>​	<strong>Query::whereTime</strong>用法和where类似，不同的是当参数3($range)为null时，$op可以用特殊字段来表示时间区间，支持的特殊日期时间区间格式有：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">where</span>(<span class="string">&#x27;birthday&#x27;</span>, <span class="string">&#x27;today&#x27;</span>)表示日期范围是今天</span><br><span class="line"><span class="title function_ invoke__">where</span>(<span class="string">&#x27;birthday&#x27;</span>, <span class="string">&#x27;yesterday&#x27;</span>)表示日期范围是今天</span><br><span class="line"><span class="title function_ invoke__">where</span>(<span class="string">&#x27;birthday&#x27;</span>, <span class="string">&#x27;week&#x27;</span>)表示日期范围是本周</span><br><span class="line"><span class="title function_ invoke__">where</span>(<span class="string">&#x27;birthday&#x27;</span>, <span class="string">&#x27;last week&#x27;</span>)表示日期范围是上周</span><br><span class="line"><span class="title function_ invoke__">where</span>(<span class="string">&#x27;birthday&#x27;</span>, <span class="string">&#x27;month&#x27;</span>)表示日期范围是本月</span><br><span class="line"><span class="title function_ invoke__">where</span>(<span class="string">&#x27;birthday&#x27;</span>, <span class="string">&#x27;last month&#x27;</span>)表示日期范围是上月</span><br><span class="line"><span class="title function_ invoke__">where</span>(<span class="string">&#x27;birthday&#x27;</span>, <span class="string">&#x27;year&#x27;</span>)表示日期范围是本年</span><br><span class="line"><span class="title function_ invoke__">where</span>(<span class="string">&#x27;birthday&#x27;</span>, <span class="string">&#x27;last year&#x27;</span>)表示日期范围是上年</span><br><span class="line"><span class="title function_ invoke__">whereTime</span>(<span class="string">&#x27;create_time&#x27;</span>,<span class="string">&#x27;-2 hours&#x27;</span>) 表示两小时以内 等价于 <span class="title function_ invoke__">where</span>(<span class="string">&#x27;create_time&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;-2 hours&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>EXP</strong></p>
<p><strong>使用：</strong></p>
<p>​	where(‘字段名’, ‘exp’, ‘条件字符串’)；</p>
<p>​	where(‘字段名’, null, Expression())  可以用DB::raw(“查询字符串”)构造Expression形式的查询条件</p>
<p><strong>示例：</strong></p>
<p>​	where(‘id’, ‘exp’, ‘in(1,2,3)’) <strong>[推荐使用]</strong> ；等价于where(‘id’, ‘in’, ‘1,2,3’) ;</p>
<p>​	where(‘id’, null, DB::raw(“FIND_IN_SET(1, id)”))，其内部也是转为where(‘id’, ‘exp’, ‘in (1,2,3)’);</p>
<p><strong>说明：</strong>exp查询条件不会被当做字符串，可以使用任何sql语法，包括函数和字段名称。</p>
</li>
</ul>
<p><strong>注意：</strong>使用字符串条件查找最好使用<em><strong>预处理机制</strong></em>，确保安全，例如：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;think_user&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&quot;id=:id and username=:name&quot;</span>)</span><br><span class="line">	-&gt;<span class="title function_ invoke__">bind</span>([<span class="string">&#x27;id&#x27;</span>=&gt;[<span class="number">1</span>,\PDO::<span class="variable constant_">PARAM_INT</span>],<span class="string">&#x27;name&#x27;</span>=&gt;<span class="string">&#x27;thinkphp&#x27;</span>])</span><br><span class="line"> 	-&gt;<span class="title function_ invoke__">select</span>();</span><br></pre></td></tr></table></figure>



<ul>
<li><p><strong>Query::whereOr</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 指定OR查询条件</span><br><span class="line"> * @access public</span><br><span class="line"> * @param mixed $field     查询字段</span><br><span class="line"> * @param mixed $op        查询表达式</span><br><span class="line"> * @param mixed $condition 查询条件</span><br><span class="line"> * @return $this</span><br><span class="line"> */</span><br><span class="line">public function whereOr($field, $op = null, $condition = null)    </span><br></pre></td></tr></table></figure>
<p><strong>描述：</strong>设置Or查询条件</p>
</li>
<li><p><strong>Query::whereXOR</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 指定XOR查询条件</span><br><span class="line"> * @access public</span><br><span class="line"> * @param mixed $field     查询字段</span><br><span class="line"> * @param mixed $op        查询表达式</span><br><span class="line"> * @param mixed $condition 查询条件</span><br><span class="line"> * @return $this</span><br><span class="line"> */</span><br><span class="line">public function whereXor($field, $op = null, $condition = null)</span><br></pre></td></tr></table></figure>
<p><strong>描述：</strong>设置XOR查询条件</p>
</li>
<li><p><strong>Query::parseWhereExp</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析查询表达式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@access</span> public</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string                $logic     查询逻辑 and or xor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string|array|\Closure $field     查询字段</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mixed                 $op        查询表达式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mixed                 $condition 查询条件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array                 $param     查询参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  bool                 $strict    严格模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">parseWhereExp</span>(<span class="params"><span class="variable">$logic</span>, <span class="variable">$field</span>, <span class="variable">$op</span>, <span class="variable">$condition</span>, <span class="variable">$param</span> = [], <span class="variable">$strict</span> = <span class="literal">false</span></span>)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>描述：</strong>查询条件表达式解析。</p>
<p><strong>示例：</strong></p>
<ul>
<li><p><strong>And条件</strong><br>  where(“id”, 25)<br>  where(“id &#x3D; 25”)<br>  where(“id”, ‘&#x3D;’, 25)<br>  where(“id”, “in”, [1,2,3])</p>
</li>
<li><p><strong>Or条件</strong><br>  whereOr(“id”, 25)</p>
</li>
<li><p>Xor条件</p>
<p>  whereXor</p>
</li>
<li><p>null条件</p>
<p>  whereNull | whereNotNull</p>
</li>
<li><p>time条件</p>
<p>  whereTime</p>
</li>
<li><p>raw条件</p>
<p>  whereRaw</p>
</li>
<li><p>Exists</p>
<p>  whereExists | whereNotExists</p>
</li>
<li><p>In</p>
<p>  whereIn | whereNotIn</p>
</li>
<li><p>like</p>
<p>  whereLike | whereNotLike</p>
</li>
<li><p>between</p>
<p>  whereBetween | whereNotBetween</p>
</li>
<li><p>EXP</p>
<p>  whereExp</p>
</li>
</ul>
<p><strong>注意：</strong></p>
<p>​	同一级条件中，And和Or平级，如果想实现Or的关系，一般用闭包查询，将Or的条件包在闭包里头，然后整体和外围的条件And<br>例如：想实现condA and condB &amp; (condC or condD)，就将condC&#x2F;condD通过闭包（内部or）然后和condA&#x2F;condB一起链如查询。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$where_extra</span> = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="variable">$query</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$query</span>-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;=&#x27;</span>, <span class="number">3</span>)</span><br><span class="line">        -&gt;<span class="title function_ invoke__">whereOr</span>(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;=&#x27;</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$result</span> = <span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;fa_admin&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;=&quot;</span>, <span class="number">25</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="variable">$where_extra</span>)</span><br><span class="line">    -&gt;<span class="title function_ invoke__">field</span>([<span class="string">&quot;id&quot;</span>, <span class="string">&quot;username&quot;</span> =&gt; <span class="string">&quot;name&quot;</span>])</span><br><span class="line">    -&gt;<span class="title function_ invoke__">fetchSql</span>(<span class="literal">true</span>)</span><br><span class="line">    -&gt;<span class="title function_ invoke__">select</span>();      </span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成的查询sql： &quot;SELECT `id`,`username` AS `name` FROM `fa_admin` WHERE  `id` = 25  AND (  `id` = 3 OR `id` = 4 )&quot;</span></span><br></pre></td></tr></table></figure>


<ul>
<li><strong>Query::fetchSql</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取执行的SQL语句</span><br><span class="line"> * @access public</span><br><span class="line"> * @param boolean $fetch 是否返回sql</span><br><span class="line"> * @return $this</span><br><span class="line"> */</span><br><span class="line">public function fetchSql($fetch = true)</span><br></pre></td></tr></table></figure>
<p><strong>描述：</strong>$fetch为ture则不执行sql，仅仅返回querySql，方便调试sql语句。</p>
<ul>
<li><strong>Builder::select</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 生成查询SQL</span><br><span class="line"> * @access public</span><br><span class="line"> * @param array $options 表达式</span><br><span class="line"> * @return string</span><br><span class="line"> */</span><br><span class="line">public function select($options = [])</span><br></pre></td></tr></table></figure>
<p><strong>描述：</strong>生成查询SQL语句。</p>
<ul>
<li><strong>Builder::alias</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 指定数据表别名</span><br><span class="line"> * @access public</span><br><span class="line"> * @param mixed $alias 数据表别名</span><br><span class="line"> * @return $this</span><br><span class="line"> */</span><br><span class="line">public function alias($alias)</span><br></pre></td></tr></table></figure>
<p><strong>描述：</strong>设置数据库别名<br><strong>范例：</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&quot;fa_admin&quot;</span>)-&gt;<span class="title function_ invoke__">alias</span>([<span class="string">&#x27;fa_admin&#x27;</span>=&gt;<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;fa_customer&quot;</span>=&gt;<span class="string">&quot;customer&quot;</span>])</span><br><span class="line">    -&gt;<span class="title function_ invoke__">join</span>(<span class="string">&#x27;fa_customer&#x27;</span>, <span class="string">&#x27;customer.id=admin.id&#x27;</span>)-&gt;<span class="title function_ invoke__">select</span>();</span><br><span class="line"><span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;fa_admin&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&quot;admin.id&quot;</span>, <span class="string">&quot;=&quot;</span>, <span class="number">25</span>)</span><br><span class="line">    -&gt;<span class="title function_ invoke__">field</span>(<span class="string">&quot;admin.id, admin.username, admin.nickname, staff.mobile, staff.id, staff.post&quot;</span>)</span><br><span class="line">    -&gt;<span class="title function_ invoke__">alias</span>([</span><br><span class="line">        <span class="string">&quot;fa_admin&quot;</span> =&gt; <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">        <span class="string">&quot;fa_qingdong_staff&quot;</span> =&gt; <span class="string">&quot;staff&quot;</span></span><br><span class="line">    ])-&gt;<span class="title function_ invoke__">join</span>(<span class="string">&#x27;fa_qingdong_staff&#x27;</span>, <span class="string">&#x27;staff.admin_id = admin.id&#x27;</span>)</span><br><span class="line">    -&gt;<span class="title function_ invoke__">fetchSql</span>(<span class="literal">false</span>)</span><br><span class="line">    -&gt;<span class="title function_ invoke__">select</span>();</span><br></pre></td></tr></table></figure>



<h1 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a><strong>高级查询</strong></h1><ul>
<li><p><strong>快速查询</strong></p>
<p>​	快捷查询是多个字段使用同一个查询条件的简写，在多个字段之间用|或者&amp;，表示Or和And查询，例如：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;think_user&#x27;</span>)</span><br><span class="line">    -&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;name|title&#x27;</span>,<span class="string">&#x27;like&#x27;</span>,<span class="string">&#x27;thinkphp%&#x27;</span>)</span><br><span class="line">    -&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;create_time&amp;update_time&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">    -&gt;<span class="title function_ invoke__">find</span>();</span><br></pre></td></tr></table></figure>

<p>生成的SQL：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `think_user` WHERE ( `name` LIKE &#x27;thinkphp%&#x27; OR `title` LIKE &#x27;thinkphp%&#x27; ) AND ( `create_time` &gt; 0 AND `update_time` &gt; 0 ) LIMIT 1</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>区间查询</strong></p>
<p>​	区间查询是同一个字段多个查询条件的简化写法，例如：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;think_user&#x27;</span>)</span><br><span class="line">    -&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;name&#x27;</span>,[<span class="string">&#x27;like&#x27;</span>,<span class="string">&#x27;thinkphp%&#x27;</span>],[<span class="string">&#x27;like&#x27;</span>,<span class="string">&#x27;%thinkphp&#x27;</span>])</span><br><span class="line">    -&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;id&#x27;</span>,[<span class="string">&#x27;&gt;&#x27;</span>,<span class="number">0</span>],[<span class="string">&#x27;&lt;&gt;&#x27;</span>,<span class="number">10</span>],<span class="string">&#x27;or&#x27;</span>)</span><br><span class="line">    -&gt;<span class="title function_ invoke__">find</span>();</span><br></pre></td></tr></table></figure>

<p>生成的SQL：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `think_user` WHERE ( `name` LIKE &#x27;thinkphp%&#x27; AND `name` LIKE &#x27;%thinkphp&#x27; ) AND ( `id` &gt; 0 OR `id` &lt;&gt; 10 ) LIMIT 1</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>批量查询</strong></p>
<p>​	批量查询可以进行多个条件的批量条件查询，例如：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;think_user&#x27;</span>)</span><br><span class="line">    -&gt;<span class="title function_ invoke__">where</span>([</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>  =&gt;  [<span class="string">&#x27;like&#x27;</span>,<span class="string">&#x27;thinkphp%&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span> =&gt;  [<span class="string">&#x27;like&#x27;</span>,<span class="string">&#x27;%thinkphp&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;id&#x27;</span>    =&gt;  [<span class="string">&#x27;&gt;&#x27;</span>,<span class="number">0</span>],</span><br><span class="line">        <span class="string">&#x27;status&#x27;</span>=&gt;  <span class="number">1</span></span><br><span class="line">    ])</span><br><span class="line">    -&gt;<span class="title function_ invoke__">select</span>();</span><br></pre></td></tr></table></figure>

<p>生成的SQL：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `think_user` WHERE `name` LIKE &#x27;thinkphp%&#x27; AND `title` LIKE &#x27;%thinkphp&#x27; AND `id` &gt; 0 AND `status` = &#x27;1&#x27;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>闭包查询</strong></p>
<p>​	闭包查询可以很好的执行多个查询条件的与或关系。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Db::table(&#x27;think_user&#x27;)-&gt;select(function($query)&#123;</span><br><span class="line">    $query-&gt;where(&#x27;name&#x27;,&#x27;thinkphp&#x27;)</span><br><span class="line">        -&gt;whereOr(&#x27;id&#x27;,&#x27;&gt;&#x27;,10);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>生成的SQL：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `think_user` WHERE `name` = &#x27;thinkphp&#x27; OR `id` &gt; 10</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>使用Query对象查询</strong></p>
<p>​	可以事先封装Query对象，并且传入select方法，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$query = new \think\db\Query;</span><br><span class="line">$query-&gt;name(&#x27;user&#x27;)</span><br><span class="line">    -&gt;where(&#x27;name&#x27;,&#x27;like&#x27;,&#x27;%think%&#x27;)</span><br><span class="line">    -&gt;where(&#x27;id&#x27;,&#x27;&gt;&#x27;,10)</span><br><span class="line">    -&gt;limit(10);</span><br><span class="line">Db::select($query);    </span><br></pre></td></tr></table></figure>

<p>注意：使用Query对象的话，select方法之前的调用的任何链式操作都是无效的。</p>
</li>
<li><p><strong>混合查询</strong></p>
<p>​	混合前面的查询方式，比如普通查询、快捷查询、批量查询、闭包查询。</p>
</li>
<li><p><strong>字符串条件查询</strong></p>
<p>​	对于一些复杂的查询，可以直接使用原生SQL语句查询，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Db::table(&#x27;think_user&#x27;)</span><br><span class="line">    -&gt;where(&#x27;id &gt; 0 AND name LIKE &quot;thinkphp%&quot;&#x27;)</span><br><span class="line">    -&gt;select();</span><br></pre></td></tr></table></figure>

<p>为了安全起见，我们可以对字符串查询条件使用参数绑定，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Db::table(&#x27;think_user&#x27;)</span><br><span class="line">    -&gt;where(&#x27;id &gt; 0 AND name LIKE &quot;thinkphp%&quot;&#x27;)</span><br><span class="line">    -&gt;select();</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>快捷方法</strong></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>whereNull</code></td>
<td align="left">查询字段是否为Null</td>
</tr>
<tr>
<td align="left"><code>whereNotNull</code></td>
<td align="left">查询字段是否不为Null</td>
</tr>
<tr>
<td align="left"><code>whereIn</code></td>
<td align="left">字段IN查询</td>
</tr>
<tr>
<td align="left"><code>whereNotIn</code></td>
<td align="left">字段NOT IN查询</td>
</tr>
<tr>
<td align="left"><code>whereBetween</code></td>
<td align="left">字段BETWEEN查询</td>
</tr>
<tr>
<td align="left"><code>whereNotBetween</code></td>
<td align="left">字段NOT BETWEEN查询</td>
</tr>
<tr>
<td align="left"><code>whereLike</code></td>
<td align="left">字段LIKE查询</td>
</tr>
<tr>
<td align="left"><code>whereNotLike</code></td>
<td align="left">字段NOT LIKE查询</td>
</tr>
<tr>
<td align="left"><code>whereExists</code></td>
<td align="left">EXISTS条件查询</td>
</tr>
<tr>
<td align="left"><code>whereNotExists</code></td>
<td align="left">NOT EXISTS条件查询</td>
</tr>
<tr>
<td align="left"><code>whereExp</code></td>
<td align="left">表达式查询</td>
</tr>
</tbody></table>
</li>
</ul>
<h1 id="视图查询"><a href="#视图查询" class="headerlink" title="视图查询"></a>视图查询</h1><p>​	视图查询主要是进行多表查询，不需要数据库支持视图。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Db::view(&#x27;User&#x27;,&#x27;id,name&#x27;)</span><br><span class="line">    -&gt;view(&#x27;Profile&#x27;,&#x27;truename,phone,email&#x27;,&#x27;Profile.user_id=User.id&#x27;)</span><br><span class="line">    -&gt;view(&#x27;Score&#x27;,&#x27;score&#x27;,&#x27;Score.user_id=Profile.id&#x27;)</span><br><span class="line">    -&gt;where(&#x27;score&#x27;,&#x27;&gt;&#x27;,80)</span><br><span class="line">    -&gt;select();</span><br></pre></td></tr></table></figure>

<p>生成的SQL语句类似于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT User.id,User.name,Profile.truename,Profile.phone,Profile.email,Score.score FROM think_user User </span><br><span class="line">INNER JOIN think_profile Profile ON Profile.user_id=User.id </span><br><span class="line">INNER JOIN think_socre Score ON Score.user_id=Profile.id WHERE Score.score &gt; 80</span><br></pre></td></tr></table></figure>

<p>默认是inner join，如果需要更改，可以使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Db::view(&#x27;User&#x27;,&#x27;id,name&#x27;)</span><br><span class="line">    -&gt;view(&#x27;Profile&#x27;,&#x27;truename,phone,email&#x27;,&#x27;Profile.user_id=User.id&#x27;,&#x27;LEFT&#x27;)</span><br><span class="line">    -&gt;view(&#x27;Score&#x27;,&#x27;score&#x27;,&#x27;Score.user_id=Profile.id&#x27;,&#x27;RIGHT&#x27;)</span><br><span class="line">    -&gt;where(&#x27;score&#x27;,&#x27;&gt;&#x27;,80)</span><br><span class="line">    -&gt;select();</span><br></pre></td></tr></table></figure>

<p>生成的SQL语句类似于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT User.id,User.name,Profile.truename,Profile.phone,Profile.email,Score.score FROM think_user User </span><br><span class="line">LEFT JOIN think_profile Profile ON Profile.user_id=User.id </span><br><span class="line">RIGHT JOIN think_socre Score ON Score.user_id=Profile.id WHERE Score.score &gt; 80</span><br></pre></td></tr></table></figure>

<p>可以使用别名，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Db::view(&#x27;User&#x27;,[&#x27;id&#x27;=&gt;&#x27;uid&#x27;,&#x27;name&#x27;=&gt;&#x27;account&#x27;])</span><br><span class="line">    -&gt;view(&#x27;Profile&#x27;,&#x27;truename,phone,email&#x27;,&#x27;Profile.user_id=User.id&#x27;)</span><br><span class="line">    -&gt;view(&#x27;Score&#x27;,&#x27;score&#x27;,&#x27;Score.user_id=Profile.id&#x27;)</span><br><span class="line">    -&gt;where(&#x27;score&#x27;,&#x27;&gt;&#x27;,80)</span><br><span class="line">    -&gt;select();</span><br></pre></td></tr></table></figure>

<p>生成的SQL语句类似于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT User.id AS uid,User.name AS account,Profile.truename,Profile.phone,Profile.email,Score.score </span><br><span class="line">FROM think_user User INNER JOIN think_profile Profile ON Profile.user_id=User.id </span><br><span class="line">INNER JOIN think_socre Score ON Score.user_id=Profile.id WHERE Score.score &gt; 80</span><br></pre></td></tr></table></figure>

<p>可以使用数组的方式定义表名以及别名，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Db::view([&#x27;think_user&#x27;=&gt;&#x27;member&#x27;],[&#x27;id&#x27;=&gt;&#x27;uid&#x27;,&#x27;name&#x27;=&gt;&#x27;account&#x27;])</span><br><span class="line">    -&gt;view(&#x27;Profile&#x27;,&#x27;truename,phone,email&#x27;,&#x27;Profile.user_id=member.id&#x27;)</span><br><span class="line">    -&gt;view(&#x27;Score&#x27;,&#x27;score&#x27;,&#x27;Score.user_id=Profile.id&#x27;)</span><br><span class="line">    -&gt;where(&#x27;score&#x27;,&#x27;&gt;&#x27;,80)</span><br><span class="line">    -&gt;select();</span><br></pre></td></tr></table></figure>

<p>生成的SQL语句类似于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT member.id AS uid,member.name AS account,Profile.truename,Profile.phone,Profile.email,Score.score </span><br><span class="line">FROM think_user member INNER JOIN think_profile Profile ON Profile.user_id=member.id </span><br><span class="line">INNER JOIN think_socre Score ON Score.user_id=Profile.id WHERE Score.score &gt; 80</span><br></pre></td></tr></table></figure>



<h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><ul>
<li><p><strong>使用select()</strong></p>
<p>Query::select()参数为false时，不进行查询而是返回构建的SQL语句，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT member.id AS uid,member.name AS account,Profile.truename,Profile.phone,Profile.email,</span><br><span class="line">Score.score FROM think_user member INNER JOIN think_profile Profile ON Profile.user_id=member.id </span><br><span class="line">INNER JOIN think_socre Score ON Score.user_id=Profile.id WHERE Score.score &gt; 80</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>使用fetchSql()</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$subQuery = Db::table(&#x27;think_user&#x27;)</span><br><span class="line">    -&gt;field(&#x27;id,name&#x27;)</span><br><span class="line">    -&gt;where(&#x27;id&#x27;,&#x27;&gt;&#x27;,10)</span><br><span class="line">    -&gt;fetchSql(true)</span><br><span class="line">    -&gt;select();</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>使用buildSql构造子查询</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$subQuery = Db::table(&#x27;think_user&#x27;)</span><br><span class="line">    -&gt;field(&#x27;id,name&#x27;)</span><br><span class="line">    -&gt;where(&#x27;id&#x27;,&#x27;&gt;&#x27;,10)</span><br><span class="line">    -&gt;buildSql();</span><br></pre></td></tr></table></figure>

<p>生成subQuery结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( SELECT `id`,`name` FROM `think_user` WHERE `id` &gt; 10 )</span><br></pre></td></tr></table></figure>

<p><em><strong>注意：此方法会自动加括号，前面两个方法需要手动添加括号。</strong></em></p>
<p>然后使用子查询构造新的查询：</p>
<p>生成的SQL语句为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM ( SELECT `id`,`name` FROM `think_user` WHERE `id` &gt; 10 ) a WHERE a.name LIKE &#x27;thinkphp&#x27;</span><br><span class="line">ORDER BY `id` desc</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>使用闭包构造子查询</strong></p>
<p><code>IN/NOT IN</code>和<code>EXISTS/NOT EXISTS</code>之类的查询可以直接使用闭包作为子查询，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Db::table(&#x27;think_user&#x27;)</span><br><span class="line">-&gt;where(&#x27;id&#x27;,&#x27;IN&#x27;,function($query)&#123;</span><br><span class="line">    $query-&gt;table(&#x27;think_profile&#x27;)-&gt;where(&#x27;status&#x27;,1)-&gt;field(&#x27;id&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">-&gt;select();</span><br></pre></td></tr></table></figure>

<p>生成的SQL语句类似：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `think_user` WHERE `id` IN ( SELECT `id` FROM `think_profile` WHERE `status` = 1 )</span><br></pre></td></tr></table></figure>

<p>又例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Db::table(&#x27;think_user&#x27;)</span><br><span class="line">-&gt;where(function($query)&#123;</span><br><span class="line">    $query-&gt;table(&#x27;think_profile&#x27;)-&gt;where(&#x27;status&#x27;,1);</span><br><span class="line">&#125;,&#x27;exists&#x27;)</span><br><span class="line">-&gt;find();</span><br></pre></td></tr></table></figure>

<p>生成的SQL语句类似：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `think_user` WHERE EXISTS ( SELECT * FROM `think_profile` WHERE `status` = 1 ) </span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="原生查询"><a href="#原生查询" class="headerlink" title="原生查询"></a>原生查询</h1><ul>
<li><p><strong>Query::query方法</strong></p>
<p>用于执行SQL查询操作，如果数据非法或者查询错误返回false，否则返回结果集。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Db::query(&quot;select * from think_user where status=1&quot;);</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>Query::execute()</strong></p>
<p>execute用于更新和写入数据的sql操作，如果数据非法或者查询错误则返回false ，否则返回影响的记录数。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Db::execute(&quot;update think_user set name=&#x27;thinkphp&#x27; where status=1&quot;);</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>参数绑定</strong></p>
<p>支持在原生查询的时候使用参数绑定，包括问号占位符或者命名占位符，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Db::query(&quot;select * from think_user where id=? AND status=?&quot;,[8,1]);</span><br><span class="line">// 命名绑定</span><br><span class="line">Db::execute(&quot;update think_user set name=:name where status=:status&quot;,[&#x27;name&#x27;=&gt;&#x27;thinkphp&#x27;,&#x27;status&#x27;=&gt;1]);</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>存储过程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$result = Db::query(&#x27;call sp_query(8)&#x27;);</span><br></pre></td></tr></table></figure>

<p>也可以用参数绑定：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$result = Db::query(&#x27;call sp_query(?)&#x27;,[8]);</span><br><span class="line">// 或者命名绑定</span><br><span class="line">$result = Db::query(&#x27;call sp_query(:id)&#x27;,[&#x27;id&#x27;=&gt;8]);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h1><ul>
<li><p>一对一关联</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hasOne(&#x27;关联模型名&#x27;,&#x27;外键名&#x27;,&#x27;主键名&#x27;,[&#x27;模型别名定义&#x27;],&#x27;join类型&#x27;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">belongsTo(&#x27;关联模型名&#x27;,&#x27;外键名&#x27;,&#x27;关联表主键名&#x27;,[&#x27;模型别名定义&#x27;],&#x27;join类型&#x27;);</span><br></pre></td></tr></table></figure>

<p>例如：customer表通过owner_staff_id关联到staff表，外键名为staff表的主键id，主键名为customer表的owner_staff_id，customer表通过字段owner_staff_id与staff表的id外键关联起来。这里的本地的称之为主键，关联的外部模型的字段称之为外键，这么说可能更容易理解：</p>
<p>hasOne(‘关联模型’, ‘关联模型的关联字段名’, ‘本地字段名’)  其中’本地字段名’和’关联模型的关联字段名’是相关联的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public function ownerStaff() &#123;</span><br><span class="line"></span><br><span class="line">    return $this-&gt;hasOne(Staff::class, &#x27;id&#x27;, &#x27;owner_staff_id&#x27;)-&gt;field(&#x27;id,name,group_ids&#x27;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>一对多关联</p>
</li>
<li><p>多对多关联</p>
</li>
<li><p>关联预载入</p>
</li>
<li><p>关联统计</p>
</li>
</ul>
<h1 id="ThinkPHP5-DB模块可能存在的问题"><a href="#ThinkPHP5-DB模块可能存在的问题" class="headerlink" title="ThinkPHP5 DB模块可能存在的问题"></a><strong>ThinkPHP5 DB模块可能存在的问题</strong></h1><ul>
<li><p><strong>参数绑定性能</strong></p>
<p>比如设置了一个查询条件where(‘id’, ‘in’, $idlist) 其中$idlist是一个数组格式的id集合，如果$idlist数据量比较大，在解析where参数的时候进行。当参数绑定耗时会比较多，此时可以用字符串的where代替，就是逻辑层直接用$idlist转为字符串$strids，然后where(“id in (${strids})”);<br><strong>例如：</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$idlist</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">25</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">28</span>,<span class="number">29</span>,<span class="number">30</span>];</span><br><span class="line"><span class="variable">$strids</span> = <span class="title function_ invoke__">implode</span>(<span class="string">&#x27;,&#x27;</span>, <span class="variable">$idlist</span>);</span><br><span class="line"><span class="variable">$result</span> = <span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;fa_admin&#x27;</span>)</span><br><span class="line">    <span class="comment">// 当$idlist很大时，用字符串where条件替代</span></span><br><span class="line">    <span class="comment">//-&gt;where(&quot;id&quot;, &#x27;in&#x27;, $idlist)</span></span><br><span class="line">    -&gt;<span class="title function_ invoke__">where</span>(<span class="string">&quot;id in ($&#123;strids&#125;)&quot;</span>)</span><br><span class="line">    -&gt;<span class="title function_ invoke__">field</span>([<span class="string">&quot;id&quot;</span>, <span class="string">&quot;username&quot;</span> =&gt; <span class="string">&quot;name&quot;</span>])</span><br><span class="line">    -&gt;<span class="title function_ invoke__">fetchSql</span>(<span class="literal">false</span>)</span><br><span class="line">    -&gt;<span class="title function_ invoke__">select</span>();</span><br></pre></td></tr></table></figure>

</li>
<li><p><strong>Model结果序列化性能</strong></p>
<p>​	通常情况下如果数据量比较大一般会采取分页机制来减少每次查询和处理的记录集。但是如果用户确实就想一次性查看大量数据比如(1000)条记录，测试发现通过Model查询db获取记录之后调用json(model)会触发Model::jsonSerialize()，进而调用Model::toArray()，此函数对Model中每个属性进行处理，很耗时。可行的优化方案如下：</p>
<ul>
<li><p><strong>降低查询的fields</strong></p>
<p>通过fields(“xxx”)来过滤需要的字段列表，或者通过设置模型的显示属性$visible和隐藏属性$hidden</p>
</li>
<li><p><strong>降低pageNum</strong></p>
<p>毕竟都有分页了，没必要将每页记录数量设置太大</p>
</li>
<li><p><strong>优化Model::toArray()</strong></p>
<p>测试从customer表中查出1000条件记录，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$result = Customer::where(&quot;id&quot;, &#x27;exp&#x27;, &quot;&gt; 0&quot;)-&gt;limit(1000)-&gt;select();</span><br><span class="line"></span><br><span class="line">$timeprofile[] = Debug::getUseTime();</span><br><span class="line"></span><br><span class="line">$result_json = json_encode($result);</span><br><span class="line"></span><br><span class="line">$timeprofile[] = Debug::getUseTime();</span><br></pre></td></tr></table></figure>

<p>打印出的时间：</p>
<p>​	select耗时：0.03s</p>
<p>​	json_encode耗时：6.95s</p>
<p>由上可见Model::toArray()耗时非常大。</p>
</li>
<li><p><strong>优化Query::select()</strong></p>
<p>select()会先准备要执行的最终查询sql，然后查询，查询完毕后还会对结果集进行处理，比如创建模型对象，并且用结果集中的每条记录数据来初始化模型对象，此过程也是非常耗时，对于大部分只需要数据并不会后续处理的应用场景而言，可以省略这一步操作。其实，Query::select()如果没有model对象，这一步本来就是可以省略的。</p>
</li>
</ul>
</li>
</ul>
<p>​	</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jerrywang2013.github.io/2024/04/27/ThinkPHP%E4%B9%8BDB-Query/" data-id="clwbg5x4l0004z44qfy6ab9hx" data-title="ThinkPHP之DB::Query" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-MarkDown基本语法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/23/MarkDown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2024-04-23T13:25:07.000Z" itemprop="datePublished">2024-04-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/23/MarkDown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">MarkDown基本语法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>一、前言<br>    由于有些语法无法在博客园展示，推荐使用<a target="_blank" rel="noopener" href="https://www.typora.io/">Typora解锁全套</a><br>    推荐使用<a target="_blank" rel="noopener" href="https://www.cnblogs.com/nickchen121/p/10722733.html">jupyter</a><br>    <a target="_blank" rel="noopener" href="https://www.cnblogs.com/nickchen121/p/11746655.html">markdown数学公式大全</a></p>
<p>二、MD工具</p>
<ul>
<li><strong>离线工具</strong>：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/guoxuanhan/p/16841068.html">typora</a>：markdown编辑器和阅读器，分割简单多种主题，支持windows&#x2F;linux&#x2F;macOS。</li>
<li><strong>在线编辑器</strong>：<br><a target="_blank" rel="noopener" href="https://maxiang.io/">马克飞象</a><br><a target="_blank" rel="noopener" href="http://daringfireball.net/projects/markdown/dingus">dingus</a></li>
</ul>
<p>二、MD基本语法</p>
<ul>
<li><p>2.1 标题<br><strong>代码</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br></pre></td></tr></table></figure>
<p><strong>效果</strong>：</p>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4></li>
<li><p>2.2 加粗<br>语法：使用**或者__<br><strong>代码</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**我被加粗了**</span><br></pre></td></tr></table></figure>
<p><strong>效果</strong>：<br>&nbsp;&nbsp;&nbsp;&nbsp;我被<strong>加粗</strong>了倾斜</p>
</li>
<li><p>2.3 斜体<br>语法：使用*或者_<br><strong>代码</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*我被倾斜了*</span><br></pre></td></tr></table></figure>
<p><strong>效果</strong>：<br>&nbsp;&nbsp;&nbsp;&nbsp;<em>我被倾斜了</em></p>
</li>
<li><p>2.4 高亮<br>语法：使用*或者_<br>  我被&#x3D;&#x3D;高亮&#x3D;&#x3D;</p>
</li>
<li><p>2.5 代码引用(&gt;)</p>
</li>
<li><p>2.6 代码引用(<code>\`\`\`</code>)</p>
</li>
<li><p>2.7 代码引用(`)</p>
</li>
<li><p>2.8 插入连接<br>Markdown支持两种链接： <strong><em>内联</em></strong> 和 <strong><em>引用</em></strong></p>
</li>
<li><p>内联<br><strong>代码</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is [an example](http://example.com/ &quot;Here is Title&quot;) inline link</span><br></pre></td></tr></table></figure>
<p><strong>效果</strong>：<br>This is <a target="_blank" rel="noopener" href="http://example.com/" title="Here is Title">an example</a> inline link</p>
</li>
<li><p>引用<br> &lt;&gt;<br> <a href></a></p>
</li>
<li><p>2.9 插入图片链接   </p>
</li>
<li><p>2.11 有序列表</p>
<ol>
<li>one</li>
<li>two</li>
</ol>
</li>
<li><p>2.12 无序列表</p>
<ul>
<li>one</li>
<li>two</li>
</ul>
</li>
<li><p>2.13 水平分割线<br><strong>代码</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">---- 或者 *** 或者 * * * 或者 - - -</span><br></pre></td></tr></table></figure>
<p><strong>效果</strong>:</p>
</li>
</ul>
<hr>
<ul>
<li>2.14 表格</li>
<li>2.15 数学公式（行内嵌）</li>
<li>2.16 数学公式（块状）</li>
</ul>
<hr>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><table>
<thead>
<tr>
<th align="left">Item</th>
<th align="right">Value</th>
<th align="center">Qty</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Computer</td>
<td align="right">1600 USD</td>
<td align="center">5</td>
</tr>
<tr>
<td align="left">Phone</td>
<td align="right">12 USD</td>
<td align="center">12</td>
</tr>
<tr>
<td align="left">Pipe</td>
<td align="right">1 USD</td>
<td align="center">234</td>
</tr>
</tbody></table>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p>flow<br>st&#x3D;&gt;start: Start<br>e&#x3D;&gt;end<br>op&#x3D;&gt;operation: My Operation<br>cond&#x3D;&gt;condition: Yes or No?</p>
<p>st-&gt;op-&gt;cond<br>cond(yes)-&gt;e<br>cond(no)-&gt;op</p>
<p>以及时序图:</p>
<p>sequence<br>Alice-&gt;Bob: Hello Bob, how are you?<br>Note right of Bob: Bob thinks<br>Bob–&gt;Alice: I am good thanks!</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jerrywang2013.github.io/2024/04/23/MarkDown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/" data-id="clwbg5x4i0001z44q4lst6lc9" data-title="MarkDown基本语法" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/05/18/QT/">QT</a>
          </li>
        
          <li>
            <a href="/2024/05/14/c-%E8%B0%83%E8%AF%95/">c++调试</a>
          </li>
        
          <li>
            <a href="/2024/05/11/%E7%94%A8libharu%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AA%E5%B0%8F%E4%BD%9C%E4%B8%9A/">用libharu完成一个小作业</a>
          </li>
        
          <li>
            <a href="/2024/05/09/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BFApacheServer%E9%85%8D%E7%BD%AE/">宝塔面板ApacheServer配置</a>
          </li>
        
          <li>
            <a href="/2024/05/07/vscode%E8%B0%83%E8%AF%95php/">vscode调试php</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
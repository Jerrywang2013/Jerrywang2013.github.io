<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Jerry Blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="learning records">
<meta property="og:type" content="website">
<meta property="og:title" content="Jerry Blogs">
<meta property="og:url" content="https://jerrywang2013.github.io/index.html">
<meta property="og:site_name" content="Jerry Blogs">
<meta property="og:description" content="learning records">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="c++ lua php js python">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Jerry Blogs" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Jerry Blogs</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://jerrywang2013.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-cuda初接触" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/15/cuda%E5%88%9D%E6%8E%A5%E8%A7%A6/" class="article-date">
  <time class="dt-published" datetime="2024-06-14T23:32:52.000Z" itemprop="datePublished">2024-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/06/15/cuda%E5%88%9D%E6%8E%A5%E8%A7%A6/">cuda初接触</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="安装cuda-toolkit"><a href="#安装cuda-toolkit" class="headerlink" title="安装cuda toolkit"></a>安装cuda toolkit</h1><ul>
<li><strong>安装</strong></li>
</ul>
<p>​		直接去nvdia官网<a target="_blank" rel="noopener" href="https://developer.nvidia.com/cuda-downloads%E4%B8%8B%E8%BD%BD%EF%BC%8C%E9%80%89%E6%8B%A9%E5%A5%BD%E4%BD%A0%E7%9A%84%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83%E5%8D%B3%E5%8F%AF%E8%8E%B7%E5%8F%96%E5%AF%B9%E5%BA%94%E7%9A%84%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E9%93%BE%E6%8E%A5(windows)%E6%88%96%E8%80%85%E5%AE%89%E8%A3%85%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA(linux)%E3%80%82%E8%BF%99%E9%87%8C%E6%88%91%E6%9C%AC%E6%9C%BAwindows11+4060Ti%EF%BC%8C%E5%AE%89%E8%A3%85%E7%9A%84%E6%98%AFV12.5%E7%89%88%E6%9C%AC%E3%80%82linux%E4%B8%8B%E5%AE%89%E8%A3%85%E6%8C%89%E7%85%A7%E5%AE%98%E7%BD%91%E7%BB%99%E5%87%BA%E7%9A%84%E6%8F%90%E7%A4%BA%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E5%8D%B3%E5%8F%AF%E3%80%82">https://developer.nvidia.com/cuda-downloads下载，选择好你的当前环境即可获取对应的下载文件链接(windows)或者安装命令提示(linux)。这里我本机windows11+4060Ti，安装的是V12.5版本。linux下安装按照官网给出的提示执行命令即可。</a></p>
<ul>
<li><strong>多版本</strong></li>
</ul>
<p>​		可以安装多个cuda版本，比如我装了cuda12.4和12.5，可以同时存在，不冲突。环境变量PATH包含的搜索路径前面的是当前启用的版本，另外就是注意CUDA_PATH这个环境变量要正确。</p>
<ul>
<li><strong>范例代码</strong></li>
</ul>
<p>​		据官网介绍，cuda11.6之后，sample不再在cuda-toolkit包中提供，而是单独的在github提供，仓库地址：<a target="_blank" rel="noopener" href="https://github.com/nvidia/cuda-samples%E3%80%82%E5%85%B7%E4%BD%93%E7%9A%84%E5%8F%82%E8%A7%81nvdia%E6%9C%89%E5%85%B3cuda">https://github.com/nvidia/cuda-samples。具体的参见nvdia有关cuda</a> sample的说明：<a target="_blank" rel="noopener" href="https://docs.nvidia.com/cuda/cuda-samples/index.html%E3%80%82%E6%97%A7%E7%89%88%E6%9C%AC%E7%9A%84sample%E6%98%AF%E5%8C%85%E5%90%AB%E5%9C%A8cuda">https://docs.nvidia.com/cuda/cuda-samples/index.html。旧版本的sample是包含在cuda</a> toolkit中，完全安装cuda toolkit本地就有sample代码。</p>
<h1 id="cuda版本和显卡兼容"><a href="#cuda版本和显卡兼容" class="headerlink" title="cuda版本和显卡兼容"></a>cuda版本和显卡兼容</h1><p>运行cuda程序，需要与构建cuda程序兼容的nvdia显卡驱动。应用程序依赖于库的动态链接，那么系统必须也要有此类库的正确版本。工具包都对于显卡驱动版本有一定的要求，比如：</p>
<table>
<thead>
<tr>
<th>CUDA toolkit</th>
<th>Windows最低驱动版本</th>
</tr>
</thead>
<tbody><tr>
<td>CUDA 10.2</td>
<td>441.22</td>
</tr>
<tr>
<td>CUDA 10.1</td>
<td>418.96</td>
</tr>
</tbody></table>
<p>​		查看本机驱动，windows下在“NVDIA控制器”面板中，点击左下角”系统信息”，可以看到驱动版本，例如本机T4060T驱动版本是555.85。或者运行nvdia-smi命令。</p>
<ul>
<li><strong>nvdia-smi</strong></li>
</ul>
<p>​		在之前的cuda toolkit里头会带有nvsmi，不过在cuda toolkit12里头并没有找到nvdia-smi工具。这个可以尝试去英伟达官网下载驱动重新安装，驱动里头一般带有此工具。我是直接安装了Studio版本的555.99-desktop-win10-win11-64bit-international-nsd-dch-whql.exe驱动，安装完毕后命令行运行nvdia-smi即可显示驱动信息</p>
<p>C:\Users\Administrator&gt;nvidia-smi<br>Sat Jun 22 17:31:15 2024<br>+—————————————————————————————–+<br>| NVIDIA-SMI 555.99                 Driver Version: 555.99         CUDA Version: 12.5     |<br>|—————————————–+————————+———————-+<br>| GPU  Name                  Driver-Model | Bus-Id          Disp.A | Volatile Uncorr. ECC |<br>| Fan  Temp   Perf          Pwr:Usage&#x2F;Cap |           Memory-Usage | GPU-Util  Compute M. |<br>|                                         |                        |               MIG M. |<br>|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|<br>|   0  NVIDIA GeForce RTX 4060 Ti   WDDM  |   00000000:01:00.0  On |                  N&#x2F;A |<br>| 33%   39C    P8             15W &#x2F;  165W |     242MiB &#x2F;  16380MiB |      2%      Default |<br>|                                         |                        |                  N&#x2F;A |<br>+—————————————–+————————+———————-+</p>
<p>+—————————————————————————————–+<br>| Processes:                                                                              |<br>|  GPU   GI   CI        PID   Type   Process name                              GPU Memory |<br>|        ID   ID                                                               Usage      |<br>|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|<br>|    0   N&#x2F;A  N&#x2F;A     20132    C+G   C:\Windows\explorer.exe                     N&#x2F;A      |<br>|    0   N&#x2F;A  N&#x2F;A     20636    C+G   …GeForce Experience\NVIDIA Share.exe      N&#x2F;A      |<br>|    0   N&#x2F;A  N&#x2F;A     21524    C+G   …siveControlPanel\SystemSettings.exe      N&#x2F;A      |<br>|    0   N&#x2F;A  N&#x2F;A     21664    C+G   …crosoft\Edge\Application\msedge.exe      N&#x2F;A      |<br>|    0   N&#x2F;A  N&#x2F;A     22632    C+G   …2txyewy\StartMenuExperienceHost.exe      N&#x2F;A      |<br>|    0   N&#x2F;A  N&#x2F;A     24856    C+G   …CBS_cw5n1h2txyewy\TextInputHost.exe      N&#x2F;A      |<br>|    0   N&#x2F;A  N&#x2F;A     26152    C+G   …__8wekyb3d8bbwe\WindowsTerminal.exe      N&#x2F;A      |<br>|    0   N&#x2F;A  N&#x2F;A     26792    C+G   C:\Program Files\Typora\Typora.exe          N&#x2F;A      |<br>+—————————————————————————————–+</p>
<ul>
<li><strong>首个cuda项目</strong></li>
</ul>
<p>​		打开VS创建第一个包含cuda运行时的项目。安装cuda会默认安装了vs支持的插件，因此在创建项目的时候选择“CUDA 12.5 Runtime”类型。创建项目后默认会创建一个kernel.cu文件，打开工程设置，可以看到原来的c++替换为cuda c++，这里配置了c++的编译选项和命令（原来的cl这里变成了nvcc)。直接编译，成功构建。运行构建好的CudaRuntime1.exe，打印出:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;1,2,3,4,5&#125; + &#123;10,20,30,40,50&#125; = &#123;11,22,33,44,55&#125;</span><br></pre></td></tr></table></figure>

<p><strong>备注</strong>：在linux环境下安装和创建类似，可以直接写cu或cpp文件，然后用nvcc编译或者写个简单的makefile。使用简单的makefile好处是可以自动搜索编译目标.cu&#x2F;.cpp文件而不用手动添加源文件（大致思路：通过find -name搜索出项目目录的所有.cu .cpp文件；然后使用patsubst替换.cu .cpp为.o，这样就构造出ALL_OBJECT目录，然后写TARGET依赖于ALL_OBJECT即可；最后记得为.o定义编译规则即可）。</p>
<p>​		公司用的是服务器上编译运行cuda测试代码；家里直接用windows，后续测试环境就在windows下测试，</p>
<h1 id="线程网格模型"><a href="#线程网格模型" class="headerlink" title="线程网格模型"></a>线程网格模型</h1><p>​		关于线程网格模型，在公司有些总结，不过公司网络和外面隔断，这里简单总结一下：</p>
<ul>
<li><p><strong>内置变量</strong></p>
<p>​		核函数有几个内置变量用于标记核函数被调度执行线程的标记信息</p>
<p>​		<strong>threadIdx</strong>[dim3(x,y,z)]: 线程索引，dim3类型，标记线程相对block在xyz三个方向上的偏移</p>
<p>​		<strong>blockIdx</strong>[dim3(x,y,z)]: 块索引，dim3类型，标记线程块相对grid在xyz三个方向上的偏移</p>
<p>​		<strong>blockDim</strong>[dim3(x,yz)]: 块维度(尺寸)，dim3类型，标记每个线程块在xyz三个方向的尺寸（或者说线程数量）</p>
<p>​		<strong>gridDim</strong>[dim3(x,yz)]: 网格维度(尺寸)，dim3类型，标记每个线程网格在xyz三个方向的尺寸（或者说块数量）</p>
<p>​		学习cuda并发编程必然会接触线程模型，这里只需要记住上面4个内置变量的含义即可。基本所有书籍都会花费比较多的篇章将网格模型以及核函数所在线程相关的id&#x2F;idx计算，有些还有错误。比如有些把grid中的block横向的xy都搞反了。</p>
<p>举个简单例子：		</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 定义网格尺寸和block_size</span><br><span class="line">grid_size = dim3(2,3,4);</span><br><span class="line">block_size = dim3(3,4,5);</span><br><span class="line">// 调用核函数</span><br><span class="line">kernel_fun&lt;&lt;&lt;grid_size , block_size &gt;&gt;&gt;()</span><br><span class="line"></span><br><span class="line">我们可以在kernel_fun中增加一条printf语句，将threadIdx.xyz和blockIdx.xyz打印出来，结合gridDim和blockDim</span><br><span class="line">就能很好的理解上述有关内置变量的定义。</span><br><span class="line">threadIdx.x取值范围是[0, block_size.x] 注意，不是[0, block_size.y]，对照打印输出的值就能看明白。</span><br><span class="line">其它的threadIdx.yz、blockIdx类似。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>维度使用场景</strong></p>
<p>​		线程模型支持三维，具体的使用几维视我们的需求而定。</p>
<ul>
<li><p><strong>一维</strong></p>
<p>简单的任务分解，比如我们想计算两个N维矢量相加的结果，Z(i) &#x3D; U(i) + V(i)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">U = [1,2,3,4,5]</span><br><span class="line">V = [10,20,30,40,50]</span><br><span class="line">Z = [11,22,33,44,55]</span><br><span class="line">__global__ void kernel_fun(z, u, v) &#123;</span><br><span class="line">	int index = threadIdx.x;</span><br><span class="line">	z[index] = u[index] + v[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>二维</strong></p>
<p>二维空间的数据处理，比如二维矩阵运算以及典型的图像处理（涉及到宽高）</p>
</li>
<li><p><strong>三维</strong></p>
<p>二维空间可能之外还有属性，比如3维空间图形处理，平面之外还有高度；或者说图形处理中，颜色Color部分和透明度Alpha部分分开处理。</p>
</li>
</ul>
<p><strong>总结：</strong></p>
<p>​		起始所谓的二维三维都是为了更好的理解业务层面的内容而引入的，我们把这里线程模型理解为c&#x2F;c++中数组，起始也没有什么二维三维甚至n维数据，在计算机看来，所有N维数组也都是一维数组，其内部都是线性连续存储，只有一个start_ptr和end_ptr的概念。之所以引入多维是为了更好的展示或者索引数据，比如二维数组<code>bitmap[row][col]</code>可以很直观的定位出像素位置，它是第row行第col列，非常直观，但是计算机内部，其位置仍然是数组bitmap的起始地址加上偏移，大概的就是：<code>pixel_ptr = bitmap_array_start_ptr + col * width_pitch + row</code> 。</p>
<p>​		嗯，多维指示业务层面更好的展示和理解，本质仍然是一维，结合数组理解。知道这个足够了！</p>
</li>
</ul>
<p>		</p>
<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p>​		这块在公司也做了一些测试，这里也只是简单记录一下。</p>
<ul>
<li><p><strong>寄存器</strong></p>
<p>​      kernel函数内部的变量，数量有限，速度最快，线程独享</p>
</li>
<li><p><strong>局部内存</strong></p>
<p>​       kernel函数内部的变量，线程独享。比较多的变量或者比较大的变量就会被降级为局部内存处理，位于处理单元上的，速度也很快，大小有限</p>
</li>
<li><p><strong>共享内存</strong></p>
<p>​       在kernel函数中用__shared__定义的内存，block中线程共享，速度也比较块，大小有限。</p>
</li>
<li><p><strong>全局内存&#x2F;常量内存</strong></p>
<p>​        也就是我们说的显存，速度慢，空间大。纹理内存类似，只不过针对性的优化处理。全局内存第一种形式是用<code>__device__</code>声明的静态全局内存；第二种方式是用<code>__cudaMalloc__</code>动态创建。</p>
</li>
</ul>
<p><strong>记录踩坑</strong>：</p>
<p>1、<code>__device__</code>定义的变量，其静态全局内存定义的是符号，不是地址，这个和我们在c中定义数组，数组名可以当地址用是不一样的。你在host端代码不能直接用cudaMemcpy通过变量名拷贝；因为cudaMemory只能拷贝地址。解决办法是调用cudaMemcpyFromSymbol或者先获取symbol地址再调用cudaMemcpy拷贝；</p>
<p>2、多思考共享内存的使用，这个还是非常有用的，这个对于设计好的核函数是很有帮助。</p>
<p>​		</p>
<p>​		</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jerrywang2013.github.io/2024/06/15/cuda%E5%88%9D%E6%8E%A5%E8%A7%A6/" data-id="clxpujbsw00003c4qdp0d38jd" data-title="cuda初接触" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-git常用操作" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/11/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/" class="article-date">
  <time class="dt-published" datetime="2024-06-11T15:50:53.000Z" itemprop="datePublished">2024-06-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/06/11/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/">git常用操作</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><p><strong>克隆项目到本地</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>将本地变动文件（新加、修改）添加到暂存区</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>提交</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;comment&quot;</span><br></pre></td></tr></table></figure>

<p>说明：将暂存区内容提交到本地版本服务器，形成一次提交操作，有对应的日志，后续可以根据此日志来恢复</p>
</li>
<li><p><strong>推送</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push [&lt;远程主机名&gt; [&lt;远程分支名&gt;]]</span><br><span class="line">git push origin 将当前分支推送到远程仓库的同名分支</span><br><span class="line">git push origin &lt;远程分支名&gt; 将当前分支推送到远程仓库的指定分支</span><br></pre></td></tr></table></figure>

<p>如果设置了上游分支，直接用git push就行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream &lt;remote&gt; &lt;breanch&gt;  </span><br><span class="line">git branch --set-upstream-to=&lt;remote&gt;/&lt;branch&gt; &lt;本地分支名&gt;</span><br><span class="line">//  设置上游分支</span><br><span class="line">git branch --set-upstream-to=origin/another-branch</span><br></pre></td></tr></table></figure>

<p>如果没有设置上游分支，第一次push的时候可以用git push -u origin <branch> 来设置，之后就可以直接用git push推送当前分支的修改。</branch></p>
</li>
<li><p><strong>重置暂存区</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset head</span><br></pre></td></tr></table></figure>

<p>重置暂存区为，将其恢复到当前分支head指针指向的提交相同的状态。不影响工作区文件，只会影响暂存区且尚未提交的更改。</p>
</li>
<li><p><strong>取消暂存</strong></p>
<p>  比如1.txt文件修改了并且git add被加入到暂存区，此时如果想将1.txt从暂存区中移出（避免下次提交到）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git restore --staged 1.txt</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>恢复工作区文件</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git restore file.txt 恢复file.txt到当前分支最新提交</span><br><span class="line">git restore --<span class="built_in">source</span>=main file.txt 将file.txt恢复到main分支的最新提交</span><br><span class="line">git restore --staged file.txt 恢复暂存区中的文件</span><br><span class="line">git restore --<span class="built_in">source</span>=1a2b3c4d file.txt  从提交 1a2b3c4d 恢复 file.txt</span><br><span class="line">// git checkout  已经不建议使用</span><br><span class="line">git checkout main -- file.txt  恢复工作区文件file.txt到main分支的状态</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>从版本控制中删除文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git  rm --cached 1.txt </span><br><span class="line">git commit -m &quot;Remove 1.txt from version control&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>移除版本控制之后，本地工作区文件存在，此时如果切换到其它分支会提示此untracked的工作区文件可能会被重写。主要是其它分支有此文件，切换工作区可能会改写此未被跟踪的文件造成意外情况，解决办法有：</p>
<ul>
<li><p><strong>手动备份</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">move 1.txt 1.txt.bak</span><br><span class="line">git checkout new-feature</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>暂存未被追踪的文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash push -m &quot;sss&quot; --include-untracked</span><br><span class="line">git checkout new-feature</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>强制切换分支</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -f new-feature</span><br></pre></td></tr></table></figure>

<p>可能存在未被追踪的文件数据丢失！</p>
</li>
</ul>
</li>
<li><p><strong>显示日志</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br><span class="line">git reflog</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><ul>
<li><p><strong>查看分支</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git branch -v   查看本地分支</span><br><span class="line">git branch -v   查看本地分支 带详细信息</span><br><span class="line">git branch -vv  查看本地分支，带上游信息</span><br><span class="line">git branch -r  查看远程分支</span><br><span class="line">git branch -rv  查看远程分支，带详细信息</span><br><span class="line">git branch -r  查看全部分支</span><br><span class="line">本地分支和远程分支颜色显示不同，当前分支颜色也特殊标记</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建分支</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch new-feature </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>切换分支</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git switch new-feature</span><br><span class="line">git checout new-feature  // 不推荐使用</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建分支并且切换到新分支</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git switch -c new-feature </span><br><span class="line">git branch -b new-feature </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>从远程分支origin&#x2F;feature-branch创建本地分支</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b new-feature origin/feature-branch</span><br></pre></td></tr></table></figure>
</li>
<li><p>从本地develop创建分支</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b feature-branch develop</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>推送到远程服务器并且创建一个同名的远程分支</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin new-feature</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建本地分支后，推送并创建远程分支 -u可以设置上游分支</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin feature-branch</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>合并分支</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git merge new-feature  </span><br><span class="line">将new-feature分支内容合并到当前分支。如果有冲突，需要手动编辑冲突文件然后再add | commit | push</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><strong>暂存区（Index&#x2F;Staging Area）</strong>：这是一个临时区域，用于存储即将提交的更改。当你使用 <code>git add</code> 命令时，文件的更改会被添加到暂存区。</li>
<li><strong>工作区（Working Directory）</strong>：这是你实际进行开发和修改文件的地方。工作区中的文件可能已经被修改，但还没有被添加到暂存区。</li>
<li><strong>HEAD</strong>：这是一个指针，指向当前分支的最新提交。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jerrywang2013.github.io/2024/06/11/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/" data-id="clxamrsc80000k44q0u412w05" data-title="git常用操作" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-QObject简单笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/06/QObject%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2024-06-06T13:04:13.000Z" itemprop="datePublished">2024-06-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/06/06/QObject%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/">QObject简单笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>记录一下QObject有关元对象一些数据和实现细节。</p>
<p>用ProcessOn在线画了一张图，导出为图片，直接附上。</p>
<p><img src="/2024/06/06/QObject%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/QObjectUML.png" alt="QObject类图"></p>
<ul>
<li>SIGNAL&#x2F;SLOT宏会在函数原型字符串前面增加一个数字编号1或者2，这个是创建连接的时候用于区分signal和slot。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jerrywang2013.github.io/2024/06/06/QObject%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/" data-id="clx39vhck0000yc4q3h2q21z1" data-title="QObject简单笔记" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-c-11" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/05/27/c-11/" class="article-date">
  <time class="dt-published" datetime="2024-05-27T03:49:14.000Z" itemprop="datePublished">2024-05-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/05/27/c-11/">c++11</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>接触QT，里头用到C++11新特性，打算简单了解一下。</p>
<h1 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h1><p>​		扩大列表初始化使用范围，对所有内置类型和自定义类型都可以用列表初始化方法，并且可以省略&#x3D;号。另外还支持部分内置容器的初始化列表</p>
<ul>
<li><p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">​		int x;</span><br><span class="line">​		int y;</span><br><span class="line">&#125;</span><br><span class="line">Point p=&#123;1,2&#125;; // OK</span><br><span class="line">Point p&#123;1,2&#125;; // 自定义类型OK 省略=</span><br><span class="line">int a&#123;100&#125;;  // 内置类型OK 省略=</span><br><span class="line">std::vector&lt;int&gt; v&#123;1,2,3&#125;; // OK</span><br><span class="line">std::initializer_list&lt;int&gt; il&#123; 2,3,4,5 &#125;;</span><br><span class="line">v = il; // OK</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="变量类型推导"><a href="#变量类型推导" class="headerlink" title="变量类型推导"></a>变量类型推导</h1><p>​		c++11提供了多种简化声明的方式，特别是使用模板时。</p>
<ul>
<li><p>auto关键字		</p>
<p>​		自动类型推导，要求显示初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void sum(int a, int b)&#123;&#125;</span><br><span class="line">int aaa = 1;</span><br><span class="line">auto ap1 = aaa;</span><br><span class="line">auto ap2 = sum;</span><br><span class="line">auto it = vec.begin(); // vec::iterator</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>auto elem 是推导出值类型，不影响原始数据；auto &amp;elem是推导出引用类型，直接影响原始数据。</p>
</li>
<li><p>decltype</p>
<p>​	将变量类型声明为表达式指定的类型。注意，参数是一个表达式，不能是一个类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto ap2 = sum;</span><br><span class="line">decltype(ap2) c;</span><br><span class="line">cout &lt;&lt; typeid(c).name() &lt;&lt; endl; // int (__cdecl*)(int,int)</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h1><p>​	c++11之前空指针用NULL，这个起始和0没区别，容易引起歧义（比如函数重载）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void fn(int); </span><br><span class="line">void fn(int*)</span><br><span class="line">fn(NULL)可能会调用fn(int)</span><br><span class="line">fn(nullptr)明确调用fn(int*)</span><br></pre></td></tr></table></figure>



<h1 id="范围循环"><a href="#范围循环" class="headerlink" title="范围循环"></a>范围循环</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (auto&amp; elem : vec) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;   item:&quot; &lt;&lt; elem &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>修饰类时，指示类不可被继承；修饰函数时，指示函数不可被重写。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A final </span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">class B : public A  // error</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virutal void fun() final</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B : public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void fun() &#123;  // error    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="override"><a href="#override" class="headerlink" title="override"></a>override</h1><p>检查派生类虚函数是否是重写了基类的某个虚函数，如果没有重写则编译报错</p>
<h1 id="新增容器"><a href="#新增容器" class="headerlink" title="新增容器"></a>新增容器</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array</span><br><span class="line">forward_list</span><br><span class="line">unordered_map</span><br><span class="line">unordered_set</span><br></pre></td></tr></table></figure>



<h1 id="default"><a href="#default" class="headerlink" title="default"></a>default</h1><p><code>default</code> 关键字可以用于以下几种成员函数：</p>
<ol>
<li><strong>默认构造函数</strong></li>
<li><strong>析构函数</strong></li>
<li><strong>拷贝构造函数</strong></li>
<li><strong>拷贝赋值运算符</strong></li>
<li><strong>移动构造函数</strong></li>
<li><strong>移动赋值运算符</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123; </span><br><span class="line">public:    </span><br><span class="line">	MyClass() = default;                     // 默认构造函数    </span><br><span class="line">	~MyClass() = default;                    // 析构函数    </span><br><span class="line">	MyClass(const MyClass&amp;) = default;       // 拷贝构造函数    </span><br><span class="line">	MyClass&amp; operator=(const MyClass&amp;) = default;  // 拷贝赋值运算符</span><br><span class="line">	MyClass(MyClass&amp;&amp;) = default;            // 移动构造函数    </span><br><span class="line">	MyClass&amp; operator=(MyClass&amp;&amp;) = default; // 移动赋值运算符 </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>应用场景：</p>
<p>比如你写了一个自定义带参数的构造函数，那么编译器不会给你生成默认构造函数，此时你直接用MyClass()会报错，这种情况下，可以用MyClass()&#x3D;default;就可以用MyClass c;</p>
<h1 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h1><p>​	在c++11之前只有左值引用。所谓左值是指出现在等号左边，比如常见的变量可以在等号左边，它是左值。常量不能出现在等号左边，所以它是右值。</p>
<h2 id="左值-右值"><a href="#左值-右值" class="headerlink" title="左值&amp;右值"></a>左值&amp;右值</h2><p>​		左值：可以取其地址，例如：变量、引用等；</p>
<p>​		右值：表示一个临时对象或者字面值，通常无法取其地址。例如：字面值、临时对象、表达式的结果等；</p>
<h2 id="右值引用语法："><a href="#右值引用语法：" class="headerlink" title="右值引用语法：&amp;&amp;"></a>右值引用语法：&amp;&amp;</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int&amp;&amp; rvalueRef = 10;</span><br></pre></td></tr></table></figure>

<h2 id="右值引用用途"><a href="#右值引用用途" class="headerlink" title="右值引用用途"></a>右值引用用途</h2><h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><p>​		移动语义让我们‘移动’资源而不是拷贝资源，提高性能。移动操作只需要转移资源的所有权，而不需要实际的数据拷贝。</p>
<h3 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h3><ul>
<li><p>通用引用(universal reference) </p>
<p>template<T> void func(T&amp;&amp; value){}</T></p>
<p>​		当模版参数T是通过类型推导获得时，T&amp;&amp;被称之为通用引用，通用引用是可以绑定到左值或者右值的，而不是表面上看上去的右值。</p>
</li>
<li><p>折叠规则</p>
<p>c++有一套引用折叠规则：</p>
<ul>
<li>T&amp; &amp;、T&amp; &amp;&amp;和T&amp;&amp; &amp;都折叠为T&amp;</li>
<li>T&amp;&amp; &amp;&amp;折叠为T&amp;&amp;</li>
</ul>
</li>
</ul>
<p>完美转发示例：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void processValue(int&amp; value)</span><br><span class="line"> &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Lvalue: &quot; &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    value = 42;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void processValue(int&amp;&amp; value) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Rvalue: &quot; &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void forwardValue(T&amp;&amp; value) </span><br><span class="line">&#123;</span><br><span class="line">    processValue(std::forward&lt;T&gt;(value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int x = 10;</span><br><span class="line">    forwardValue(x);  // 传递左值</span><br><span class="line">    std::cout &lt;&lt; &quot;After forwarding, x = &quot; &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    forwardValue(20);  // 传递右值</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>右值引用规则</p>
<ul>
<li>引用折叠</li>
<li>标准库中的右值引用</li>
</ul>
</li>
</ul>
<p>​	左值引用只能引用左值，不能引用右值；</p>
<p>​	通常临时变量是不能左值引用的，例如int &amp;a &#x3D; 123;这个就是错误的。但是通过常量引用，可以对临时变量或者函数返回的临时对象进行引用，此举相当于告诉编译器将临时变量的生命空间延长，与引用变量的生命空间保持一致。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> int a = 10;</span><br><span class="line"> int&amp; b = a;</span><br><span class="line"> int&amp; c = 10;  // error 非常量引用的初始值必须为左值</span><br><span class="line"> const int&amp; d = 10; // ok</span><br><span class="line"> const string&amp; str2 = &quot;abc&quot;; // ok，提升临时变量的生命空间和str2保持一致</span><br><span class="line"> const string&amp; str3 = [str2](const char *str) -&gt; string&#123;</span><br><span class="line">	return str + str2;</span><br><span class="line">	&#125;(&quot;123&quot;);// ok 提升临时变量的生命空间和str3一致</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">bool isOdd(int&amp; num)</span><br><span class="line">&#123;</span><br><span class="line">	return 0 == num % 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isOdd_r(int&amp;&amp; num) &#123;</span><br><span class="line">	return 0 == num % 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test() &#123;</span><br><span class="line">	int a = 10;</span><br><span class="line">	cout &lt;&lt; isOdd(2); // error 非常量引用的初始值必须为左值</span><br><span class="line">	cout &lt;&lt; isOdd(a); // ok</span><br><span class="line">    cout &lt;&lt; isOdd(a+2); // error 非常量引用的初始值必须为左值</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; isOdd_r(2);  // ok</span><br><span class="line">	cout &lt;&lt; isOdd_r(a); // error 右值引用初始值必须是右值</span><br><span class="line">	cout &lt;&lt; isOdd_r(a + 2); // ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	右值除了可以是字面常量、还可以是临时对象，例如表达式返回值、传值返回类型的返回值（不能是引用返回类型）等。</p>
<p>​	右值引用允许我们操作右值（临时对象、字面常量等），从而避免不必要的拷贝。右值引用其实是告诉编译器这是一个可移动对象。当我们写 MyClass c &#x3D; xxx; 时，编译器会根据 xxx 的类型来选择合适的构造函数。如果 xxx 是一个可移动的对象（即右值引用），并且 MyClass 有一个移动构造函数，那么编译器会调用移动构造函数来构造 c 对象。</p>
<p><strong>构造函数选择的规则</strong></p>
<ul>
<li><p>如果 xxx 是一个右值：</p>
<ul>
<li>​	编译器会优先选择移动构造函数（MyClass(MyClass&amp;&amp;)），如果存在的话。</li>
<li>如果没有移动构造函数，编译器会尝试使用拷贝构造函数（MyClass(const MyClass&amp;)）。</li>
</ul>
</li>
<li><p>如果 xxx 是一个左值：</p>
<p>编译器会选择拷贝构造函数（MyClass(const MyClass&amp;)）。</p>
</li>
</ul>
<p><strong>移动构造函数和移动赋值操作</strong></p>
<ul>
<li><p>手动实现拷贝构造和拷贝赋值函数</p>
</li>
<li><p>如果没有手动实现拷贝构造和拷贝赋值方法，编译器会生成默认的移动构造和移动赋值函数。</p>
<p>如果是可移动对象，但是没有移动构造（比如手动实现了拷贝构造但是没有实现移动构造）和移动赋值函数，那么编译器会用拷贝构造和赋值操作替代。</p>
</li>
</ul>
<h1 id="using"><a href="#using" class="headerlink" title="using"></a>using</h1><p>在以前的c++中，using用于引入命名空间，在c++11中，using可以用于定义类型别名，相当于typedef。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个 vector&lt;int&gt; 的别名</span></span><br><span class="line"><span class="keyword">using</span> IntVector = std::vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="comment">// 定义一个 map&lt;string, int&gt; 的别名</span></span><br><span class="line"><span class="keyword">using</span> StringIntMap = std::map&lt;std::string, <span class="type">int</span>&gt;;</span><br><span class="line">IntVector vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">StringIntMap map = &#123;&#123;<span class="string">&quot;one&quot;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&quot;two&quot;</span>, <span class="number">2</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="std-iota"><a href="#std-iota" class="headerlink" title="std::iota"></a>std::iota</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">iota</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">1</span>);</span><br></pre></td></tr></table></figure>



<h1 id="std-generate"><a href="#std-generate" class="headerlink" title="std::generate"></a>std::generate</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">generate</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [&amp;n]() &#123; <span class="keyword">return</span> n += <span class="number">2</span>; &#125;); <span class="comment">// 生成2的倍数</span></span><br></pre></td></tr></table></figure>



<h1 id="std-fill"><a href="#std-fill" class="headerlink" title="std::fill"></a>std::fill</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">fill</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">42</span>);</span><br></pre></td></tr></table></figure>



<h1 id="资源管理指针"><a href="#资源管理指针" class="headerlink" title="资源管理指针"></a>资源管理指针</h1><ul>
<li><p>unique_ptr</p>
<p>独占式智能指针，用于管理唯一对象，确保只有一个指针可以访问该对象；unique_ptr可以自动释放动态分配的内存，当指针超过作用域或者被重置，会自动删除所管理的对象。</p>
<p>注意：unique_ptr是不能用左值赋值的，只能用右值引用赋值，因为默认拷贝构造函数和赋值运算符操作都被禁止。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr(const unique_ptr&amp;)            = delete;</span><br><span class="line"> unique_ptr&amp; operator=(const unique_ptr&amp;) = delete;</span><br></pre></td></tr></table></figure>
</li>
<li><p>shared_ptr</p>
<p>共享智能指针，引用计数技术实现。当引用技术为0时自动销毁对象，com技术里头主要用到的就是共享智能指针。</p>
</li>
<li><p>weak_ptr</p>
<p>弱指针，不会增长引用计数，它可以解决shared_ptr循环引用问题。当所有的shared_ptr超出作用域之后，哪怕还有weak_ptr，所管理的对象也会被销毁。</p>
<p>例如：两个share_ptr<Node> 指针AB，Node里头又有一个shared_ptr<Node> next，A的next成员指向B，B的next成员指向A，这样就会出现循环引用。解决办法是将Node的next成员改为weak_ptr类型。</Node></Node></p>
<p>注意：weak_ptr弱引用是维护的智能指针控制块的weak_refcount，shared_ptr维护的是refcount，是两个独立的计数。weakptr需要和sharedptr引用的是同一个控制块！</p>
</li>
</ul>
<h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><p>语法：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[capture list](parameters) -&gt; return_type &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>capture_list：要捕获的变量列表（类似其他语言的using），匿名函数中需要用到的外部变量列表</p>
<ul>
<li>[&#x3D;] 表示捕获外部作用域的所有变量</li>
<li>[&amp;]按照引用捕获外部作用域所有变量</li>
<li>[a, &amp;b]按照值捕获变量a，按照引用捕获变量b</li>
<li>[this]捕获当前对象的this指针</li>
<li>[] 不捕获任何变量</li>
</ul>
<p>parameters：参数列表</p>
<p>return_type： 返回值类型，可以用auto自动推导</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto f_sum = [](int a, int b)-&gt;auto &#123;</span><br><span class="line">		return a * b;</span><br><span class="line">	&#125;;</span><br><span class="line">cout &lt;&lt; f_sum(2, 3) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>



<h1 id="变参模版"><a href="#变参模版" class="headerlink" title="变参模版"></a>变参模版</h1><p>​		允许函数或者类模版接受可变数量参数，使用…表示可变参数。</p>
<p>例如：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// c++10/14</span><br><span class="line">// 处理单个参数的函数</span><br><span class="line">void print() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;End of recursion\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 处理参数包的函数</span><br><span class="line">template&lt;typename T, typename... Args&gt;</span><br><span class="line">void print(T first, Args... args) &#123;</span><br><span class="line">    std::cout &lt;&lt; first &lt;&lt; &quot; &quot;;</span><br><span class="line">    print(args...); // 递归调用，展开参数包</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    print(1, 2, 3.5, &quot;Hello&quot;, &#x27;c&#x27;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">对于c++17</span><br><span class="line">// 使用折叠表达式处理参数包</span><br><span class="line">template&lt;typename... Args&gt;</span><br><span class="line">void print(Args... args) &#123;</span><br><span class="line">    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; &#x27;\n&#x27;; // 左折叠表达式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c++11&#x2F;14采用递归方式来进行可变参数展开；c++17采用折叠表达式展开可变参数。</p>
<p>折叠表达式的基本形式如下：</p>
<ol>
<li><strong>一元左折叠</strong>：<code>(... op pack)</code></li>
<li><strong>一元右折叠</strong>：<code>(pack op ...)</code></li>
<li><strong>二元左折叠</strong>：<code>(init op ... op pack)</code></li>
<li><strong>二元右折叠</strong>：<code>(pack op ... op init)</code></li>
</ol>
<p>其中，<code>op</code> 是一个二元运算符，<code>pack</code> 是参数包，<code>init</code> 是初始值。</p>
<h2 id="一元左折叠"><a href="#一元左折叠" class="headerlink" title="一元左折叠"></a>一元左折叠</h2><p>一元左折叠的语法是 <code>(... op pack)</code>，表示从左到右依次将参数包中的每个参数与运算符 <code>op</code> 进行运算。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (... + args); <span class="comment">// 一元左折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 输出 15</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一元右折叠"><a href="#一元右折叠" class="headerlink" title="一元右折叠"></a>一元右折叠</h2><p>一元右折叠的语法是 <code>(pack op ...)</code>，表示从右到左依次将参数包中的每个参数与运算符 <code>op</code> 进行运算。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args + ...); <span class="comment">// 一元右折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 输出 15</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二元左折叠"><a href="#二元左折叠" class="headerlink" title="二元左折叠"></a>二元左折叠</h2><p>二元左折叠的语法是 <code>(init op ... op pack)</code>，其中 <code>init</code> 是初始值，表示从左到右依次将初始值和参数包中的每个参数与运算符 <code>op</code> 进行运算。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span> + ... + args); <span class="comment">// 二元左折叠，初始值为 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 输出 15</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二元右折叠"><a href="#二元右折叠" class="headerlink" title="二元右折叠"></a>二元右折叠</h2><p>二元右折叠的语法是 <code>(pack op ... op init)</code>，其中 <code>init</code> 是初始值，表示从右到左依次将参数包中的每个参数和初始值与运算符 <code>op</code> 进行运算。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args + ... + <span class="number">0</span>); <span class="comment">// 二元右折叠，初始值为 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 输出 15</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="支持的运算符"><a href="#支持的运算符" class="headerlink" title="支持的运算符"></a>支持的运算符</h2><p>折叠表达式支持多种二元运算符，包括但不限于：</p>
<ul>
<li>算术运算符：<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code></li>
<li>逻辑运算符：<code>&amp;&amp;</code>, <code>||</code></li>
<li>位运算符：<code>&amp;</code>, <code>|</code>, <code>^</code></li>
<li>比较运算符：<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></li>
<li>其他运算符：<code>,</code>, <code>.*</code>, <code>-&gt;*</code></li>
</ul>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>Q：vs宏__cplusplus始终显示199711L</p>
<p>A：在vs项目属性设置里头的“c++语言标准”里头设置了c++11或者c++17版本，代码里头看到__cplusplus宏始终显示199711L，这是考虑到历史代码兼容性问题（很多老代码用到此宏），编译器不会修改此宏，除非通过 &#x2F;Zc:cplusplus显示设置。在vc中可以使用_MSVC_LANG宏来获取当前用的语言标准版本</p>
<p>Q：MSVC中函数传值返回一个对象，调试发现并没有调用移动构造函数</p>
<p>A：这是因为MSVC编译器有可能做了RVO（返回值优化），通常是默认开启的，测试发现哪怕禁用优化，RVO还是生效。此种情况下，编译器可能直接在调用者的变量空间中构造返回的对象。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/650986900">https://zhuanlan.zhihu.com/p/650986900</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/455848360">https://zhuanlan.zhihu.com/p/455848360</a></p>
<p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/">https://en.cppreference.com/w/</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/650986900">https://zhuanlan.zhihu.com/p/650986900</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/139515439">https://zhuanlan.zhihu.com/p/139515439</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jerrywang2013.github.io/2024/05/27/c-11/" data-id="clwofja4x0000oo4q1oi39uw7" data-title="c++11" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-QT" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/05/18/QT/" class="article-date">
  <time class="dt-published" datetime="2024-05-18T00:56:13.000Z" itemprop="datePublished">2024-05-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/05/18/QT/">QT</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="QGlobal"><a href="#QGlobal" class="headerlink" title="QGlobal"></a>QGlobal</h1><p>​		QGlobal.h中定义了一些全局的类型定义、宏、函数</p>
<p>类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">qint8 | qint16 |qint32 |qint64   quint8 | quint16 |quint32 |quint64</span><br><span class="line">qlonglong | qulonglong  qreal</span><br><span class="line">uchar | uint | ulong | ushort  这里uint是unsigned int</span><br></pre></td></tr></table></figure>

<p>函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qAbs | qBound | qMax | qMin | qRound | qRound64 | qOverload | qVersion | q_check_ptr</span><br></pre></td></tr></table></figure>

<p>宏</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">QT_DEPRECATED_WARNINGS | QT_VERSION | QT_VERSION_CHECK | QT_VERSION_STR</span><br><span class="line">Q_ASSERT | Q_ASSERT_X</span><br><span class="line">Q_BYTE_ORDER | Q_BIG_ENDIAN | Q_LITTLE_ENDIAN</span><br><span class="line">Q_DECL_EXPORT | Q_DECL_IMPORT</span><br><span class="line">foreach(var, container)</span><br><span class="line">qDebug | qInfo | qWarning | qCritical | qFatal</span><br><span class="line">qMove</span><br><span class="line">qPrintable: 将QString转为const char*，等价于str.toLocal8Bit().constData()</span><br><span class="line">qUtf8Printable: 转为utf8编码格式的const char *</span><br><span class="line">qUtf16Printable：QString转为const ushort*，等价于str.utf16()</span><br></pre></td></tr></table></figure>



<h1 id="QString"><a href="#QString" class="headerlink" title="QString"></a>QString</h1><p>QT字符串类，包括字符操作、编码转换、字符串和数值转换（包括进制）</p>
<ul>
<li><p>static函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">QString::asprintf(const char *format);</span><br><span class="line">vasprintf(const char *format, va_list ap);</span><br><span class="line">fromLatin1</span><br><span class="line">fromLocal8Bit</span><br><span class="line">fromStdString</span><br><span class="line">fromUcs4</span><br><span class="line">fromUtf8</span><br><span class="line">fromUtf16</span><br><span class="line">fromWCharArray</span><br><span class="line">number() ==&gt; 数值型转为字符串</span><br></pre></td></tr></table></figure>


</li>
<li><p>字符串&lt;&#x3D;&gt;数值转换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">数值=&gt;字符串</span><br><span class="line">QString QString::number(long n, int base = 10)</span><br><span class="line">QString&amp; setnum()</span><br><span class="line">arg()</span><br><span class="line"></span><br><span class="line">字符串=&gt;数值</span><br><span class="line">toInt | toLong | toLongLong |toFloat</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">int intValue = 42;</span><br><span class="line">double doubleValue = 3.14159;</span><br><span class="line">QString intString = QString::number(intValue); // &quot;42&quot;</span><br><span class="line">QString doubleString = QString::number(doubleValue, &#x27;f&#x27;, 2); </span><br><span class="line"></span><br><span class="line">int intValue = 42;</span><br><span class="line">double doubleValue = 3.14159;</span><br><span class="line">QString formattedString = QString(&quot;Integer: %1, Double: %2&quot;).arg(intValue).arg(doubleValue, 0, &#x27;f&#x27;, 2);</span><br><span class="line"></span><br><span class="line">int intValue = intString.toInt(&amp;ok);</span><br><span class="line">float floatValue = floatString.toFloat(&amp;ok);</span><br><span class="line">double doubleValue = doubleString.toDouble(&amp;ok);</span><br></pre></td></tr></table></figure>


</li>
<li><p>编码转换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// QString 转utf8、Latin1、local 8bit</span><br><span class="line">QString()::toUtf8() | toLatin1() | toLocal8Bit()</span><br><span class="line">// 从XX转为QString</span><br><span class="line">QString::fromUtf8() | fromLatin1() | from Local8Bit</span><br></pre></td></tr></table></figure>

<p>也可以借助QTextCodec类完成复杂的编码转换，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QTextCodec&gt; </span><br><span class="line">QString str = &quot;你好，世界&quot;; </span><br><span class="line">// 将 QString 转换为 GBK 编码的 </span><br><span class="line">QByteArray QTextCodec *codec = QTextCodec::codecForName(&quot;GBK&quot;); </span><br><span class="line">QByteArray gbkBytes = codec-&gt;fromUnicode(str); </span><br><span class="line">// 从 GBK 编码的 QByteArray 转换为 QString </span><br><span class="line">QString decodedStr = codec-&gt;toUnicode(gbkBytes);</span><br></pre></td></tr></table></figure>

<p>QT6里头有QStringConverter用于编码转换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QStringConverter&gt; </span><br><span class="line">QString str = &quot;Hello, 世界&quot;; </span><br><span class="line">// 将 QString 转换为 UTF-8 编码的 </span><br><span class="line">QByteArray auto utf8Bytes = QStringConverter::encode(QStringConverter::Utf8, str); </span><br><span class="line">// 从 UTF-8 编码的 QByteArray 转换为 QString </span><br><span class="line">auto decodedStr = QStringConverter::decode(QStringConverter::Utf8, utf8Bytes);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="日期时间类"><a href="#日期时间类" class="headerlink" title="日期时间类"></a>日期时间类</h1><p>QTime</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 构造QTime类</span><br><span class="line">currentTime()</span><br><span class="line">fromString(const QString &amp;string, const QString &amp;format)</span><br><span class="line">// 时间格式化，例如 HH-mm-ss</span><br><span class="line">toString(format)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 获取小时、分钟、秒、毫秒</span><br><span class="line">hour() | minute() | second() | msec()</span><br><span class="line">// 时间比较</span><br><span class="line">operator&lt; | &lt;= | == | &gt; | &gt;=</span><br><span class="line"></span><br><span class="line">// 用于计时类</span><br><span class="line">QTime t;</span><br><span class="line">t.start();</span><br><span class="line">do_some_task();</span><br><span class="line">qDebug(&quot;time elapsed:%d ms&quot;, t.elapsed());</span><br></pre></td></tr></table></figure>

<p>QDate</p>
<p>QDateTime</p>
<h1 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h1><h2 id="Q：如何理解qt中的signal和slot"><a href="#Q：如何理解qt中的signal和slot" class="headerlink" title="Q：如何理解qt中的signal和slot"></a>Q：<strong>如何理解qt中的signal和slot</strong></h2><p>A：简单点说，signal类似事件或者消息，slot类似事件或者消息handler；常见的需求是动作发生后对应的事件（或者消息）被触发进而触发对应的handler处理，这样的话，只需要捕获动作对应的事件和消息即可。slot这里可以自定义，也有一部分预先定义好的，比如window有一个关闭的slot，那么我们可以将一个按钮的点击信号关联到窗口的关闭handler，实现点击按钮就关闭窗口的效果。</p>
<p>​		用slot这个概念很形象，功能handler就像一个插槽一样，这里的siganal和slot就像将电线接到插槽上形成通路一样，signal发出就会触发handler执行。</p>
<p>signale和slot的连接通过 <code>**QObject::connect**</code>实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FooObjectA *fooA = new FooObjectA();</span><br><span class="line">FooObjectB *fooB = new FooObjectB();</span><br><span class="line"></span><br><span class="line">QObject::connect(fooA, SIGNAL(bared()), fooB, SLOT (baz()));</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li><p>信号由对象发出，表示某个事件发生，例如按钮点击会发出一个clicked()信号。信号不需要再类外定义，它们由qt的元系统（MOS）自动生成。</p>
</li>
<li><p>槽是一个函数，可以连接到信号，信号发生时，连接到该信号的槽函数被调用。槽可以是任意成员函数、全局函数或者lambda表达式。槽需要在类外定义，和普通成员函数一样。</p>
</li>
<li><p>signal可以连接signal，从这个角度看，signal可以充当信号中转。</p>
<p>例如： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class MyWidget : public QWidget</span><br><span class="line"> &#123;</span><br><span class="line">     Q_OBJECT</span><br><span class="line"> public:</span><br><span class="line">     MyWidget();</span><br><span class="line"> signals:</span><br><span class="line">     void buttonClicked();</span><br><span class="line"> private:</span><br><span class="line">     QPushButton *myButton;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> MyWidget::MyWidget()</span><br><span class="line"> &#123;</span><br><span class="line">     myButton = new QPushButton(this);</span><br><span class="line">     connect(myButton, SIGNAL(clicked()),</span><br><span class="line">             this, SIGNAL(buttonClicked()));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



</li>
<li><p>connect有多个重载版本，使用SIGNAL宏的好处是可以指定带参数的型号，并且不需要指定类名</p>
<p>如果不用SIGNAL需要将重载成员函数进行明确的类型转换指定确定的重载版本，</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span> : <span class="keyword">public</span> QObject &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">valueChanged</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">valueChanged</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">QObject::<span class="built_in">connect</span>(obj, <span class="built_in">static_cast</span>&lt;<span class="built_in">void</span> (MyObject::*)(<span class="type">int</span>)&gt;(&amp;MyObject::valueChanged), [](<span class="type">int</span> value) &#123;</span><br><span class="line">    <span class="comment">// 处理 int 类型的 valueChanged 信号</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">QObject::<span class="built_in">connect</span>(obj, <span class="built_in">static_cast</span>&lt;<span class="built_in">void</span> (MyObject::*)(<span class="type">double</span>)&gt;(&amp;MyObject::valueChanged), [](<span class="type">double</span> value) &#123;</span><br><span class="line">    <span class="comment">// 处理 double 类型的 valueChanged 信号</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Q：Qt-Designer对mainwindow重置布局就会导致程序崩溃"><a href="#Q：Qt-Designer对mainwindow重置布局就会导致程序崩溃" class="headerlink" title="Q：Qt Designer对mainwindow重置布局就会导致程序崩溃"></a><strong>Q：Qt Designer对mainwindow重置布局就会导致程序崩溃</strong></h2><p><strong>A：</strong>暂时不知！</p>
<h2 id="Q-Qt-designer中如何用自定义类替换默认的widget类"><a href="#Q-Qt-designer中如何用自定义类替换默认的widget类" class="headerlink" title="Q: Qt designer中如何用自定义类替换默认的widget类"></a>Q: Qt designer中如何用自定义类替换默认的widget类</h2><p>A：比如说Designer中有一个PushButton，我们写了一个自定义的CustomPushButton类，派生自PushButton，有自定义的slot例如myButtonSlot，我们想在Designer中创建连接，选择PushButton然后能选择myButtonSlot。经过测试发现，可以通过在Designer中选择模板PushButton按钮，右键菜单选择“提升”，在弹出的提升对话框中编辑“提升类名称”为CustomPushButton，点击“添加”，添加完毕之后再点击“提升”就可以将此空间提升为CustomPushButton类型。</p>
<p>​		提升之后，我们查看对应的ui文件可以发现，有一段<customwidgets>有新增一个CustomPushButton类型，同时我们发现我们刚才提升的按钮，其class属性由原来的PushButton更新为CustomPushButton了。</customwidgets></p>
<p>​		到此，类是提升了，但是我们在编辑连接的时候，选择了已经提升的按钮，仍然无法看到CustomPushButton类中定义的slot。好像designer并不会扫描我们的CustomPUshButton.h文件获取其中定义的slots，要要designer能知道我们类中定义的slots，需要在目标按钮控件上点击右键，点击菜单项“改变信号和槽”，然后手动添加我们CustomPushButton中自定义的槽，这样就可以在designer中可以选择目标按钮的自定义槽。</p>
<h2 id="Q：界面ui文件如何生成相应的代码"><a href="#Q：界面ui文件如何生成相应的代码" class="headerlink" title="Q：界面ui文件如何生成相应的代码"></a>Q：界面ui文件如何生成相应的代码</h2><p><strong>A：</strong>默认情况下，通过designer创建一个界面(例如mainwindow.ui)文件，会同步自动创建对应的界面类mainwindow.h和mainwindow.cpp文件，并且在编译之后在编译目录生成ui_mainwindow.h文件，此文件是解析界面mainwindow.ui文件(xml)，生成对应窗口的创建代码。</p>
<p>​		对应的mainwindow.h定义的是类MainWindow，生成的ui_mainwindow.h对应的是界面类UI::MainWindow(等价于编译生成文件中的Ui_MainWindow类)，然后MainWindow类中成员ui指针类型是UI::MainWindow*，MainWindow构造函数会new UI::MainWindow对象赋值给ui，然后调用UI::MainWindow::setupUi来初始化界面元素。</p>
<h2 id="Q：为何有些ui文件编译时不会生成对应的ui-xxx-h文件？"><a href="#Q：为何有些ui文件编译时不会生成对应的ui-xxx-h文件？" class="headerlink" title="Q：为何有些ui文件编译时不会生成对应的ui_xxx.h文件？"></a><strong>Q：为何有些ui文件编译时不会生成对应的ui_xxx.h文件？</strong></h2><p><strong>A：</strong>项目编译的时候，会用预处理工具uic对ui文件进行处理，生成对应的头文件，并非所有的ui文件在编译的时候都会生成对应的头文件，因为uic只会对工程pro文件中的FORMS参数中的ui进行预编译生成对应的头文件。用qt creator创建ui文件一般会自动添加到项目中，会自动修改pro文件，将ui追加到FORMS变量中。</p>
<h2 id="Q：mainwindow-cpp为何可以直接-include-“ui-mainwindow-h”？他们并不在同一个目录"><a href="#Q：mainwindow-cpp为何可以直接-include-“ui-mainwindow-h”？他们并不在同一个目录" class="headerlink" title="Q：mainwindow.cpp为何可以直接#include “ui_mainwindow.h”？他们并不在同一个目录"></a><strong>Q：mainwindow.cpp为何可以直接#include “ui_mainwindow.h”？他们并不在同一个目录</strong></h2><p><strong>A：</strong>ui文件不一定非要放在项目目录下，比如放在&#x2F;ui&#x2F;mainwindow.ui，只需要修改pro文件FORMS中ui文件的路径即可，例如FORMS +&#x3D; ui&#x2F;mainwindow.ui。ui编译后生成的ui_mainwindow.h文件在build目录下，mainwindow.cpp是直接include ui_mainwindow.h，哪里头文件搜索路径在哪里设置的？pro文件并没有看到include文件搜索路径。</p>
<p>​		pro文件确实没有，这个是qt默认的生成规则，qmake在处理pro文件的时候会生成makefile文件，我们可以打开makefile.debug文件看一下，里头INCPATH并没有包括了build目录。这是因为生成的ui_mainwindow.h文件和makefile文件是同一个目录，所以对ui_mainwindow.h文件的引用并不需要在incpath中添加路径。但是mainwindow.cpp文件在项目目录而不是build目录，和ui_mainwindow.h文件不在同一个目录之所以能直接#include “ui_maindown.h”，是因为makefile文件中mainwindow.cpp目标依赖是..\..\mainwindow.cpp。</p>
<h2 id="Q：除了用uic编译ui文件生成-h文件，还有没有其他办法使用ui文件？"><a href="#Q：除了用uic编译ui文件生成-h文件，还有没有其他办法使用ui文件？" class="headerlink" title="Q：除了用uic编译ui文件生成.h文件，还有没有其他办法使用ui文件？"></a><strong>Q：除了用uic编译ui文件生成.h文件，还有没有其他办法使用ui文件？</strong></h2><p><strong>A：</strong>还可以用QUiLoader，需要使用QtUiTools库（修改pro文件的QT +&#x3D; widgets uitools）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 这里calculatorform.ui是在资源文件下的forms过滤器下</span><br><span class="line">QFile file(&quot;:/forms/calculatorform.ui&quot;);</span><br><span class="line">file.open(QFile::ReadOnly);</span><br><span class="line">QWidget *formWidget = loader.load(&amp;file, this);</span><br><span class="line">file.close();</span><br></pre></td></tr></table></figure>



<h2 id="Q-QObject-findChild"><a href="#Q-QObject-findChild" class="headerlink" title="Q:  QObject::findChild"></a><strong>Q:  QObject::findChild</strong></h2><p><strong>A:</strong> 可用于Widget查找子窗体。todo…</p>
<h2 id="Q-QObject-staticMetaObject"><a href="#Q-QObject-staticMetaObject" class="headerlink" title="Q: QObject::staticMetaObject"></a><strong>Q: QObject::staticMetaObject</strong></h2><p><strong>A:</strong><code>staticMetaObject</code> 是 Qt 中 QObject 类的静态成员，它返回与特定对象类型相关联的元对象。元对象（Meta Object）是 QObject 的一个重要概念，它包含了有关对象类型的元信息，比如对象的类名、父类、属性、信号和槽等信息。</p>
<p>对于任何继承自 QObject 的类，都可以使用 <code>staticMetaObject</code> 来获取与其相关联的元对象。这个元对象是在编译时生成的，包含了所有静态信息，因此可以在运行时快速地访问对象的元信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QObject&gt;</span><br><span class="line"></span><br><span class="line">// 定义一个继承自 QObject 的类</span><br><span class="line">class MyClass : public QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    // 其他类定义</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 在需要获取元对象的地方，使用 staticMetaObject</span><br><span class="line">const QMetaObject *metaObject = MyClass::staticMetaObject;</span><br></pre></td></tr></table></figure>

<p>​		上面的代码定义了一个继承自 QObject 的类 MyClass，并在需要的地方使用了 <code>staticMetaObject</code> 获取了 MyClass 类的元对象。一旦获取了元对象，就可以通过元对象访问对象的各种属性、信号和槽等元信息。</p>
<ul>
<li><p><strong>访问属性信息</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 获取属性个数</span><br><span class="line">int propertyCount = metaObject-&gt;propertyCount();</span><br><span class="line"></span><br><span class="line">// 遍历所有属性</span><br><span class="line">for (int i = 0; i &lt; propertyCount; ++i) &#123;</span><br><span class="line">    QMetaProperty property = metaObject-&gt;property(i);</span><br><span class="line">    qDebug() &lt;&lt; &quot;Property Name: &quot; &lt;&lt; property.name();</span><br><span class="line">    qDebug() &lt;&lt; &quot;Property Type: &quot; &lt;&lt; property.typeName();</span><br><span class="line">    qDebug() &lt;&lt; &quot;Is Readable: &quot; &lt;&lt; property.isReadable();</span><br><span class="line">    qDebug() &lt;&lt; &quot;Is Writable: &quot; &lt;&lt; property.isWritable();</span><br><span class="line">    // 其他属性信息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>访问信号信息</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 获取信号个数</span><br><span class="line">int signalCount = metaObject-&gt;methodCount();</span><br><span class="line">for (int i = metaObject-&gt;methodOffset(); i &lt; signalCount; ++i) &#123;</span><br><span class="line">    QMetaMethod method = metaObject-&gt;method(i);</span><br><span class="line">    if (method.methodType() == QMetaMethod::Signal) &#123;</span><br><span class="line">        qDebug() &lt;&lt; &quot;Signal Name: &quot; &lt;&lt; method.name();</span><br><span class="line">        qDebug() &lt;&lt; &quot;Parameter Types: &quot; &lt;&lt; method.parameterTypes();</span><br><span class="line">        // 其他信号信息</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>访问slot信息</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 获取槽个数</span><br><span class="line">int slotCount = metaObject-&gt;methodCount();</span><br><span class="line">for (int i = metaObject-&gt;methodOffset(); i &lt; slotCount; ++i) &#123;</span><br><span class="line">    QMetaMethod method = metaObject-&gt;method(i);</span><br><span class="line">    if (method.methodType() == QMetaMethod::Slot) &#123;</span><br><span class="line">        qDebug() &lt;&lt; &quot;Slot Name: &quot; &lt;&lt; method.name();</span><br><span class="line">        qDebug() &lt;&lt; &quot;Parameter Types: &quot; &lt;&lt; method.parameterTypes();</span><br><span class="line">        // 其他槽信息</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>调用槽函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个对象</span><br><span class="line">QObject *obj = new QObject();</span><br><span class="line"></span><br><span class="line">// 获取槽函数的索引</span><br><span class="line">int slotIndex = metaObject-&gt;indexOfSlot(&quot;slotFunctionName()&quot;);</span><br><span class="line"></span><br><span class="line">// 调用槽函数</span><br><span class="line">if (slotIndex != -1) &#123;</span><br><span class="line">    QMetaMethod slotMethod = metaObject-&gt;method(slotIndex);</span><br><span class="line">    slotMethod.invoke(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Q：解析moc-classname-cpp文件"><a href="#Q：解析moc-classname-cpp文件" class="headerlink" title="Q：解析moc_classname.cpp文件"></a><strong>Q：解析moc_classname.cpp文件</strong></h2><p><strong>A：</strong>对象声明文件中如果有Q_OBJECT宏，则会生成moc_classname.cpp文件。</p>
<p><code>qt_meta_stringdata_TextFinder</code>：signal和slot声明的函数原型涉及到的返回值、函数名、参数类型、参数名等等的字符串表。本质是一个字符串表，里头把所有用到的字符串去重后统一存在一个字符数组中，然后建立一个索引表（索引数组，可以用于遍历字符串表），每个索引项记录了字符串的起始指针和长度</p>
<p><code>qt_meta_data_TextFinder</code>: uint数组，内部结构其实是QMetaObjectPrivate，在QMetaObjectPrivate后面跟着是method(signal&#x2F;slot)的原型定义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct QMetaObjectPrivate</span><br><span class="line">&#123;</span><br><span class="line">  // revision 7 is Qt 5.0 everything lower is not supported</span><br><span class="line">  // revision 8 is Qt 5.12: It adds the enum name to QMetaEnum</span><br><span class="line">  enum &#123; OutputRevision = 8 &#125;; // Used by moc, qmetaobjectbuilder and qdbus</span><br><span class="line">  int revision;</span><br><span class="line">  int className;</span><br><span class="line">  int classInfoCount, classInfoData;</span><br><span class="line">  int methodCount, methodData;</span><br><span class="line">  int propertyCount, propertyData;</span><br><span class="line">  int enumeratorCount, enumeratorData;</span><br><span class="line">  int constructorCount, constructorData;</span><br><span class="line">  int flags;</span><br><span class="line">  int signalCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例（相关的注释在代码中）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// 字符串表总体结构，其中data是字符串表的索引信息，stringdata0是压缩在一起的所有字符串的字节数组。</span><br><span class="line">// 字符串表 = 字符串索引表 + 所有字符串连接起来的大字节数组</span><br><span class="line">struct qt_meta_stringdata_TextFinder_t &#123;</span><br><span class="line">    QByteArrayData data[16];</span><br><span class="line">    char stringdata0[160];</span><br><span class="line">&#125;;</span><br><span class="line">// 计算字字符串表中的每个字符串的索引信息，每个字符串在字符串表中的索引信息</span><br><span class="line">// 注意：字符串的索引信息包括字符串长度size和字符串偏移offset。其中offset并非在字符串表中的偏移，而是相对于当前字符串索引项指针的偏移</span><br><span class="line">// 例如：假设ptr是执行字符串表的索引表的第n个字符串指针，是QByteArrayData*ptr，那么对应的字符串的地址是(char *)ptr+offset</span><br><span class="line">// 可以参考下面QArrayData::data()代码实现来理解</span><br><span class="line">#define QT_MOC_LITERAL(idx, ofs, len) \</span><br><span class="line">    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \</span><br><span class="line">    qptrdiff(offsetof(qt_meta_stringdata_TextFinder_t, stringdata0) + ofs \</span><br><span class="line">        - idx * sizeof(QByteArrayData)) \</span><br><span class="line">    )</span><br><span class="line">    // 构造字符串表：字符串索引表 + 大的字符串字节数组</span><br><span class="line">static const qt_meta_stringdata_TextFinder_t qt_meta_stringdata_TextFinder = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">QT_MOC_LITERAL(0, 0, 10), // &quot;TextFinder&quot;</span><br><span class="line">QT_MOC_LITERAL(1, 11, 14), // &quot;custom_clicked&quot;</span><br><span class="line">QT_MOC_LITERAL(2, 26, 0), // &quot;&quot;</span><br><span class="line">QT_MOC_LITERAL(3, 27, 7), // &quot;checked&quot;</span><br><span class="line">QT_MOC_LITERAL(4, 35, 15), // &quot;custom_clicked2&quot;</span><br><span class="line">QT_MOC_LITERAL(5, 51, 1), // &quot;a&quot;</span><br><span class="line">QT_MOC_LITERAL(6, 53, 11), // &quot;const char*&quot;</span><br><span class="line">QT_MOC_LITERAL(7, 65, 1), // &quot;s&quot;</span><br><span class="line">QT_MOC_LITERAL(8, 67, 15), // &quot;custom_clicked3&quot;</span><br><span class="line">QT_MOC_LITERAL(9, 83, 1), // &quot;c&quot;</span><br><span class="line">QT_MOC_LITERAL(10, 85, 5), // &quot;char*&quot;</span><br><span class="line">QT_MOC_LITERAL(11, 91, 1), // &quot;b&quot;</span><br><span class="line">QT_MOC_LITERAL(12, 93, 15), // &quot;custom_clicked4&quot;</span><br><span class="line">QT_MOC_LITERAL(13, 109, 6), // &quot;int8_t&quot;</span><br><span class="line">QT_MOC_LITERAL(14, 116, 20), // &quot;on_btnSearch_clicked&quot;</span><br><span class="line">QT_MOC_LITERAL(15, 137, 22) // &quot;on_btnSearch_pressdown&quot;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    //</span><br><span class="line">    &quot;TextFinder\0custom_clicked\0\0checked\0&quot;</span><br><span class="line">    &quot;custom_clicked2\0a\0const char*\0s\0&quot;</span><br><span class="line">    &quot;custom_clicked3\0c\0char*\0b\0custom_clicked4\0&quot;</span><br><span class="line">    &quot;int8_t\0on_btnSearch_clicked\0&quot;</span><br><span class="line">    &quot;on_btnSearch_pressdown&quot;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">#undef QT_MOC_LITERAL</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct Q_CORE_EXPORT QArrayData</span><br><span class="line">&#123;</span><br><span class="line">  QtPrivate::RefCount ref;</span><br><span class="line">  int size;</span><br><span class="line">  uint alloc : 31;</span><br><span class="line">  uint capacityReserved : 1;</span><br><span class="line">  qptrdiff offset; // in bytes from beginning of header</span><br><span class="line">  // QArrayData::data()就是上述获取其指向的数据的内容，可以看到offset是相对于自己(QArrayData *this)而言的</span><br><span class="line">  void *data()</span><br><span class="line">  &#123;</span><br><span class="line">​    Q_ASSERT(size == 0</span><br><span class="line">​        || offset &lt; 0 || size_t(offset) &gt;= sizeof(QArrayData));</span><br><span class="line">​    return reinterpret_cast&lt;char *&gt;(this) + offset;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><code>staticMetaObject</code>: QObject对象的静态metaobject</p>
<p>另外还有为用户定义的信号（signal函数）生成实现代码。注意，用户定义的信号只需要在头文件的类中给出函数申明即可，不需要定义。</p>
<p><strong>Q：QT布局</strong></p>
<p><strong>A：</strong>QT UI系统通过Layout&#x2F;sizePolicy&#x2F;StretchFactor来控制布局和控件的大小。</p>
<ul>
<li>布局控制<strong>子元素</strong>的排列，比如如果widget是QHBoxLayout布局，那么其所有子元素会水平布局</li>
<li>sizePolicy控制<strong>控件自己</strong>尺寸的行为，有下列选项<ul>
<li><strong>Fixed</strong>：控件将保持其固定大小，并不会改变。</li>
<li><strong>Minimum</strong>：控件将尽可能小，以适应其内容，但不会超过其最小尺寸。</li>
<li><strong>Maximum</strong>：控件将尽可能大，以填充可用空间，但不会超过其最大尺寸。</li>
<li><strong>Preferred</strong>：控件希望具有适当的大小，以显示其内容，但它可能会根据可用空间进行扩展或收缩。</li>
<li><strong>Expanding</strong>：控件希望尽可能大，以填充可用空间。如果可用空间增加，它将尝试扩展以填充更多空间。</li>
<li><strong>MinimumExpanding</strong>：控件希望尽可能大，以填充可用空间，并且具有最小尺寸。</li>
<li><strong>Ignored</strong>：布局管理器会忽略控件的大小，控件可以是任何大小。</li>
</ul>
</li>
<li>StretchFactor</li>
</ul>
<p><strong>备注：</strong>在水平布局中，假设里头有2个子控件，默认设置sizePolicy水平方向均为prefered或者extended，父窗口调整大小，两个子控件会自动调整宽度以完全适应父窗口宽度。如果想在中间假如间隔，可以假如一个horzSpacer弹簧。如果想控制其中一个子控件宽度不变，修改该子控件sizePolicy水平为fixed还不行，还需要修改minimumsize.x为你相设置的宽度（不要尝试修改geometry的宽度，在布局下面，控件的geometry无法修改）</p>
<h2 id="Q：qrc文件"><a href="#Q：qrc文件" class="headerlink" title="Q：qrc文件"></a><strong>Q：qrc文件</strong></h2><p><strong>A：</strong>通过makefile可以看到编译时会用rcc.exe来编译qrc文件，生成对应的cpp文件。然后在程序入口地方可以用Q_INIT_RESOURCE(XXX);来初始化资源，内部调用qRegisterResourceData函数来注册资源数据。</p>
<h2 id="Q：-在线安装频繁提示网络错误，用代理和不用代理一样"><a href="#Q：-在线安装频繁提示网络错误，用代理和不用代理一样" class="headerlink" title="Q： 在线安装频繁提示网络错误，用代理和不用代理一样"></a><strong>Q： 在线安装频繁提示网络错误，用代理和不用代理一样</strong></h2><p><strong>A：</strong>尝试使用离线安装包（qt-creator-opensource-windows-x86_64-13.0.1.exe），里头可选择安装项目。</p>
<h2 id="Q：QtCreator编译后如何部署"><a href="#Q：QtCreator编译后如何部署" class="headerlink" title="Q：QtCreator编译后如何部署"></a><strong>Q：QtCreator编译后如何部署</strong></h2><p>A：编译后会生成可执行环境，进入到生成目录直接运行exe文件无法启动，提示依赖库不存在，不过可以在Creator中调试（会自动设置好依赖库路径）。发布的时候需要部署，qt自带了部署工具windeployqt.exe，具体的在开发包5.12.12\msvc2017_64\bin\（x64）或者5.12.12\msvc2017\bin\（x86）下面，此命令只需要一个exe文件名即可。例如：你可以将生成的output.exe文件拷贝到你要部署的目录，然后在部署目录下执行windeployqt.exe output.exe即可。</p>
<p>​		当然，我们也可以借助QtCreator工具来部署，在Kit中点击Run，打开运行配置，最上面就是部署配置，可以创建部署步骤(Customer Process Step)，例如我们先拷贝输出文件到部署目录然后部署，下面是示例&gt;2：</p>
<p><img src="/2024/05/18/QT/image-20240518091304577.png" alt="image-20240518091304577"></p>
<ul>
<li>这里步骤一是想用copy命令拷贝，不要直接在command：里头输入copy，他会提示：invalid command。我们需要用cmd.exe &#x2F;c copy来执行拷贝，Command填入cmd.exe即可， &#x2F;c copy 填在arguments里头。</li>
<li>windeployqt指示部署依赖的QT库，项目中用到的第三方库需要自己手动部署（自行拷贝到发布目录）</li>
</ul>
<h2 id="Q-构建库并且使用"><a href="#Q-构建库并且使用" class="headerlink" title="Q: 构建库并且使用"></a>Q: 构建库并且使用</h2><p>A：创建mylib库。文件 - new project - 库 - c++library，输入名称mylib，下一步build system选择qmake，下一步 define project details 库类型设置为static library，其他默认，后面一路next，最后选择build套件，结束。</p>
<p>​		创建好mylib库之后，直接构建就可以，构建输出目录设置为mylib&#x2F;debug。</p>
<p>​		可以看下mylib.pro文件，在pro文件中，用TEMPLATE &#x3D; lib 指示这是一个库工程（app用app）；CONFIG +&#x3D; staticlib指示静态库（动态库是dll），其他的SOURCES指示源代码文件列表；HEADERS指示头文件列表；</p>
<p>​		修改app.pro文件，假如头文件包含和头文件搜搜目录以及依赖库和库目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HEADERS += \</span><br><span class="line">    cperson.h \</span><br><span class="line">    myspinbox.h \</span><br><span class="line">    textfinder.h \</span><br><span class="line">    mylib.h</span><br><span class="line">    </span><br><span class="line">INCLUDEPATH += $$PWD/../mylib</span><br><span class="line">// 注意这里指示演示，没有区分debug和release</span><br><span class="line">LIBS += -L$$PWD/../mylib/debug/ -lmylib</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h1><p>1、<a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学开源软件镜像站</a></p>
<p>2、<a target="_blank" rel="noopener" href="https://download.qt.io/">qt官方下载站</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jerrywang2013.github.io/2024/05/18/QT/" data-id="clwbg5x4k0003z44q9fcu4qwg" data-title="QT" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-c-调试" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/05/14/c-%E8%B0%83%E8%AF%95/" class="article-date">
  <time class="dt-published" datetime="2024-05-13T22:52:45.000Z" itemprop="datePublished">2024-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/05/14/c-%E8%B0%83%E8%AF%95/">c++调试</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>好多年都没怎用c&#x2F;c++了，最近因为用到某个库写个小工具用到c++，这里简单记录下c++调试。</p>
<p>环境：VS2022</p>
<p>编译环境：x64 debug</p>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="简单的函数调用示例"><a href="#简单的函数调用示例" class="headerlink" title="简单的函数调用示例"></a>简单的函数调用示例</h2><ul>
<li><p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> s = <span class="built_in">sum</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sum:&quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码只有一个简单的函数调用，我们通过这个案例主要了解一下c++代码背后的机器码的样子，以及程序运行过程中栈和寄存器的变化。</p>
</li>
<li><p>反汇编</p>
<ul>
<li><p><strong>sum() 反汇编</strong>(被调用函数)</p>
<p><img src="/2024/05/14/c-%E8%B0%83%E8%AF%95/image-20240514070514439.png" alt="image-20240514070514439"></p>
<p>部分反汇编代码解释：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">push rbp; rbp值入栈，用于保存rbp寄存器，后面恢复用</span><br><span class="line">push rdi; rdi寄存器入栈，后面会用到rdi寄存器，这里值先保存</span><br><span class="line">sub rsp 0e8h; 将rsp减去0e8h，保留栈空间用于本函数(局部变量等）的使用</span><br><span class="line">mov eax, dword ptr[a]; 将a值赋值给eax寄存器</span><br><span class="line">mov ecx, dword ptr[b]; 将b值赋值给ecx寄存器</span><br><span class="line">lea eax, [rax+rcx+1]; 计算rax+rcx+1结果保存到eax</span><br><span class="line">lea rsp,[rbp+0c8h]; 恢复rsp，之前rsp用rbp+0e8h,然后rbp-=20h</span><br><span class="line">pop rdi; 恢复rdi寄存器</span><br><span class="line">pop rbp; 恢复rbp寄存器</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>main() 反汇编</strong>(调用函数)</p>
<p><img src="/2024/05/14/c-%E8%B0%83%E8%AF%95/image-20240514070345762.png" alt="image-20240514070345762"></p>
<p>主要看main函数调用sum()前后部分反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov edx, dword ptr[b];   变量b的值赋值给edx寄存器</span><br><span class="line">mov ecx, dword ptr[a];  变量a的值赋值给ecx寄存器</span><br><span class="line">call sum(07FF71D5411E5h); 调用sum函数</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>x64架构调用约定：</strong></p>
<ul>
<li><p>在x64 window平台下，函数参数传递默认情况下前四个整形或者指针参数统计寄存器传递(rcx, rdx, r8, r9)，后面的参数通过压栈传参。可以看到，这里2个参数是用了ecx和edx传参。</p>
<p>测试5个参数的传参：</p>
<pre><code>00007FF758712370  push        rbp  
00007FF758712372  push        rdi  
00007FF758712373  sub         rsp,158h  
00007FF75871237A  lea         rbp,[rsp+30h]
int s = sum(a, b, 3, 4, 5);
00007FF758712399  mov         dword ptr [rsp+20h],5    
00007FF7587123A1  mov         r9d,4  
00007FF7587123A7  mov         r8d,3  
00007FF7587123AD  mov         edx,dword ptr [b]  
00007FF7587123B0  mov         ecx,dword ptr [a]  
00007FF7587123B3  call        sum (07FF758711465h) 
</code></pre>
<p>​		可以看到参数处理是从左往右，前面四个参数用rcx、rdx、r8、r9传递，后面的参数压入栈传递（自左往右）， 第五个参数压入到rsp+20h位置，如果有第六个参数，则第六个参数在第五个参数之后入栈，对应位置在rsp+28h;</p>
</li>
<li><p>前4个参数如果是浮点参数，通过SSE寄存器xmm0-xmm3传递</p>
</li>
<li><p>由调用者为寄存器中的参数传递保留栈上的空间（至少分配32字节的阴影空间），被调用者可以访问这个栈空间来讲寄存器中的内容写回栈空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lea rbp,[rsp+30h]; </span><br><span class="line">这个代码就是为参数保留栈空间，以便调用者调用到。一般来说总长度是(总的参数个数)*8</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>不要以为前面四个参数是通过寄存器传递给被调用函数可以不用为参数保留栈空间，哪怕调用者这边不用，也需要保留参数的栈空间，因为被调用者那边约定是将寄存器的内容写入到栈中。有个疑问，这样用寄存器传递参数不是多此一举，比直接用栈传递参数还少拷贝两次吗？</p>
</li>
<li><p>返回整数或者指针通过rax寄存器完成，浮点数返回值通过xmm0传递</p>
</li>
<li><p>堆栈保持16字节对齐（叶函数除外）</p>
</li>
<li><p>x64没有x86的stdcall&#x2F;cdecl&#x2F;fastcall&#x2F;thiscall等，只有一个x64调用约定</p>
</li>
</ul>
<p> 备注：</p>
<ol>
<li><p>call会将返回地址压入堆栈（esp&#x3D;esp-8)</p>
</li>
<li><p>栈是沿低地址延伸的，栈底地址是大于栈顶地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push rax  等价于 rsp--; *rsp = rax;</span><br><span class="line">pop rax 等价于rax = *rsp; rsp++;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>栈布局图</strong></p>
<img src="/2024/05/14/c-%E8%B0%83%E8%AF%95/image-20240515000343120.png" alt="image-20240515000343120" style="zoom:50%;">



<p><img src="https://learn.microsoft.com/en-us/cpp/build/media/vcamd_conv_ex_5.png?view=msvc-170" alt="Diagram of the stack layout for the x64 conversion example."></p>
<p><img src="/2024/05/14/c-%E8%B0%83%E8%AF%95/image-20240516120003269.png" alt="image-20240516120003269"></p>
<img src="/2024/05/14/c-%E8%B0%83%E8%AF%95/image-20240517133710237.png" alt="image-20240517133710237" style="zoom:80%;">

<h2 id="volatile-non-volatile-register"><a href="#volatile-non-volatile-register" class="headerlink" title="volatile &amp; non-volatile register"></a>volatile &amp; non-volatile register</h2><p>​		volatile register通常又称之为可变寄存器。可变的意思是在函数调用过程中寄存器值可能发生变化。</p>
<ul>
<li><p>常见volatile register</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RAX, RCX, RDX, R8, R9, R10, R11</span><br><span class="line">// 这几个寄存器常用语参数传递</span><br></pre></td></tr></table></figure>
</li>
<li><p>常见的non-volatile register</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RBX，RDI,RSI,RBP,RSP,R12,R13,R14,R15</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="x64函数中的Prolog和Epilog"><a href="#x64函数中的Prolog和Epilog" class="headerlink" title="x64函数中的Prolog和Epilog"></a>x64函数中的Prolog和Epilog</h2><p>x64 push&#x2F;pop指令限定在prolog和epilog中使用，因为在prolog和epilog之间rsp是不会被修改的。</p>
<h3 id="prolog"><a href="#prolog" class="headerlink" title="prolog"></a>prolog</h3><ul>
<li><p>将寄存器参数保存到调用函数分配的参数所在的栈空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">   通常代码如下，上面的4个mov指令是将寄存器参数保存到栈里头，对被调用函数而言，这段代码寻址是固定的，因为rsp指向的是返回地址，它的上面才是参数，所以第一个参数地址永远是rsp+8；第二个参数地址是rsp+10h，以此类推。</span><br><span class="line">*/</span><br><span class="line"> mov     dword ptr [rsp+20h],r9d</span><br><span class="line"> mov     dword ptr [rsp+18h],r8d</span><br><span class="line"> mov     dword ptr [rsp+10h],edx</span><br><span class="line"> mov     dword ptr [rsp+8],ecx</span><br><span class="line"> sub     rsp,18h</span><br></pre></td></tr></table></figure>


</li>
<li><p>保存本函数可能修改的volatile寄存器的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 类似如下反汇编代码，保存non-volatile寄存器</span><br><span class="line">00007FF78B541CE2  push        rbp  </span><br><span class="line">00007FF78B541CE3  push        rdi</span><br></pre></td></tr></table></figure>


</li>
<li><p>为函数局部变量分配栈空间，如果此函数有调用其他函数，还要为调用函数的参数分配空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00007FF78B541CE4  sub         rsp,108h  </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Epilog"><a href="#Epilog" class="headerlink" title="Epilog"></a>Epilog</h3><ul>
<li>清理函数在prolog中为其变量分配的堆栈空间以及函数参数堆栈空间</li>
<li>恢复non-volatile寄存器</li>
<li>返回到调用者</li>
</ul>
<p>x86堆栈操作与x64主要差别</p>
<p>​	x86堆栈操作严重以来ebp；而x64不依赖。</p>
<h1 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h1><p>​	在c&#x2F;c++中，调用约定指的是编译器如果安排函数调用中参数传递顺序、调用栈空间的清理、函数返回值传递等规则。不同平台和编译器有不同的函数调用约定，主要有三个：</p>
<ul>
<li><p>__cdecl</p>
<p>​	默认调用约定。参数从右往左压入堆栈，调用方负责清理堆栈，返回值通过寄存器传递。</p>
</li>
<li><p>__stdcall</p>
<p>​	windows平台常用。参数从右往左压入堆栈，被调用函数清理堆栈，返回值通过寄存器传递。</p>
</li>
<li><p>__thiscall</p>
<p>​		常用语类成员函数，将this指针作为隐式参数传递给函数，其它参数从右往左压入堆栈，调用者负责清理堆栈。</p>
</li>
</ul>
<p>​		不用太纠结用那个调用约定，本身只是一个规则而已。一般来说，通过返回指令ret 和 ret X能判断出是否是stdcall或者cdecl。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64">x86-64 上的堆栈框架布局 - Eli Bendersky 的网站 (thegreenplace.net)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wingsummer/p/16076345.html">x64 番外篇——知识铺垫 - 寂静的羽夏 - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/cpp/build/x64-software-conventions?view=msvc-170&redirectedfrom=MSDN">x64 ABI 约定 |Microsoft学习</a></p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170">x64 calling convention | Microsoft Learn</a></p>
<p><a target="_blank" rel="noopener" href="https://medium.com/@sruthk/cracking-assembly-introduction-to-assembly-language-a4ad14e601a1">破解程序集 — 程序集语言简介 |由 Sruthi K |中等 (medium.com)</a></p>
<h1 id="常用windbg命令"><a href="#常用windbg命令" class="headerlink" title="常用windbg命令"></a>常用windbg命令</h1><p>​		这里仅仅记录调试常用的命令，不全。需要详细的命令可以查看dbghelp.chm文件(debug tools for windwos包)</p>
<ul>
<li>设置符号&#x2F;源文件路径</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.sympath + &lt;pdb文件路径&gt;</span><br><span class="line">.srcpath + &lt;.cpp文件路径&gt;</span><br></pre></td></tr></table></figure>

<p>​		也可以在界面’文件‘菜单中点击’Symbol File Path‘设置符号文件路径；点击”Source File Path”打开代码文件路径。</p>
<ul>
<li><p>d </p>
<p>查看内存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d addr</span><br><span class="line">// 默认以字节为单位显示，也可以用db | dw | dd | dq来显示指定显示格式</span><br><span class="line">// 查看堆栈附近内存</span><br><span class="line">d rsp</span><br></pre></td></tr></table></figure>
</li>
<li><p>uf </p>
<p>查看函数汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uf [Module!]Function</span><br><span class="line">uf [Module!]Address</span><br><span class="line">address是函数地址，可以用名称，例如 </span><br><span class="line">uf ConsoleApplicaiton!main</span><br><span class="line">uf main</span><br></pre></td></tr></table></figure>
</li>
<li><p>切换调试模型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l+t 设置调试模式为源码模式</span><br><span class="line">l-t 设置调试模式为反汇编模式</span><br><span class="line">l+s 命令行显示行号</span><br><span class="line">l-s 命令行不显示行号</span><br></pre></td></tr></table></figure>
</li>
<li><p>!analyze</p>
<p>分析dump文件用到。</p>
</li>
<li><p>lm</p>
<p>显示模块信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lmOptions [a Address] [m Pattern | M Pattern]</span><br><span class="line">eg:</span><br><span class="line">lmDvm *Console*!*</span><br></pre></td></tr></table></figure>
</li>
<li><p>x</p>
<p>查看符号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x [opts] Module!Symbol</span><br><span class="line">x * // ！！！注意，这个是显示局部变量！！！</span><br><span class="line">eg:</span><br><span class="line">x sample!*main*</span><br><span class="line">支持*通配符，列出sample模块的所有含有字符串main的函数</span><br></pre></td></tr></table></figure>
</li>
<li><p>b</p>
<p>设置断点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bm sample!*main*   // bm设置函数断点</span><br><span class="line">bp address  // 设置地址断点</span><br></pre></td></tr></table></figure>
</li>
<li><p>r</p>
<p>显示寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; r</span><br><span class="line">rax=0000000000000006 rbx=0000000000000000 rcx=0000000000000006</span><br><span class="line">rdx=0000000000000001 rsi=0000000000000000 rdi=0000000000000000</span><br><span class="line">rip=00007ff696776656 rsp=00000051766ff640 rbp=00000051766ff670</span><br><span class="line"> r8=0000000000000002  r9=00000051766ff728 r10=0000000000000012</span><br><span class="line">r11=00000051766ff7d0 r12=0000000000000000 r13=0000000000000000</span><br><span class="line">r14=0000000000000000 r15=0000000000000000</span><br></pre></td></tr></table></figure>
</li>
<li><p>k</p>
<p>查看堆栈，如果要显示所有线程的堆栈：~*k</p>
</li>
<li><p>.formats</p>
<p>显示表达式和符号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.formats expression</span><br></pre></td></tr></table></figure>
</li>
<li><p>常见操作片段</p>
<p>假设调试ConsoleApplication1.exe</p>
<p>查看模块	 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//所有模块，然后点击某个模块可以列出函数</span><br><span class="line">lm</span><br><span class="line">// 查看某个模块</span><br><span class="line">lmv m Console*</span><br></pre></td></tr></table></figure>

<p>查看ConsoleApplicaiton1中的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 列出ConsoleApplication1中所有函数</span><br><span class="line">x ConsoleA*!*</span><br><span class="line">// 如果函数太多，可以用DML格式来显示。注意/D 后面接的是modulename（可统配），不要带方法</span><br><span class="line">x /D Console*!a*</span><br><span class="line">// 查看某个方法地址，从上面的DML显示中直接点击或者用通配符 找到函数符号和地址</span><br><span class="line">x /D ConsoleApplicati*!s*</span><br><span class="line">// 用bm或者bp设置断点。注意bp不会检测断点地址；bm会检测符号是否存在</span><br><span class="line">bm ConsoleApplication1!sum</span><br><span class="line">bp 00007ff7`8b541cc0</span><br><span class="line">// 恢复程序运行</span><br><span class="line">g</span><br><span class="line">// ....</span><br><span class="line">// 运行到断点处触发断点，程序中断</span><br><span class="line">// 显示局部变量</span><br><span class="line">dv</span><br><span class="line">dv /v 显示变量和变量的地址</span><br><span class="line">// 显示堆栈</span><br><span class="line">k</span><br><span class="line">// 显示内存</span><br><span class="line">db Address</span><br><span class="line">// 看寄存器</span><br><span class="line">r</span><br><span class="line">// 查看汇编</span><br><span class="line">u Address</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>​</p>
</li>
</ul>
<p>	</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jerrywang2013.github.io/2024/05/14/c-%E8%B0%83%E8%AF%95/" data-id="clwbg5x4l0005z44qcmrhab55" data-title="c++调试" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-用libharu完成一个小作业" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/05/11/%E7%94%A8libharu%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AA%E5%B0%8F%E4%BD%9C%E4%B8%9A/" class="article-date">
  <time class="dt-published" datetime="2024-05-10T23:35:56.000Z" itemprop="datePublished">2024-05-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/05/11/%E7%94%A8libharu%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AA%E5%B0%8F%E4%BD%9C%E4%B8%9A/">用libharu完成一个小作业</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>libharu是一个开源的pdf文件操作的C语言库。</p>
<p>因一个小作业需要用libharu而初步接触haru，这里简单记录一下自己的理解。	</p>
<h1 id="下载-安装"><a href="#下载-安装" class="headerlink" title="下载 &amp; 安装"></a>下载 &amp; 安装</h1><ul>
<li><p><strong>下载</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/libharu/libharu.git</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>安装</strong></p>
<p>​		参考readme和install说明。在windows下利用CMake进行安装。		</p>
<pre><code>    mkdir libharu_build
    cd libharu_build
    cmake ..\libharu
</code></pre>
<p>​		本机安装了vs2022, CMake会自动生成VS2022的工程文件。</p>
</li>
<li><p><strong>编译</strong></p>
<p>​		打开VS2022，打开libharu_build\libharu.sln文件，可正常编译通过，生成库文件在libharu_build\src\debug\，配置文件在libharu_build\include。可自行修改项目配置设置编译后生成的库文件目录，或者直接在postbuild里头加个脚本做生成后的发布（拷贝）。</p>
<p>​</p>
</li>
</ul>
<p>		</p>
<h1 id="libharu-功能"><a href="#libharu-功能" class="headerlink" title="libharu 功能"></a>libharu 功能</h1><p>​		简单看了下 <code>https://github.com/libharu/libharu/wiki</code>，了解一下haru的基本概念和一些设计思想。</p>
<h3 id="图形"><a href="#图形" class="headerlink" title="图形"></a>图形</h3><ul>
<li><h5 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h5><p>​		默认坐标轴原点(0,0)是页面左下角，右上角坐标是(页面宽，页面高)，xy轴方向分别是往右和往上；默认分辨率是72dpi。</p>
<p>​		可以用HPDF_Page_Concat()修改默认坐标系。	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HPDF_STATUS HPDF_Page_Concat  (HPDF_Page    page,</span><br><span class="line">                               HPDF_REAL    a,</span><br><span class="line">                               HPDF_REAL    b,</span><br><span class="line">                               HPDF_REAL    c,</span><br><span class="line">                               HPDF_REAL    d,</span><br><span class="line">                               HPDF_REAL    x,</span><br><span class="line">                               HPDF_REAL    y);</span><br></pre></td></tr></table></figure>

<p>​		wiki中没有讲参数含义，大概猜测这里的abcd是旋转矩阵的四个变量，xy应该是偏移量。</p>
<p><strong>例如：</strong></p>
<p>将坐标系沿着XY正方向偏移（100， 100）像素，新的原点是原来坐标系(100, 100)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HPDF_Page_Concat(page, 1, 0, 0, 1, 100, 100);</span><br></pre></td></tr></table></figure>

<p>​		</p>
</li>
<li><p><strong>图形模式</strong></p>
<p>​		libharu为每个pdf文档的每一页维护一个图形模式标志，用于控制绘图操作。图形模式不需要显示的去设置，而是通过相关的绘图函数来控制的，同样的，不同的图像模式下可以调用的函数也是不同的，必须保证函数能在合适的图像模式下调用，常见的调用错误是：</p>
<table>
<thead>
<tr>
<th align="left">HPDF_PAGE_INVALID_GMODE</th>
<th>0x1051</th>
<th>See Graphics mode.</th>
</tr>
</thead>
<tbody><tr>
<td align="left"></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>常见的三种GMode</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define  HPDF_GMODE_PAGE_DESCRIPTION    0x0001</span><br><span class="line">  </span><br><span class="line">#define  HPDF_GMODE_PATH_OBJECT       0x0002</span><br><span class="line">  </span><br><span class="line">#define  HPDF_GMODE_TEXT_OBJECT       0x0004</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>HPDF_GMODE_PAGE_DESCRIPTION</strong></p>
<p>可用操作：</p>
<ul>
<li><p>General graphics state</p>
</li>
<li><p>Special graphics state</p>
</li>
<li><p>Color</p>
</li>
<li><p>Text state</p>
</li>
</ul>
</li>
<li><p><strong>HPDF_GMODE_PATH_OBJECT</strong></p>
<p>可用操作：</p>
<ul>
<li>Path Construction</li>
</ul>
<p>	</p>
<p><strong>状态机：</strong></p>
<ul>
<li><p>调用绘图函数(Path Construction)进入</p>
</li>
<li><p>调用Path Painting Operators退出到<strong>HPDF_GMODE_PAGE_DESCRIPTION</strong></p>
</li>
</ul>
</li>
<li><p><strong>HPDF_GMODE_TEXT_OBJECT</strong></p>
<p><strong>可用操作：</strong></p>
<ul>
<li>Graphics state</li>
<li>Color</li>
<li>Text state</li>
<li>Text-showing</li>
<li>Text-positioning</li>
</ul>
<p><strong>状态机：</strong></p>
<ul>
<li><p>调用HPDF_Page_BeginText()进入</p>
</li>
<li><p>调用HPDF_Page_EndText()退出到<strong>HPDF_GMODE_PAGE_DESCRIPTION</strong></p>
</li>
</ul>
</li>
</ul>
<p><strong>Graphpics State</strong> 操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HPDF_Page_Concat()</span><br><span class="line">HPDF_Page_SetDash()</span><br><span class="line">HPDF_Page_SetFlat()</span><br><span class="line">HPDF_Page_SetLineCap()</span><br><span class="line">HPDF_Page_SetLineJoin()</span><br><span class="line">HPDF_Page_SetLineWidth()</span><br><span class="line">HPDF_Page_SetMiterLimit()</span><br></pre></td></tr></table></figure>

<p><strong>Color</strong>操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HPDF_Page_SetCMYKFill()</span><br><span class="line">HPDF_Page_SetCMYKStroke()</span><br><span class="line">HPDF_Page_SetGrayFill()</span><br><span class="line">HPDF_Page_SetGrayStroke()</span><br><span class="line">HPDF_Page_SetRGBFill()</span><br><span class="line">HPDF_Page_SetRGBStroke()</span><br></pre></td></tr></table></figure>

<p><strong>Path Construction</strong>操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HPDF_Page_Arc()</span><br><span class="line">HPDF_Page_Circle()</span><br><span class="line">HPDF_Page_CurveTo()</span><br><span class="line">HPDF_Page_CurveTo2()</span><br><span class="line">HPDF_Page_CurveTo3()</span><br><span class="line">HPDF_Page_LineTo()</span><br><span class="line">HPDF_Page_MoveTo()</span><br><span class="line">HPDF_Page_Rectangle()</span><br></pre></td></tr></table></figure>

<p><strong>Path Painting</strong>操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HPDF_Page_ClosePathFillStroke()</span><br><span class="line">HPDF_Page_ClosePathEofillStroke()</span><br><span class="line">HPDF_Page_ClosePathStroke()</span><br><span class="line">HPDF_Page_Eofill()</span><br><span class="line">HPDF_Page_EofillStroke()</span><br><span class="line">HPDF_Page_EndPath()</span><br><span class="line">HPDF_Page_Fill()</span><br><span class="line">HPDF_Page_FillStroke()</span><br><span class="line">HPDF_Page_Stroke()</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<p>​	简单说就是在description状态下调用绘图函数(Path Construction)进入绘图状态，调用绘图结束函数Path Painting)结束绘图；调用HPDF_Page_BeginText()进入文字绘制状态，调用HPDF_Page_EndText()退出文字绘制状态。</p>
<p>​	特别注意绘制状态，刚接触很容易碰到绘制状态不对导致的绘制函数调用错误（错误码0x1051）</p>
</li>
<li><p><strong>图形绘制</strong></p>
<p>​		大部分功能和windows的gdi绘制差不多，有stoke和fill相关的设置；有绘制line&#x2F;rectangle&#x2F;triangle&#x2F;cricle等等，方法也都类似。</p>
<ul>
<li><p><strong>HPDF_Page_Stroke</strong>  绘制路径</p>
</li>
<li><p>**HPDF_Page_FillStroke  **填充路径</p>
</li>
<li><p><strong>HPDF_Page_ClosePathFillStroke</strong> 封闭路径并且填充</p>
</li>
<li><p><strong>HPDF_Page_ClosePathStroke</strong> 封闭路径然后绘制路径</p>
</li>
<li><p><strong>HPDF_Page_EndPath</strong> 指示路径结束</p>
</li>
<li><p><strong>HPDF_Page_SetRGBFill</strong> 设置填充颜色</p>
</li>
<li><p><strong>HPDF_Page_SetRGBStroke</strong> 设置描边颜色</p>
</li>
<li><p><strong>HPDF_Page_SetRGBFill</strong> 设置填充灰度颜色</p>
</li>
<li><p><strong>HPDF_Page_SetGrayStroke</strong> 设置描边灰度颜色</p>
</li>
</ul>
</li>
<li><p><strong>高级绘制功能</strong></p>
<p>libharu提供了extgstate相关的函数，可以控制透明度、混合模式，具体实现在hpdf_ext_gstate.c，示例代码：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HPDF_Page_GSave (page);</span><br><span class="line">gstate = HPDF_CreateExtGState (pdf);</span><br><span class="line">HPDF_ExtGState_SetAlphaFill (gstate, 0.8);</span><br><span class="line">HPDF_ExtGState_SetAlphaStroke (gstate, 0.8);</span><br><span class="line">HPDF_Page_SetExtGState (page, gstate);</span><br><span class="line">draw_circles (page, &quot;alpha fill = 0.8&quot;, 230.0f, PAGE_HEIGHT - 170);</span><br><span class="line">HPDF_Page_GRestore (page);</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>文字绘制</strong></p>
<p>​	绘制文字接口有HPDF_Page_ShowText()、TextOut()、TextRect()、ShowTextNextLine()等接口。关于文字绘制，需要注意的地方：</p>
<ul>
<li><p>位置属性的更新。比如我们要在指定位置绘制文字，可以用TextOut()方法指定posx&#x2F;posy绘制，也可以用ShowText()方法。使用ShowText()方法要注意，需要先定位好位置，也就是调用HPDF_Page_MoveTextPos()方法，此方法的参数x&#x2F;y是相对当前未知的偏移，这个特别要注意。另外，当你在同一行用MoveTextPos()在x轴偏移了，然后当你想换行在最左开始绘制新的文字，这时候要注意了，需要将位置重定位到x&#x3D;0的位置，而MoveTextPos()方法是偏移相对位置。</p>
</li>
<li><p>中英文汉字绘制问题。需要设置字体和编码，字体用GB-EUC-H编码，文字用GBK可以。</p>
<ul>
<li><strong>GB编码支持</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HPDF_Font font = HPDF_GetFont(pdf, fontName, &quot;GB-EUC-H&quot;);</span><br><span class="line">HPDF_REAL size = 32;</span><br><span class="line">HPDF_Page_SetFontAndSize(page, font, size);</span><br></pre></td></tr></table></figure>

<p>注意，需要在之前调用HPDF_UseCNSEncodings(pdf);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HPDF_UseCNSFonts(pdf);</span><br><span class="line">HPDF_UseCNSEncodings(pdf);</span><br></pre></td></tr></table></figure>

<p>​		GB-EUC-H支持GB2312简体中文编码，实现文件在hpdf_encoder_cns.c，可以看看文件中的GB_EUC_IsLeadByte函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static HPDF_BOOL</span><br><span class="line">GB_EUC_IsLeadByte (HPDF_Encoder encoder, HPDF_BYTE b)</span><br><span class="line">&#123;</span><br><span class="line">  HPDF_UNUSED (encoder);</span><br><span class="line">  return (b &gt;= 0xa1 &amp;&amp; b &lt;= 0xfe);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		可以看出这个是简单的判断是否是GB2312 汉字的首字节编码范围。</p>
<ul>
<li><strong>UTF8支持</strong></li>
</ul>
<p>	</p>
<p>GB-EUC-H不支持多国语言，想要更通用的多国语言支持，建议使用UTF8编码。调用HPDF_UseUTFEncodings来开启UTF8编码的支持，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HPDF_EXPORT(HPDF_STATUS) HPDF_UseUTFEncodings(HPDF_Doc pdf)</span><br></pre></td></tr></table></figure>

<p>​		libharu对于utf8的支持在hpdf_encoder_utf.c文件实现，主要有下面几个函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static HPDF_ByteType UTF8_Encoder_ByteType_Func (HPDF_Encoder encoder, HPDF_ParseText_Rec  *state);</span><br><span class="line"></span><br><span class="line">static HPDF_UNICODE UTF8_Encoder_ToUnicode_Func(HPDF_Encoder  encoder,         HPDF_UINT16 code);</span><br></pre></td></tr></table></figure>

<p>​		这里主要是完成utf8-&gt;unicode的编码转换，其中UTF8_Encoder_ByteType_Func用于获取utf8字符串的字符个数（不是字节）；UTF8_Encoder_ToUnicode_Func用于将utf8编码的字符串转为unicode字符串。这里没有用第三方库进行编码转换，直接跟进UTF8编码规则，完成UTF和Unicode的编码拆组。</p>
</li>
<li><p><strong>文字高级渲染</strong></p>
<ul>
<li><p>HPDF_Page_SetTextMatrix</p>
<p>控制文字变换矩阵。</p>
<p>例如： </p>
<p><strong>旋转矩阵</strong>：		</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a  b  0 </span><br><span class="line">c  d  0 </span><br><span class="line">0  0  1</span><br><span class="line"></span><br><span class="line">a = cos(θ)</span><br><span class="line">b = -sin(θ)</span><br><span class="line">c = sin(θ)</span><br><span class="line">d = cos(θ)</span><br></pre></td></tr></table></figure>

<p><strong>斜切矩阵：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1           tan(α)  0 </span><br><span class="line">tan(β)      1       0 </span><br><span class="line">0           0       1</span><br></pre></td></tr></table></figure>

<p><strong>缩放：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2  0  0</span><br><span class="line">0  2  0</span><br><span class="line">0  0  1</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>HPDF_Page_SetCharSpace</strong></p>
<p>设置字符间距</p>
</li>
<li><p><strong>HPDF_Page_SetWordSpace</strong></p>
<p>设置单词间距</p>
</li>
<li><p><strong>HPDF_Page_TextRect</strong></p>
<p>支持文字绘制的对齐模式设置</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>大纲绘制</strong>		</p>
<p>​		利用HPDF_CreateOutline函数可以创建树形大纲列表，HPDF_Outline_SetOpened函数可以设置大纲项打开状态，HPDF_Outline_SetDestination可以用于目标位置的关联。</p>
<ul>
<li><pre><code>HPDF_Outline HPDF_CreateOutline(HPDF_Doc pdf, 
            HPDF_Outline parent, 
            const char *title, 
            HPDF_Encoder encoder);
HPDF_STATUS HPDF_Outline_SetOpened  (HPDF_Outline outline, HPDF_BOOL opened)
HPDF_STATUS HPDF_Outline_SetDestination (HPDF_Outline outline, HPDF_Destination dst)
</code></pre>
</li>
</ul>
</li>
</ul>
<p>​		</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jerrywang2013.github.io/2024/05/11/%E7%94%A8libharu%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AA%E5%B0%8F%E4%BD%9C%E4%B8%9A/" data-id="clwbg5x4n000az44qe72ffg9u" data-title="用libharu完成一个小作业" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-宝塔面板ApacheServer配置" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/05/09/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BFApacheServer%E9%85%8D%E7%BD%AE/" class="article-date">
  <time class="dt-published" datetime="2024-05-09T06:31:22.000Z" itemprop="datePublished">2024-05-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/05/09/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BFApacheServer%E9%85%8D%E7%BD%AE/">宝塔面板ApacheServer配置</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>​	Windows + Apache2.4 + PHP7.4 + Mysql5.6</p>
<p>​	直接安装宝塔面板，然后通过宝塔面板安装Apache、PHP、Mysql即可。</p>
<h1 id="WebServer配置"><a href="#WebServer配置" class="headerlink" title="WebServer配置"></a>WebServer配置</h1><p>​	启动宝塔面板，进入宝塔控制后台，点击左侧菜单“网站”，点击“新建站点”，创建一个Web服务器，设置好域名、默认文档、伪静态、网站目录等，下面记录常见可能出问题的点。</p>
<ul>
<li><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>​	在网站设置里头，可以点击左侧“域名管理”来配置域名，域名形如：<a href="http://www.domain.com:port，可以指定端口，不显示指定端口默认就是80。">www.domain.com:port，可以指定端口，不显示指定端口默认就是80。</a></p>
<p>​	这里假设设置的域名是<a href="http://www.crm.com，端口80，这里对应的配置有两个地方：">www.crm.com，端口80，这里对应的配置有两个地方：</a></p>
<ul>
<li><p><strong>告诉apache监听端口</strong></p>
</li>
<li><p><strong>设置站点的VirtualHost配置</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​	需要注意的是，如果我们修改站点的域名映射，比如新加一个域名<a href="http://www.crm-mini.com:8090，宝塔面板会修改apache/conf/httpd.conf文件，在顶部增加Listen">www.crm-mini.com:8090，宝塔面板会修改apache/conf/httpd.conf文件，在顶部增加Listen</a> 8090。问题是这个操作不是可靠的，反复修改站点域名映射有时候就能发现Listen的端口混乱，所以如果发现修改配置后没效果，可以检查下httpd.conf文件配置，手动修改；</p>
<p>​	另外，同一个站点配置多个域名，不要用不同的端口，否则宝塔也会弄混淆，搞错监听端口。不同域名是通过在VirtualHost里头的ServerAlias来配置，例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerAlias www.crm-mini.com 127.0.0.1</span><br></pre></td></tr></table></figure>


</li>
<li><h3 id="伪静态"><a href="#伪静态" class="headerlink" title="伪静态"></a>伪静态</h3><p>​	伪静态是利用url重写技术，实现类似静态url的效果，本质是url rewrite。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mod_rewrite.c&gt;</span><br><span class="line"> RewriteEngine on</span><br><span class="line"> RewriteBase /</span><br><span class="line"> RewriteCond %&#123;REQUEST_FILENAME&#125; !-d</span><br><span class="line"> RewriteCond %&#123;REQUEST_FILENAME&#125; !-f</span><br><span class="line"> RewriteRule ^(.*)$ index.php?s=/$1 [QSA,PT,L]</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure>

<p>​	在web服务器的根目录的.htaccess文件中加入上述伪静态指令，当请求<a target="_blank" rel="noopener" href="http://doamin.com/aaa%E4%BC%9A%E5%B0%86%E8%AE%BF%E9%97%AE%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0index.php/s=aaa%EF%BC%88%E5%BD%93aaa%E4%B8%8D%E6%98%AF%E6%96%87%E4%BB%B6%E6%88%96%E8%80%85%E7%9B%AE%E5%BD%95%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%89">http://doamin.com/aaa会将访问重定向到index.php/s=aaa（当aaa不是文件或者目录的情况下）</a></p>
<p>​	利用mod_rewrite功能，我们可以定义一些规则做请求的重定向。</p>
</li>
<li><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><ul>
<li><p><strong>Rewrite url</strong></p>
<p>​		宝塔面板的重定向也是配置RewriteRule，尝试将&#x2F;crm的请求映射到另外一个web站点失败。</p>
<p>例如：有两个站点 <a target="_blank" rel="noopener" href="http://www.crm-mini.com/">http://www.crm-mini.com</a> 和  <a target="_blank" rel="noopener" href="http://www.crm-normal.com对应本地的两个web目录,现在想只通过http//www.crm-mini.com%E4%B8%80%E4%B8%AA%E5%85%A5%E5%8F%A3%E8%AE%BF%E9%97%AE%E4%B8%A4%E4%B8%AAweb%E7%9B%AE%E5%BD%95%EF%BC%8C%E6%AF%94%E5%A6%82http://www.crm-mini.com/normal/%E8%87%AA%E5%8A%A8%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0crm-normal%E7%9B%AE%E5%BD%95">http://www.crm-normal.com对应本地的两个web目录，现在想只通过http://www.crm-mini.com一个入口访问两个web目录，比如http://www.crm-mini.com/normal/自动重定向到crm-normal目录</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mod_rewrite.c&gt;</span><br><span class="line"> RewriteEngine on</span><br><span class="line"> RewriteRule ^crm(.*)$ http://www.crm-normal.com/$1 [L,R=301]</span><br><span class="line"></span><br><span class="line"> RewriteBase /</span><br><span class="line"> RewriteCond %&#123;REQUEST_FILENAME&#125; !-d</span><br><span class="line"> RewriteCond %&#123;REQUEST_FILENAME&#125; !-f</span><br><span class="line"> RewriteRule ^(.*)$ index.php?s=/$1 [QSA,PT,L]</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure>

<p>​		注意上述第三行，碰到dowmain&#x2F;后面接着是crm就跳转到<a href="http://www.crm-normal.com。`[L,R=301]`">http://www.crm-normal.com。`[L,R=301]`</a> 则指示 Apache 使用 301 永久重定向，L表示停止进一步的重写规则匹配。</p>
</li>
<li><p><strong>Alias</strong></p>
<p>​	用到的一种另外实现方法是在VirtualHost中配置Alias</p>
<pre><code>&lt;VirtualHost *:80&gt;
    ServerAdmin webmaster@yourdomain.com
    DocumentRoot &quot;/var/www/html&quot;
    ServerName www.yourdomain.com
    # 配置针对 crm-normal 的请求
    Alias &quot;/crm-normal&quot; &quot;/var/www/html/crm-normal&quot;
    &lt;Directory &quot;/var/www/html/crm-normal&quot;&gt;
        Options Indexes FollowSymLinks
        AllowOverride All
        Require all granted
    &lt;/Directory&gt;

    # 配置针对 crm-mini 的请求
    Alias &quot;/crm-mini&quot; &quot;/var/www/html/crm-mini&quot;
    &lt;Directory &quot;/var/www/html/crm-mini&quot;&gt;
        Options Indexes FollowSymLinks
        AllowOverride All
        Require all granted
    &lt;/Directory&gt;

    ErrorLog &quot;/var/log/apache2/yourdomain-error.log&quot;
    CustomLog &quot;/var/log/apache2/yourdomain-access.log&quot; combined
&lt;/VirtualHost&gt;
</code></pre>
<p>​		这样配置后，当访问 <code>http://www.yourdomain.com/crm-normal</code> 时，会展示 <code>crm-normal</code> 站点的内容，而访问 <code>http://www.yourdomain.com/crm-mini</code> 则会展示 <code>crm-mini</code> 站点的内容。</p>
<p>​	</p>
<p>重定向能解决只用一个域名一个端口绑定多个web站点，无需每个域名对应一个站点。</p>
</li>
</ul>
</li>
<li></li>
</ul>
<p>​	</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jerrywang2013.github.io/2024/05/09/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BFApacheServer%E9%85%8D%E7%BD%AE/" data-id="clwbg5x4n0009z44q663wfnwo" data-title="宝塔面板ApacheServer配置" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-vscode调试php" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/05/07/vscode%E8%B0%83%E8%AF%95php/" class="article-date">
  <time class="dt-published" datetime="2024-05-07T07:04:35.000Z" itemprop="datePublished">2024-05-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/05/07/vscode%E8%B0%83%E8%AF%95php/">vscode调试php</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><ul>
<li><p>已经安装apache、php（本地测试是用的宝塔面板批量安装的apache2.4以及php7.4)</p>
</li>
<li><p>已经安装vscode（测试安装的是vscode v1.87.0)</p>
</li>
<li><p>安装xdebug。vscode调试借助于xdebug，确保你的php已经安装了此插件，如果没有安装，可以去下载php_xdebug.dll，将其放入到php的ext目录。</p>
</li>
<li><p>vscode安装php debug插件（xdebug.org出品）</p>
</li>
</ul>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ul>
<li><p>在php中配置xdebug</p>
<p>​		打开php.ini文件，假如如下配置，注意端口配置项要和后面项目调试配置json文件中的端口保持一致；最后一行xdebug.remote_autostart&#x3D;1要加上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[XDebug]</span><br><span class="line"></span><br><span class="line">xdebug.profiler_append = 0</span><br><span class="line"></span><br><span class="line">xdebug.profiler_enable = 1</span><br><span class="line"></span><br><span class="line">xdebug.profiler_enable_trigger = 0</span><br><span class="line"></span><br><span class="line">xdebug.profiler_output_dir =&quot;D:\BtSoft\temp\xdebug&quot;</span><br><span class="line"></span><br><span class="line">xdebug.trace_output_dir =&quot;D:\BtSoft\temp\xdebug&quot;</span><br><span class="line"></span><br><span class="line">xdebug.profiler_output_name = &quot;cache.out.%t-%s&quot;</span><br><span class="line"></span><br><span class="line">xdebug.remote_enable = 1</span><br><span class="line"></span><br><span class="line">xdebug.remote_handler = &quot;dbgp&quot;</span><br><span class="line"></span><br><span class="line">xdebug.remote_host = &quot;127.0.0.1&quot;</span><br><span class="line"></span><br><span class="line">xdebug.remote_port = 9999</span><br><span class="line"></span><br><span class="line">zend_extension=php_xdebug.dll</span><br><span class="line"></span><br><span class="line">xdebug.remote_autostart = 1</span><br></pre></td></tr></table></figure>


</li>
<li><p>配置php项目</p>
<p>​	打开php项目，点击调试php，生成项目配置文件.vscode&#x2F;launch.json</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&quot;configurations&quot;: [</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      &quot;name&quot;: &quot;Listen for Xdebug&quot;,</span><br><span class="line"></span><br><span class="line">​      &quot;type&quot;: &quot;php&quot;,</span><br><span class="line"></span><br><span class="line">​      &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line"></span><br><span class="line">​      &quot;port&quot;: 9999,</span><br><span class="line"></span><br><span class="line">​      &quot;xdebugSettings&quot;: &#123;</span><br><span class="line"></span><br><span class="line">​        &quot;max_data&quot;: 10240</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​    &#125;,</span><br></pre></td></tr></table></figure>

<p>​		这里这里的port要和php.ini中配置xdebug的debug监听端口保持一致</p>
<p>​	</p>
<p>​	到此就可以愉快的断点、单步了！</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jerrywang2013.github.io/2024/05/07/vscode%E8%B0%83%E8%AF%95php/" data-id="clwbg5x4m0007z44q41aabiul" data-title="vscode调试php" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-libevent" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/05/05/libevent/" class="article-date">
  <time class="dt-published" datetime="2024-05-05T14:54:09.000Z" itemprop="datePublished">2024-05-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/05/05/libevent/">libevent</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>libevent是一个跨平台高效的异步网络库，支持各平台最高效的异步模型，例如epoll和iocp。</p>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><ul>
<li><p><strong>设置debug级别日志记录策略</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void event_enable_debug_logging(ev_uint32_t which)</span><br></pre></td></tr></table></figure>

<p>描述：</p>
<p>说明： which可为 EVENT_DBG_NONE 和 EVENT_DBG_ALL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define EVENT_DBG_NONE 0</span><br><span class="line"></span><br><span class="line">#define EVENT_DBG_ALL 0xffffffffu</span><br></pre></td></tr></table></figure>

<p>注意：设置为EVENT_DBG_NONE仍可用event_warn(“&#x3D;”);输出日志，因为此函数只控制debug级别的日志策略。</p>
</li>
<li><p><strong>设置自定义日志handler</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef void (*event_log_cb)(int severity, const char *msg);</span><br><span class="line">void event_set_log_callback(event_log_cb cb)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>设置自定义fatal日志handler</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef void (*event_fatal_cb)(int err);</span><br><span class="line">void event_set_fatal_callback(event_fatal_cb cb)</span><br></pre></td></tr></table></figure>

<p>说明：默认libevent检测到不可恢复的内部错误默认行为是调用abort()或者exit()结束当前的进场，你也可以自定义处理致命错误。</p>
</li>
</ul>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>自定义内存分配&#x2F;释放函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void event_set_mem_functions(void *(*malloc_fn)(size_t sz),</span><br><span class="line">                             void *(*realloc_fn)(void *ptr, size_t sz),</span><br><span class="line">                             void (*free_fn)(void *ptr));</span><br></pre></td></tr></table></figure>

<p>说明：比如可以自定义malloc等来实现更加安全的内存管理函数</p>
<h1 id="锁和线程"><a href="#锁和线程" class="headerlink" title="锁和线程"></a>锁和线程</h1><p>Libevent 结构通常可以通过三种方式处理多线程。</p>
<ul>
<li>有些结构本质上是单线程的：同时从多个线程使用它们永远是不安全的。</li>
<li>有些结构可以选择锁定：您可以告诉 Libevent 对于每个对象是否需要同时从多个线程使用它。</li>
<li>有些结构始终是锁定的：如果 Libevent 在锁定支持下运行，那么它们始终可以安全地同时从多个线程使用。</li>
</ul>
<p>​	可以使用windows thread和posix thread，在windows平台，也是可以选择默认的os thread或者pthread。另外还可以使用自定义的线程库，写好自己的内存管理以及同步函数后，需要注册之：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int evthread_set_lock_callbacks(const struct evthread_lock_callbacks *);</span><br><span class="line">void evthread_set_id_callback(unsigned long (*id_fn)(void));</span><br><span class="line">int evthread_set_condition_callbacks(const struct evthread_condition_callbacks *);</span><br></pre></td></tr></table></figure>

<p>​		上述的自定义线程库注册这种c的代码风格你可以理解为面向对象的的接口重写，比如IThread接口定义了create() &#x2F; destroy() &#x2F; lock() &#x2F; unlock()，自定义Thread库需要实现IThread的功能接口。</p>
<h1 id="Event使用"><a href="#Event使用" class="headerlink" title="Event使用"></a>Event使用</h1><h3 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h3><p>​	libevent的event代表一组条件，包括：</p>
<h3 id="事件标志"><a href="#事件标志" class="headerlink" title="事件标志"></a>事件标志</h3><ul>
<li><p>EV_TIMEOUT</p>
<p>​	构造事件的时候EV_TIMEOUT会被忽略，需要在event_add()中设置操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ev1 = event_new(base, 0, EV_TIMEOUT|EV_PERSIST, cb_func,(char*)&quot;Reading event&quot;);</span><br><span class="line">struct timeval tv;</span><br><span class="line">tv.tv_sec = 5;</span><br><span class="line">tv.tv_usec = 0;</span><br><span class="line">event_add(timeout_event, &amp;tv); </span><br></pre></td></tr></table></figure>

<p>相关函数或者宏：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">evtimer_assign(ev, b, cb, arg)</span><br><span class="line">evtimer_new(b, cb, arg)	</span><br><span class="line">evtimer_add(ev, tv)</span><br><span class="line">evtimer_del(ev)</span><br><span class="line">evtimer_pending(ev, tv)</span><br><span class="line">evtimer_initialized(ev)</span><br></pre></td></tr></table></figure>


</li>
<li><p>EV_READ</p>
</li>
<li><p>EV_WRITE</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE); </span><br><span class="line">bufferevent_setcb(bev, conn_readcb, conn_writecb, conn_eventcb, NULL);</span><br><span class="line">bufferevent_enable(bev, EV_READ | EV_WRITE);</span><br></pre></td></tr></table></figure>
</li>
<li><p>EV_SIGNAL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">signal_event = evsignal_new(base, SIGINT, signal_cb, (void *)base);</span><br><span class="line">event_add(signal_event, NULL)</span><br></pre></td></tr></table></figure>

<p>相关函数或者宏：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">evsignal_add(ev, tv)</span><br><span class="line">evsignal_assign(ev, b, x, cb, arg)</span><br><span class="line">evsignal_new(b, x, cb, arg)</span><br><span class="line">evsignal_del(ev)</span><br><span class="line">evsignal_pending(ev, tv)</span><br><span class="line">evsignal_initialized(ev)</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>​		对于大多数后端来说，每个进程只有一个event_base可以监听信号，如果同时向多个event_base添加信号事件，即便信号不同，也只有一个event_base会收到新招。kqueeue后端没有此限制。</p>
</li>
<li><p>用户触发事件</p>
<p>所谓的用户事件就是不与预定义那些事件关联，一般我们把event_new()参数的event参数设置为0即可。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct event_base *base = event_base_new(); </span><br><span class="line">struct event *user_event = event_new(base, -1, 0, user_event_cb, NULL); </span><br><span class="line">event_add(user_event, NULL); </span><br><span class="line">event_active(user_event, EV_WRITE, 0);  // 触发用户事件 </span><br><span class="line">event_base_dispatch(base);</span><br><span class="line">event_free(user_event);</span><br><span class="line">event_base_free(base); </span><br></pre></td></tr></table></figure>

<p>相关函数或者宏：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">evuser_new(b, cb, arg)</span><br><span class="line">evuser_del(ev)</span><br><span class="line">evuser_pending(ev, tv)</span><br><span class="line">evuser_initialized(ev)</span><br><span class="line">evuser_trigger(ev)	</span><br></pre></td></tr></table></figure>


</li>
<li><p>EV_PERSIST</p>
<p>​		通常情况下，当事件被激活后，它会被移除并在回调函数中处理。但是，如果事件被设置了 <code>EV_PERSIST</code> 标志，那么即使在回调函数中处理后，它仍然会留在事件循环中，并等待下一次相同类型的事件发生。使用 <code>EV_PERSIST</code> 标志的事件通常用于需要持续监听某种类型事件的场景，例如长期监听套接字的可读、可写事件等。</p>
</li>
</ul>
<h3 id="event-self-cbarg"><a href="#event-self-cbarg" class="headerlink" title="event_self_cbarg()"></a>event_self_cbarg()</h3><p>​		这个函数是libevent预定义的一个函数，用于返回一个magic指针，告诉event_new创建一个接受自己作为回调函数参数的event。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ev = event_new(base, -1, EV_PERSIST, cb_func, event_self_cbarg());</span><br></pre></td></tr></table></figure>

<p>此函数创建一个event，并且让事件触发的时候执行cb_func()时，将ev参数传给cb_func()。因为调用者调用event_new()时对象还不存在，这里用event_self_cbarg()原理也很简单，相当于给传一个flag告知event_new()。</p>
<h3 id="事件待处理-非待处理"><a href="#事件待处理-非待处理" class="headerlink" title="事件待处理&#x2F;非待处理"></a>事件待处理&#x2F;非待处理</h3><p>​		事件被创建后，不会执行任何操作，直到你通过event_add()将其处于挂起状态。</p>
<ul>
<li><p>event_add</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int event_add(struct event *ev, const struct timeval *tv);</span><br></pre></td></tr></table></figure>

<p>​		对于已挂起的事件调用event_add()，会将其保持挂起状态，并使用提供的超时重新设置。如果事件已经挂起，然后使用超时NULL重新设置它，则event_add()不起作用。</p>
</li>
<li><p>event_del</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int event_del(struct event *ev);</span><br></pre></td></tr></table></figure>

<p>​		event_del会使得事件变为非挂起 、非活动状态。如果event本来是非挂起非激活状态，调用event_del没有效果。</p>
</li>
<li><p>event_remove_timer</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int event_remove_timer(struct event *ev);</span><br></pre></td></tr></table></figure>

<p>​		删除挂起事件的超时，而无需删除事件的IO或者信号组件。如果event没有超时挂起，则event_remove_timer()无效。如果event只有超时但没有IO或者信号组件，则event_remove_timer()和event_del()效果一样。</p>
</li>
</ul>
<h3 id="event优先级"><a href="#event优先级" class="headerlink" title="event优先级"></a>event优先级</h3><ul>
<li><p>event_priority_set</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int event_priority_set(struct event *event, int priority);</span><br></pre></td></tr></table></figure>

<p>​		priority是0-1的数字。当多个事件变为活动状态时，低优先级的不会运行。libevent会运行高优先级事件，然后再次检测事件，只有没有高优先级事件处于活动状态时，低优先级事件才会运行。</p>
</li>
</ul>
<h3 id="检测事件状态"><a href="#检测事件状态" class="headerlink" title="检测事件状态"></a>检测事件状态</h3><ul>
<li><p>常用接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int event_pending(const struct event *ev, short what, struct timeval *tv_out);</span><br><span class="line"></span><br><span class="line">#define event_get_signal(ev) /* ... */</span><br><span class="line">evutil_socket_t event_get_fd(const struct event *ev);</span><br><span class="line">struct event_base *event_get_base(const struct event *ev);</span><br><span class="line">short event_get_events(const struct event *ev);</span><br><span class="line">event_callback_fn event_get_callback(const struct event *ev);</span><br><span class="line">void *event_get_callback_arg(const struct event *ev);</span><br><span class="line">int event_get_priority(const struct event *ev);</span><br><span class="line"></span><br><span class="line">void event_get_assignment(const struct event *event,</span><br><span class="line">        struct event_base **base_out,</span><br><span class="line">        evutil_socket_t *fd_out,</span><br><span class="line">        short *events_out,</span><br><span class="line">        event_callback_fn *callback_out,</span><br><span class="line">        void **arg_out);</span><br><span class="line">struct event *event_base_get_running_event(struct event_base *base);</span><br></pre></td></tr></table></figure>

<p>event_pending()： 判断event是待处理还是活动的。</p>
<p>event_get_fd()&#x2F;event_get_signal()： 返回event的描述符或者信号</p>
<p>event_get_base(): 返回event的event_base</p>
<p>event_get_events(): 返回event的时间标记(EV_READ&#x2F;EV_WRITE等)</p>
<p>event_get_callback(): 返回callback函数</p>
<p>event_get_callback_arg(): 返回回调函数参数指针</p>
<p>event_get_priority(): 返回event优先级</p>
<p>event_base_get_running_event(): 获得指向当前正在运行的event指针</p>
</li>
</ul>
<h3 id="配置一次性事件"><a href="#配置一次性事件" class="headerlink" title="配置一次性事件"></a>配置一次性事件</h3><ul>
<li><p>event_base_once()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int event_base_once(struct event_base *, evutil_socket_t, short,</span><br><span class="line">  void (*)(evutil_socket_t, short, void *), void *, const struct timeval *);</span><br></pre></td></tr></table></figure>

<p>​		参数和event_new()类似，只不过它不支持EV_SIGNAL和EV_PERSIST。在回调完成后，libevent会释放event结构。event_base_once()插入的事件无法删除或者手动激活；如果想取消event，只能使用常规的event_new()或者event_assign()创建。</p>
</li>
</ul>
<h3 id="手动激活"><a href="#手动激活" class="headerlink" title="手动激活"></a>手动激活</h3><ul>
<li><p>event_active</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void event_active(struct event *ev, int what, short ncalls);</span><br></pre></td></tr></table></figure>

<p>​		手动激活的事件不需要先处于挂起状态，并且激活它也不会使其处于挂起状态。</p>
</li>
</ul>
<h3 id="定时器事件优化"><a href="#定时器事件优化" class="headerlink" title="定时器事件优化"></a>定时器事件优化</h3><p><strong>公共超时</strong></p>
<p>​		Libevent 使用二进制堆算法来跟踪待处理事件的超时。二叉堆为添加和删除每个事件超时提供了 O(lg n) 阶的性能。如果您要添加具有随机分布的超时值集的事件，则这是最佳选择，但如果您有大量具有相同超时值的事件，则这不是最佳选择。</p>
<p>例如，假设您有一万个事件，每个事件都应在添加后五秒触发超时。在这种情况下，通过使用双链接队列实现，您可以在每次超时时获得 O(1) 性能。</p>
<p>当然，您不会希望对所有超时值使用队列，因为队列仅对于恒定超时值更快。如果某些超时或多或少是随机分布的，那么将其中一个超时添加到队列将花费 O(n) 时间，这比二进制堆要糟糕得多。</p>
<p>Libevent 可以让您通过将一些超时放入队列中，将其他超时放入二进制堆中来解决此问题。为此，您需要向 Libevent 请求一个特殊的“公共超时”时间值，然后使用该时间值添加具有该时间值的事件。如果您有大量具有单个公共超时的事件，则使用此优化应该可以提高超时性能。</p>
<ul>
<li><strong>TODO 这块得研究一下</strong></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jerrywang2013.github.io/2024/05/05/libevent/" data-id="clwbg5x4m0006z44qf23gch0w" data-title="libevent" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/06/15/cuda%E5%88%9D%E6%8E%A5%E8%A7%A6/">cuda初接触</a>
          </li>
        
          <li>
            <a href="/2024/06/11/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/">git常用操作</a>
          </li>
        
          <li>
            <a href="/2024/06/06/QObject%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/">QObject简单笔记</a>
          </li>
        
          <li>
            <a href="/2024/05/27/c-11/">c++11</a>
          </li>
        
          <li>
            <a href="/2024/05/18/QT/">QT</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>